<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础线性dp例题</title>
    <url>/2020/02/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7dp%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>​    某位大佬曾经说过，dp不会没问题，想不到状态转移方程没问题，多做题就会了。所以，我打算多刷点dp题。那么，先从基础刷起吧。</p>
<h3 id="1-P1091-合唱队形"><a href="#1-P1091-合唱队形" class="headerlink" title="1. P1091 合唱队形"></a>1. <a href="https://www.luogu.com.cn/problem/P1091" target="_blank" rel="noopener">P1091 合唱队形</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    已知序列 $a$ 有 $n$ 个数，通过取出其中一些数可以使他满足严格的先增再减序列，问最少取出几个。</p>
<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    很显然想要求最少取出几个，我们就看严格先增再减的序列的最长长度即可。我们可以用 $g[i]$ 来存储到 $a[i]$ 为止的最长递增子序列的长度，然后用 $l[i]$ 来存储从 $a[i]$ 到序列末尾最长的递减子序列的长度。处理 $g[i]$ 从前往后扫，处理 $l[i]$ 需要从后往前扫。处理完 $f$ 和 $g$ 数组那么就从左到右扫一遍，$ans=max(ans,g[i]+l[i]-1)$ 。答案即是 $n-ans$ 。 </p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn],g[maxn],l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]) g[i]=<span class="built_in">max</span>(g[i],g[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n+<span class="number">1</span>;j&gt;i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]) l[i]=<span class="built_in">max</span>(l[i],l[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxout=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maxout=<span class="built_in">max</span>(maxout,g[i]+l[i]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,n-maxout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1280-尼克的任务"><a href="#2-P1280-尼克的任务" class="headerlink" title="2. P1280 尼克的任务"></a>2. <a href="https://www.luogu.com.cn/problem/P1280" target="_blank" rel="noopener">P1280 尼克的任务</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    尼克的一个工作日为 $n$ 分钟，从第一分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $p+t-1$ 分钟结束。（实在不会总结题意，就直接复制过来了）</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    我们可以设 $f[i]$ 为时间从 $i\sim n$ 所能获得最长空闲时间，最终 $f[1]$ 对应的就是答案。假设在这个 $i$ 分钟有 $k[i]$ 个任务可以，那么我们可以分以下情况转移</p>
<ul>
<li>$k[i]=0$  ， 那么  $f[i]=f[i+1]+1$ </li>
<li>$k[i]\not=0$  ，那么可以循环 $1 \sim k[i]$ 遍历这个时间点开始的任务，$f[i]=max(f[i],f[i+k[i].t])$ </li>
</ul>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(struct task a,struct task b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.l&gt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,n,k; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t[i].l,&amp;t[i].r);</span><br><span class="line">		p[t[i].l]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(t+<span class="number">1</span>,t+<span class="number">1</span>+k,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!p[i])</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i]=dp[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i]=<span class="built_in">max</span>(dp[i],dp[i+t[cnt].r]);</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#617</title>
    <url>/2020/02/05/Codeforces-617/</url>
    <content><![CDATA[<h3 id="A-Array-with-Odd-Sum"><a href="#A-Array-with-Odd-Sum" class="headerlink" title="A. Array with Odd Sum"></a>A. <a href="https://codeforces.com/contest/1296/problem/A" target="_blank" rel="noopener">Array with Odd Sum</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    给出包含 <strong>n</strong> 个正整数的序列 <strong>a</strong> ，你可以把任何一个元素 $a_i$ ，赋值给另一个元素 $a_j$ ($i\neq j$) ，问通过任意此操作能否将序列 <strong>a</strong> 的和变为奇数。可以输出 <strong>YES</strong> ,不可以输入 <strong>NO</strong>.</p>
<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    首先当起始和为奇数的时候，就直接可输出 <strong>YES</strong> 了，如果是偶数的话，我们可以发现，如果序列元素中同时包含奇数和偶数，那么就是可以的，否则不可以。</p>
<a id="more"></a>

<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,flag,sum,p,flag1,flag2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		flag2=flag1=<span class="literal">false</span>;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			sum+=p;</span><br><span class="line">			<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">1</span>) flag1=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) flag2=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag1&amp;&amp;flag2) flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="B-Food-Buying"><a href="#B-Food-Buying" class="headerlink" title="B. Food Buying"></a>B. <a href="https://codeforces.com/contest/1296/problem/B" target="_blank" rel="noopener">Food Buying</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    初始有 <strong>s</strong> 个货币，每次花费 <strong>x</strong> 个货币会返还 $\lfloor{\frac{x}{10}}\rfloor$ 个货币，问最多共能花费多少货币。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    贪心即可。剩余的货币一直除10累加，注意最终剩余不足10的处理。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p=s;</span><br><span class="line">			<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(p)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(p&lt;<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">				now=p/<span class="number">10</span>;</span><br><span class="line">				s+=now;</span><br><span class="line">				p%=<span class="number">10</span>;</span><br><span class="line">				p+=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-Yet-Another-Walking-Robot"><a href="#C-Yet-Another-Walking-Robot" class="headerlink" title="C. Yet Another Walking Robot"></a>C. <a href="https://codeforces.com/contest/1296/problem/C" target="_blank" rel="noopener">Yet Another Walking Robot</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    一个机器人初始在 $(0,0)$ 点，规定 <strong>‘L’</strong>  ，<strong>‘R’</strong> ，<strong>‘U’</strong> ，<strong>‘D’</strong>  分别对应向左，向右，向上和向下。给定一段包含上述字母的序列 <strong>s</strong> ，机器人遵循指引序列移动。如果删除一段连续序列可使得机器人最终到达终点不变，问删除的最短序列的起始和终点为多少。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    想了半天想了错误的解法。。一直在考虑 <strong>L</strong> 和 <strong>R</strong> 数相等，<strong>U</strong> 和 <strong>D</strong> 相等，通过这个方法来找序列。看了题解才发现是通过坐标来看。我们可以开一个map记录坐标和步数的关系，从左到右扫序列，如果没有到达过这个坐标，就记录当前是第几次移动到达这个坐标的，如果到达过的话，就看上一次到达这个坐标时的步数，计算他们的序列长度，如果小于计算的就更新答案。因为是需要找最小的，因此只需要记录上一次到达的步数即可。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">-1</span>,r=n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pos; <span class="comment">//first为x second为y</span></span><br><span class="line">		<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; last;  </span><br><span class="line">		pos.first=pos.second=<span class="number">0</span>;</span><br><span class="line">		last[pos]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'L'</span>) pos.first--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) pos.first++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'U'</span>) pos.second++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'D'</span>) pos.second--;</span><br><span class="line"><span class="comment">/*			</span></span><br><span class="line"><span class="comment">			if(i==2)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				printf("%d %d\n",pos.first,pos.second);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">*/</span>			</span><br><span class="line">			<span class="keyword">if</span>(last.count(pos)!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> p=i-last[pos];</span><br><span class="line"><span class="comment">//				if(i==2) printf("%d %d\n",i,last[pos]);</span></span><br><span class="line">				<span class="keyword">if</span>(p&lt;r-l)</span><br><span class="line">				&#123;</span><br><span class="line">					l=last[pos];</span><br><span class="line">					r=i;	</span><br><span class="line">				&#125;	</span><br><span class="line"><span class="comment">//				if(i==2 )printf("%d %d\n",l,r);</span></span><br><span class="line">			&#125;</span><br><span class="line">			last[pos]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,l+<span class="number">1</span>,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="D-Fight-with-Monsters"><a href="#D-Fight-with-Monsters" class="headerlink" title="D. Fight with Monsters"></a>D. <a href="https://codeforces.com/contest/1296/problem/D" target="_blank" rel="noopener">Fight with Monsters</a></h3><hr>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>​    由你先手和对手轮流击打 $n$ 个血量为 $h_i$ 的小怪兽，你可以对怪物造成 $a$ 点伤害，对手可以造成 $b$ 点伤害。你有 $k$ 次机会使对手跳过他的回合。当小怪兽血量 $h\le0$ 时视为被击杀，当你击杀怪兽，你获得一分，当对手击杀，你不得分。求你最多能获得多少分数。</p>
<hr>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>​    先看一下对于每个怪兽我们要击杀需要花费多少机会，你和对手一个回合会击杀怪兽 $a+b$ 点血量，因此你可以一直将回合进行到怪兽血量小于$a+b$，接下来我们可以分两种情况讨论。</p>
<ul>
<li><p>怪兽血量为0，那么我们就需要回溯对手最后一个回合，然后需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil$ 次</p>
</li>
<li><p>怪兽血量不为0，我们需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil-1$ 次，注意这里不能直接写 $\lceil\frac{h_i}{a}\rceil$ 次，因为如果 $h_i$ 刚好能被 $a$ 整除，后面这个写法就错了。</p>
</li>
</ul>
<p>​    计算出了每个怪兽需要花费的机会那么就好做了，就变成了一个贪心问题，我们去尽可能得击杀需要的机会少的，当机会消耗完毕，得到的就是答案了。</p>
<hr>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,k;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;a,&amp;b,&amp;k);</span><br><span class="line">	<span class="keyword">int</span> p=a+b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">		h[i]%=p;</span><br><span class="line">		<span class="keyword">if</span>(h[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			h[i]+=b;</span><br><span class="line">			f[i]=<span class="built_in">ceil</span>((<span class="keyword">double</span>)h[i]/a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> f[i]=<span class="built_in">ceil</span>((<span class="keyword">double</span>)h[i]/a)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(f+<span class="number">1</span>,f+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k-f[i]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		ans++;</span><br><span class="line">		k-=f[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷的一些搜索题</title>
    <url>/2020/02/04/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="1-P1378-油滴扩展"><a href="#1-P1378-油滴扩展" class="headerlink" title="1. P1378 油滴扩展"></a>1. <a href="https://www.luogu.com.cn/problem/P1378" target="_blank" rel="noopener">P1378 油滴扩展</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    在长方形框中，最多有 n ($0\le{n}\le6$)个相异点，在框中点上依次放置可扩展的油滴，当碰到其他油滴边界或者长方形边框时会停止，扩展呈圆形展开。放置下一个时会确保上一个已经扩展完成。问通过变换放置顺序可使得最终框中剩下的面积最小为多少。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    这是个裸的dfs，情况最多也就 $6! = 720$ 种，所以我们可以只需要设置一个vis数组来记录是否已经放置过这个油滴，计算已扩展油滴和将要放的油滴之间的距离可以用 <strong>两点距离-扩展油滴的半径</strong>来实现 ，但是有个坑需要注意，就是当一个油滴已经放在已经有扩展油滴覆盖的区域，那么他俩的距离是0，而不是负数，因此在计算半径的时候需要优化一下。</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,y,xx,yy;</span><br><span class="line"><span class="keyword">double</span> rx[maxn];</span><br><span class="line"><span class="keyword">double</span> maxans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dx[maxn],dy[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">diss</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span> <span class="comment">//计算两点距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">radius</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//计算半径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="built_in">min</span>(<span class="built_in">abs</span>(dx[p]-x),<span class="built_in">min</span>(<span class="built_in">abs</span>(dy[p]-y),<span class="built_in">min</span>(<span class="built_in">abs</span>(dx[p]-xx),<span class="built_in">abs</span>(dy[p]-yy))));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i]&amp;&amp;i!=p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> dis=diss(dx[i],dy[i],dx[p],dy[p]);</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dis-rx[i],<span class="number">0.0</span>)); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowcnt,<span class="keyword">double</span> area)</span> <span class="comment">//area为拓展总面积 nowcnt为现在已经放置了几个 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nowcnt==n)</span><br><span class="line">	&#123;</span><br><span class="line">		maxans=<span class="built_in">max</span>(maxans,area);</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i]=<span class="literal">true</span>;</span><br><span class="line">			rx[i]=radius(i);</span><br><span class="line">			dfs(nowcnt+<span class="number">1</span>,area+pi*rx[i]*rx[i]);</span><br><span class="line">			rx[i]=<span class="number">0</span>;</span><br><span class="line">			vis[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;xx,&amp;yy);</span><br><span class="line">	<span class="keyword">double</span> sum=<span class="built_in">abs</span>(x-xx)*<span class="built_in">abs</span>(y-yy); <span class="comment">//矩形总面积 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;dx[i],&amp;dy[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%0.0lf"</span>,sum-maxans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1120-小木棍"><a href="#2-P1120-小木棍" class="headerlink" title="2. P1120 小木棍"></a>2. <a href="https://www.luogu.com.cn/problem/P1120" target="_blank" rel="noopener">P1120 小木棍</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    将一些长度为 <strong>x</strong> 的等长木棍全部切成 <strong>n</strong> 段不超过50的小木棍，求长木棍长度 <strong>x</strong> 的最小长度。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    首先这个题是有个坑的，题目给出来了，输入的小木棍长度可能会有大于50的，因此我们需要筛掉它。</p>
<p>​    那么很显然这个题是一道搜索题，我们可以写搜索函数<code>dfs(int nowcnt,int nxt,int lenlast,int len)</code>.上述参数分别表示: 现在在寻找第几根小木棍，我们寻找下一个拼接段应该从哪里开始找，当前这根拼接还需要多长，以及我们要拼成多长的木棍。搜索的复杂度这么高，对于 $n\le65$ 的数据肯定不能直接无脑搜，因此需要想想怎么优化。</p>
<ul>
<li><p>首先要从大到小排序这个很关键的，因为你从大的先凑就能够保证后面选择的时候容错率更高一些。</p>
</li>
<li><p>很显然我们可以剪掉当 lenlast&lt;0 的情况，这个地方我们可以在拼接的时候就判断，也可以在拼接后判断。</p>
</li>
<li><p>在寻找下一个拼接片段的时候，我们可以通过二分搜索来查找下一个不超过lenlast的片段，我选择了直接用STL的库中的lower_bound函数。<del>(其实因为是我的二分总是写炸)</del></p>
</li>
<li><p>再就是我们对于相等片段的处理，很显然当前片段不符合情况那么与他等长的也都不会符合，因此我们可以直接循环筛掉。当然更优的方法可以提前处理一个跳表，直接跳到下一个与他不同的位置。</p>
</li>
<li><p>最后这个优化还是挺难想的，就是如果当前片段搜下去已经不符合情况，但是当前的lenlast是等于当前片段长度的，也就是说你正好用了尽可能满足条件的一个方案，也还是没达到目的，你们你继续往下搜，用比他还要劣的方案肯定也是不可能的，因此直接就break跳出循环不需要往下搜了。</p>
<p><del>不过就算加了这么多优化我还是T了三个点，直接 O<sub>2</sub>一开跑路了嘿嘿</del></p>
</li>
</ul>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],temp,icnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> totlen,maxlen,cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],finish;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowcnt,<span class="keyword">int</span> nxt,<span class="keyword">int</span> lenlast,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//nowcnt:现在正在拼接第几根 </span></span></span><br><span class="line"><span class="function"><span class="comment">//nxt:我们应该从哪里开始检索 </span></span></span><br><span class="line"><span class="function"><span class="comment">//lenlast:现在拼接还需要多少才能拼接完成 </span></span></span><br><span class="line"><span class="function"><span class="comment">//len:每根木棍的理想长度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lenlast&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(lenlast==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		printf("test\n");</span></span><br><span class="line">		<span class="keyword">if</span>(nowcnt==cnt) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">			finish=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(p=<span class="number">1</span>;p&lt;=n;p++) <span class="keyword">if</span>(!vis[p]) <span class="keyword">break</span>;</span><br><span class="line">		vis[p]=<span class="literal">true</span>;</span><br><span class="line">		dfs(nowcnt+<span class="number">1</span>,p+<span class="number">1</span>,len-a[p],len);</span><br><span class="line">		<span class="keyword">if</span>(finish) <span class="keyword">return</span> ;</span><br><span class="line">		vis[p]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=lower_bound(a+nxt,a+<span class="number">1</span>+n,lenlast,greater&lt;<span class="keyword">int</span>&gt;())-a;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			printf("what\n");</span></span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;lenlast-a[i]&gt;=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i]=<span class="literal">true</span>;</span><br><span class="line">				dfs(nowcnt,i+<span class="number">1</span>,lenlast-a[i],len);</span><br><span class="line">				<span class="keyword">if</span>(finish) <span class="keyword">return</span>;</span><br><span class="line">				vis[i]=<span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">while</span>(a[i+<span class="number">1</span>]==a[i]) i++;</span><br><span class="line">				<span class="keyword">if</span>(i==n) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span>(lenlast-a[i]==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;<span class="number">50</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> a[i]=temp;</span><br><span class="line">		maxlen=<span class="built_in">max</span>(maxlen,a[i]);</span><br><span class="line">		totlen+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">while</span>(!a[n]) n--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=maxlen;l&lt;=totlen;l++)</span><br><span class="line">	&#123;</span><br><span class="line">		finish=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(totlen%l!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		cnt=totlen/l;</span><br><span class="line">		vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">2</span>,l-a[<span class="number">1</span>],l);</span><br><span class="line">		vis[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(finish) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-YOKOF-Power-Calculus"><a href="#3-YOKOF-Power-Calculus" class="headerlink" title="3. YOKOF - Power Calculus"></a>3. <a href="https://www.spoj.com/problems/YOKOF/" target="_blank" rel="noopener">YOKOF - Power Calculus</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    给出一个正整数 <strong>n</strong> ，只能使用乘法或者除法，可以乘除 $x$ 或者过程中产生的中间值 $x^i$ ，输出使得 $x$ 变为 $x^n$ 所需的最少步数。$(n\le100)$</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    很显然我们一直是对指数进行操作，看似是乘除，直接转化为指数的加减。因此我们需要记录一个状态数组来记录乘除中间所产生的 $x^i$ ，以便后续过程中使用。但是这道题直接搜索的话，又会超时，因为他把大量的时间浪费在高深度上，但是这个却不一定是最优解。因此需要用到迭代加深搜索(IDDFS).</p>
<blockquote>
<p>迭代加深搜索(IDDFS)主要用于处理一些题目可能会搜到很深但是答案却不是最优的问题。有的时候dfs搜索的深度是无穷的，而且他的复杂度是呈指数级增长的，因此这其中某些情况就可以用IDDFS，在每次搜索的时候，我们给深度一个限制，当达到这个最大深度却没有得到答案的时候，就返回，然后逐步提升深度，这样我们就可以避免将时间浪费在那些无谓的高深度搜索上了。</p>
</blockquote>
<p>$$<br>\sum_{i=0}^n2^i=2^{n+1}-1（指数级别增长实例）<br>$$</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1005</span>]; <span class="comment">//用来记录每次生成的中间状态 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> dep,<span class="keyword">int</span> maxdep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">0</span>||dep&gt;maxdep||k&lt;&lt;(maxdep-dep)&lt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==n||k&lt;&lt;(maxdep-dep)==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	x[dep]=k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=dep;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dfs(k+x[i],dep+<span class="number">1</span>,maxdep)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//对应乘法 </span></span><br><span class="line">		<span class="keyword">if</span>(dfs(k-x[i],dep+<span class="number">1</span>,maxdep)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//对应除法 </span></span><br><span class="line">	&#125;</span><br><span class="line">	x[dep]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dfs(<span class="number">1</span>,<span class="number">0</span>,i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>洛谷提高历练地</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX的一些总结</title>
    <url>/2020/02/03/LaTeX%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h3><!-- 空一行 -->

<p><img src="/images/xila.png" alt="xila"></p>
<a id="more"></a>

<hr>
<h3 id="一些技巧和特殊符号"><a href="#一些技巧和特殊符号" class="headerlink" title="一些技巧和特殊符号"></a>一些技巧和特殊符号</h3><ul>
<li><p>上标：num_i  -&gt;  $num_i$</p>
</li>
<li><p>下标：e^x -&gt;  $e^x$  （如果下标或上标不明显，可嵌套多层来达到目的）</p>
<ul>
<li>上下标是一串字符的话可用{}括起来表示</li>
</ul>
</li>
<li><p>根号：\sqrt[3]{x} -&gt; $\sqrt[3]{x}$</p>
</li>
<li><p>省略号： 在下面\dots -&gt; $\dots$     在中间\cdots -&gt;  $\cdots$</p>
</li>
<li><p>方框:  \boxed{example}  -&gt;  $\boxed{example}$   (还有一个\fbox与此类似  \fobx{example} -&gt; $\fbox{example}$) </p>
</li>
<li><p>字体加粗:  \mathbf{example} -&gt; $\mathbf{example}$ </p>
</li>
<li><p>字体斜体且加粗:  \boldsymbol{example}  -&gt;  $\boldsymbol{example}$</p>
</li>
<li><p>插入普通文本（自适应大小）:  \text{测试}  -&gt; $\text{测试}$  </p>
<p><img src="/images/specialsign.png" alt="specialsign"></p>
<p><img src="/images/specialsign2.png" alt="specialsign"></p>
</li>
</ul>
<hr>
<h3 id="一些基本符号"><a href="#一些基本符号" class="headerlink" title="一些基本符号"></a>一些基本符号</h3><ul>
<li><p>求和:  \sum_1^n  -&gt;  $\sum_1^n$ </p>
</li>
<li><p>积分:  \int_1^n -&gt; $\int_1^n$   \iint -&gt; $\iint$  以此类推$\cdots$</p>
</li>
<li><p>极限:  \lim_{x \to +\infty}  -&gt; $\lim_{x \to +\infty}$</p>
</li>
<li><p>分数:  \frac{1}{2} -&gt; $\frac{1}{2}$   如果要写多层分数可以用\cfrac （可以避免字母逐层缩小的限制）</p>
</li>
<li><p>组合数: \binom{5}{2} -&gt; $\binom{5}{2}$</p>
</li>
<li><p>下取整: \lfloor{x}\rfloor -&gt;  $\lfloor{x}\rfloor$</p>
</li>
<li><p>下取整: \lceil{x}\rceil -&gt; $\lceil{x}\rceil$</p>
<p><img src="/images/qita.png" alt="qita"></p>
<p><img src="/images/qita2.png" alt="qita2"></p>
</li>
</ul>
<hr>
<h3 id="关于矩阵和行列式"><a href="#关于矩阵和行列式" class="headerlink" title="关于矩阵和行列式"></a>关于矩阵和行列式</h3><ul>
<li>矩阵：用法如下，元素中间使用&amp;来分割同行元素，用\\来换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">	1 &amp; 2 &amp; 3\\</span><br><span class="line">	4 &amp; 5 &amp; 6\\</span><br><span class="line">	7 &amp; 8 &amp; 9\\</span><br><span class="line">\end&#123;matrix&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>\begin{matrix}<br>    1 &amp; 2 &amp; 3\\<br>    4 &amp; 5 &amp; 6\\<br>    7 &amp; 8 &amp; 9\\<br>\end{matrix}<br>$$</p>
<ul>
<li>行列式: 与矩阵相似，加上行列式的名字以及左右分割线即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;  \left|</span><br><span class="line">	\begin&#123;matrix&#125;</span><br><span class="line">	1 &amp; 2 &amp; 3 \\</span><br><span class="line">	4 &amp; 5 &amp; 6 \\</span><br><span class="line">	7 &amp; 8 &amp; 9 \\</span><br><span class="line">	\end&#123;matrix&#125;</span><br><span class="line">	\right|</span><br></pre></td></tr></table></figure>


<p>$$<br>A=  \left|<br>    \begin{matrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9 \\<br>    \end{matrix}<br>    \right|<br>$$</p>
<hr>
<h3 id="分段函数和方程组"><a href="#分段函数和方程组" class="headerlink" title="分段函数和方程组"></a>分段函数和方程组</h3><ul>
<li>分段函数：写法如下，每一个条件用 表达式和条件之间用 <strong>&amp;</strong> 连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x)&#x3D;</span><br><span class="line">	\begin&#123;cases&#125;</span><br><span class="line">		x&#x2F;2, &amp; &#123;n&gt;2&#125;\\</span><br><span class="line">		2x , &amp; &#123;n&#x3D;2&#125;\\</span><br><span class="line">		3x , &amp; &#123;n&lt;2&#125;\\</span><br><span class="line">	\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>f(x)=<br>    \begin{cases}<br>        x/2, &amp; {n&gt;2}\\<br>        2x , &amp; {n=2}\\<br>        3x , &amp; {n&lt;2}\\<br>    \end{cases}<br>$$</p>
<ul>
<li>方程组: 写法如下，不是一个对称的，注意left后面为{ ，right后面为. 用\\换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\left\&#123;</span><br><span class="line">	\begin&#123;array&#125;&#123;&#125;</span><br><span class="line">		a_1x+b_1y+c_1z&#x3D;d_1\\</span><br><span class="line">		a_2x+b_2y+c_2z&#x3D;d_2\\</span><br><span class="line">		a_3x+b_3y+c_3z&#x3D;d_3</span><br><span class="line">	\end&#123;array&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure>


<p>$$<br>\left\{<br>    \begin{array}{}<br>        a_1x+b_1y+c_1z=d_1\\<br>        a_2x+b_2y+c_2z=d_2\\<br>        a_3x+b_3y+c_3z=d_3<br>    \end{array}<br>\right.<br>$$</p>
<hr>
<p><strong>Ps: 上面的矩阵，行列式，分段函数和方程组有一个问题需要我们注意，因为反斜杠 \ 需要转义，那么对于每次换行需要两个\\ ，也就是说你打的时候总需要打四个，对于前面声明begin和end，或者left和right前面的反斜杠，你打的时候就要打两个，对于markdown编辑器里面编辑LaTeX可能会自适应，不会自动转义，但是我们推博客的时候，一定要注意这个地方，不然会显示错误。也就是对于上述描述中的反斜杠，都要按两倍来写</strong></p>
<hr>
<p>先总结这么多，后面那些进阶的用到了再总结。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://blog.csdn.net/happyday_d/article/details/83715440" target="_blank" rel="noopener">Typora中利用LaTeX 插入数学公式</a></li>
<li><a href="https://www.jianshu.com/p/22117d964baf" target="_blank" rel="noopener">LATEX 公式总结</a></li>
</ul>
]]></content>
      <categories>
        <category>不务正业</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesER81</title>
    <url>/2020/02/02/CodeforcesER81/</url>
    <content><![CDATA[<h3 id="A-Display-The-Number"><a href="#A-Display-The-Number" class="headerlink" title="A : Display The Number"></a>A : <a href="https://codeforces.com/contest/1295/problem/A" target="_blank" rel="noopener">Display The Number</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    用一定数目的灯管，显示尽可能大的数</p>
<p><img src="https://s2.ax1x.com/2020/02/02/1te6Re.md.png" alt="A"></p>
<a id="more"></a>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    因为位数多的肯定更大，所以肯定用尽量少的灯管搭建单个数字更好，最少的两个分别是两个灯管显示的1，以及三个灯管显示的7，所以就是尽可能的用1，如果最后剩余正好三个就显示7。这就转化成了判断奇数还是偶数的题，奇数就显示7111····，偶数就是1111···。注意要把7放在前面（我就踩坑了）。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"7"</span>);</span><br><span class="line">			n-=<span class="number">3</span>;</span><br><span class="line">			<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="B-Infinite-Prefixes"><a href="#B-Infinite-Prefixes" class="headerlink" title="B : Infinite Prefixes"></a>B : <a href="https://codeforces.com/contest/1295/problem/B" target="_blank" rel="noopener">Infinite Prefixes</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    给定一段01字符串 <strong>s</strong> 为循环节，得到无限循环的01字符串 <strong>t</strong>，求 <strong>t</strong> 中有多少前缀满足0个数-1个数等于期望值<strong>x</strong> （空前缀也算是一个前缀）</p>
<blockquote>
<p>前缀：例如”abcd”的前缀包括 “ “,”a”,”ab”,”abc”,”abcd”.</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>首先我们先记录循环节 <strong>s</strong> 中每个位置对应的01个数差，记为$num_i，i\in[1,n]$ （ <strong>s</strong> 长度记为n） </p>
<ul>
<li>首先我们可以发现当 <strong>x=0</strong> 的时候，空前缀也会有贡献，因此不能忽略空前缀。</li>
<li>如果循环节 <strong>s</strong> 的01数相等，那么我们可以发现最后循环节一位$num_n$总为0，那么可以分两种情况来讨论<ul>
<li>如果循环节中存在大于等于1个前缀满足期望值x，那么就有无限个满足，因此输出-1</li>
<li>如果循环节 <strong>s</strong> 中不存在满足期望值的前缀，那么 <strong>t</strong> 中也一定不存在</li>
</ul>
</li>
</ul>
<ul>
<li>再来看一般情况，如果一个前缀中包含多个循环节 <strong>s</strong> ,那么前面每个循环节对于最终01个数差的贡献总为$num_n$，因此我们可以用所期望的值 <strong>x</strong>，利用1~n 循环减去每一位的 $num_i$，如果所得是$num_n$的非负倍数，那么就是符合期望的，否则不是。(本来一直这里不太明白，后来发现对于循环节中的每一个位置，在后续循环的过程中，如果$num_n$不为0，那么这个位置每次对应的值总是唯一的)</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> t,cnt,n,x;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				num[i]=num[i<span class="number">-1</span>]+<span class="number">1</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> num[i]=num[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(num[i]==x) flag=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p=num[n];</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="literal">true</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> m=x-num[i];</span><br><span class="line">				<span class="keyword">if</span>(m%p==<span class="number">0</span>&amp;&amp;m/p&gt;=<span class="number">0</span>) </span><br><span class="line">				&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>) cnt++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="C-Obtain-The-String"><a href="#C-Obtain-The-String" class="headerlink" title="C : Obtain The String"></a>C : <a href="https://codeforces.com/contest/1295/problem/C" target="_blank" rel="noopener">Obtain The String</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    给定字符串 <strong>s</strong> 和 <strong>t</strong> ，每次从 <strong>s</strong> 中选取子序列放入起始为空串的 <strong>z</strong> 后，问最少需要多少次操作使得 <strong>z=t</strong></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    看了小姜老师的博客解法说是贪心，想了好一会，好像确实是可以贪心的···? 设置两个指针从 <strong>s</strong> 和 <strong>t</strong> 串的头部开始扫，对于 <strong>t</strong> 串中的每个字母，循环扫 <strong>s</strong> 串在其中找与它相同的，最终的答案就是扫 <strong>s</strong> 串的次数。(小姜老师说这个实质上就是每次尽可能找尽可能多的后缀，仔细想想确实是这样。)不过这么一直暴力扫下去肯定不是最优的方法，想办法去优化。还是借鉴大佬的想法用一个lens*26的跳表，然后O(lent)扫一遍 <strong>t</strong> 即可.</p>
<blockquote>
<p>跳表nxt的作用，用于寻找下一个所寻找字符在s中的位置。</p>
<p>nxt[x][y]用于指向从x位置开始下一个y的位置+1 （next在C++属于保留字，注意不要踩坑）</p>
</blockquote>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn],t[maxn];</span><br><span class="line"><span class="keyword">int</span> nxt[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> p,lens,lent;</span><br><span class="line"><span class="keyword">int</span> pos,ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">	<span class="keyword">while</span>(p--)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">		lent=<span class="built_in">strlen</span>(t),lens=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//		printf("%d",lens);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++)</span><br><span class="line">		&#123;</span><br><span class="line">			nxt[lens+<span class="number">1</span>][c]=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=lens;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]-<span class="string">'a'</span>==c)</span><br><span class="line">				&#123;</span><br><span class="line">					nxt[i][c]=i+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> nxt[i][c]=nxt[i+<span class="number">1</span>][c];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pos=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lent;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			pos=nxt[pos][(<span class="keyword">int</span>)t[i]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				pos=<span class="number">1</span>;</span><br><span class="line">				pos=nxt[pos][(<span class="keyword">int</span>)t[i]-<span class="string">'a'</span>];</span><br><span class="line">				<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
