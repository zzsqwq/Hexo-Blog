<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排位赛一和二记录</title>
    <url>/2020/08/15/%E6%8E%92%E4%BD%8D%E8%B5%9B%E4%B8%80%E5%92%8C%E4%BA%8C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="A-兔子的区间密码"><a href="#A-兔子的区间密码" class="headerlink" title="A. 兔子的区间密码"></a>A. <a href="https://ac.nowcoder.com/acm/contest/6954/A">兔子的区间密码</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个区间$[L,R]$ ，求从这个区间任意取两个整数(可以相同)，两者异或后能得到的最大值是多少？</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们想一下特例，当 $L==R$ 的时候，那么只能是L和他自己异或，就是0了。</p>
<p>​    &nbsp;&nbsp;&nbsp;然后可以分两部分来想，设区间端点 $L,R$ 的二进制最高位，从右往左开始数位置分别为 $p_1,p_2$ </p>
<ul>
<li>如果 $p_1 \neq p_2 $ ，那么必然是 $p_1 &lt; p_2$ ，我们很容易发现这时候肯定可以取到 $2^{p_2-1}-1 和 2^{p_2-1}$ ，那么两者异或一下就是最大的，答案为 $2^{p_2}$ </li>
<li>如果 $p_1 == p_2$ ，那么我们可以转化为更小规模的问题，就是区间为 $[L-2^{p^1-1},R-2^{p_1-1}]$ 。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line">ll l,r;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = log2(l),p2 = log2(r);</span><br><span class="line">            <span class="keyword">while</span>(p1 == p2 &amp;&amp; l != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l^=(<span class="number">1L</span>L&lt;&lt;p1);</span><br><span class="line">                r^=(<span class="number">1L</span>L&lt;&lt;p1);</span><br><span class="line">                p1 = log2(l),p2=log2(r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((<span class="number">1L</span>L&lt;&lt;(p2+<span class="number">1</span>))<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="B-猴子排序的期望"><a href="#B-猴子排序的期望" class="headerlink" title="B. 猴子排序的期望"></a>B. <a href="https://ac.nowcoder.com/acm/contest/6954/B">猴子排序的期望</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有 $N$ 张卡片，每个上面都写着一个大写字母，问随便扔一次这 $N$ 张的卡片就已经按字典序排好的概率，答案用分字为1的形如 $1/x$ 的形式表示。$( 1&lt;N &lt; 100)$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这题很显然是道数学排列组合题，我们设每个字母重复出现的次数为 $p[i]$ ，好比字母为$A$的卡片出现了两次，那么就 $p[‘A’]$ 为2。</p>
<p>​    &nbsp;&nbsp;&nbsp;那么答案就是如下<br>$$<br>ans = \frac{N!}{\Pi_{i=’A’}^{i=’Z’}(p[i]!)}<br>$$<br>​    &nbsp;&nbsp;&nbsp;这题主要难点大概是在高精，因为可能会涉及到 $100!$ 这种丧心病狂的东西，所以就用笨比的方法写了一发python。<del>其实是高级的算法不会用python写，C++乘法的高精忘掉了</del>。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">s = input()</span><br><span class="line">s[<span class="number">0</span>:n:<span class="number">1</span>]</span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    ans = ans*i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">          count = count + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= <span class="number">0</span>:</span><br><span class="line">        ans = ans//count  <span class="comment">#这里本来//写成了/,连WA3发</span></span><br><span class="line">print(<span class="string">"1/"</span>,end=<span class="string">""</span>)</span><br><span class="line">print(int(ans))</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="A-愤怒的巨巨"><a href="#A-愤怒的巨巨" class="headerlink" title="A. 愤怒的巨巨"></a>A. <a href="https://ac.nowcoder.com/acm/contest/6955/A">愤怒的巨巨</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;已知香蕉的次品率为 $p(0\le p\le 1)$  ，如果想要买到好香蕉则买香蕉个数的期望值是多少。如果买不到好香蕉，输出”Sorrry,JuJu!”(忽略双引号)。否则输出期望值的最简分数形式：c/d. $p$ 的最多位数为6。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先理解一下题意，好比次品率 $p$ 为0.5，则期望的个数为2个。如果次品率 $p$ 为 0.25，则可以说平均买四个有一个次品，那么最少需要的买的个数其实是 $3/4$ 。</p>
<p>​    &nbsp;&nbsp;&nbsp;再者特判一下 $p == 0$ 以及 $p==1$ 的情况，分别输出 <strong>1/1</strong> 和 <strong>Sorrry,JuJu!</strong>  。</p>
<p>​    &nbsp;&nbsp;&nbsp;然后其实可以看一下非次品率 $k = 1-p$ ，然后其实就是一个最大公约数问题了。只需要把 $k$ 转换成分数形式，然后用最大公约数约分一下，再取一个倒数即可。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != <span class="string">'0'</span>) flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1/1"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'1'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Sorrry,JuJu!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = k*<span class="number">10</span>+str[i]-<span class="string">'0'</span>;</span><br><span class="line">        mod *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = mod - k;</span><br><span class="line">    <span class="keyword">int</span> p = gcd(m,mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,mod/p,m/p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="B-兔子的逆序对"><a href="#B-兔子的逆序对" class="headerlink" title="B. 兔子的逆序对"></a>B. <a href="https://ac.nowcoder.com/acm/contest/6955/C">兔子的逆序对</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个区间 $[L,R]$ ，然后给出 $m$ 次翻转操作，通过给出子区间左右端点，反转该区间。每翻转一次，要求给出区间 $[L,R]$ 逆序对的奇偶性，如果是奇数，输出 <strong>dislike</strong> ，如果是偶数，输出 <strong>like</strong> 。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先用归并 / 树状数组的方法，求出来区间 $[L,R]$ 的逆序对 $ans$。</p>
<p>​    &nbsp;&nbsp;&nbsp;然后我们考虑每一次翻转带来的影响。我们考虑一个子区间 $[l,r]$ ，设该区间逆序对为 $x$ ，那么反转后该区间的逆序对为 $C_n^2 -x$ 。翻转区间 $[l,r]$ 导致答案 $ans = ans + C_n^2 -x - x = ans + C_n^2-2x$</p>
<p>​    &nbsp;&nbsp;&nbsp;因为只需要奇偶性，那么 $2x$ 需要考虑，那么就每次看看 $C_n^2$ 的奇偶性即可。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x)&amp;(-x)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">int</span> pos; <span class="comment">//postion</span></span><br><span class="line">&#125;node;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line">node num[maxn];</span><br><span class="line"><span class="keyword">int</span> tree[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i].val);</span><br><span class="line">        num[i].pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num+<span class="number">1</span>,num+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">find</span>(num[i].pos);</span><br><span class="line">        add(num[i].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">int</span> k = ((r-l+<span class="number">1</span>)*(r-l))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dislike\n"</span>);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"like\n"</span>);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"like\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"dislike\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-Butterfly"><a href="#C-Butterfly" class="headerlink" title="C. Butterfly"></a>C. <a href="https://ac.nowcoder.com/acm/contest/6955/F">Butterfly</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;这题描述起来有点难，还是直接点链接去看比较好。</p>
<p>​    &nbsp;&nbsp;&nbsp;大概就是给定一个 由 <strong>X</strong> 和 <strong>O</strong> 构成的$n\times m$ 的矩阵，让你找出里面由 <strong>X</strong> 构成的蝴蝶的最大对角线长度。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这题第一时间让我想到了我 <strong>2020/2/12</strong> 写的dp练习中的<strong>创意吃鱼法</strong>。</p>
<p>​    &nbsp;&nbsp;&nbsp;一开始想要考虑从中心开始考虑，但是需要维护的东西有点多，而且周围的判别不好判。因此可以考虑从<strong>右上/右下/左上/左下</strong> 这四个位置考虑，我这里是从左下考虑的。设我们要求的答案为 $ans$ 。</p>
<p>​    &nbsp;&nbsp;&nbsp;考虑维护三个数组，看 <strong>X</strong> 向上延伸，左上延伸，右上延伸的长度。所以我们依次遍历矩阵中的每一个元素，判定他是否可以作为蝴蝶的左下角，首先取一个向上延伸和右上延伸的最小值 $p$，然后从 $p$ 到 $ans$ 遍历，每次判定一下该答案是否合法，判定的话无非是从右下角判定一下就行，比较简单。如果答案合法，那么更新 $ans$。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> lr[maxn][maxn],rr[maxn][maxn],str[maxn][maxn]; <span class="comment">//分别为按左上、右上，向上延伸</span></span><br><span class="line"><span class="keyword">char</span> x;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">'X'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lr[i][j] = lr[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                rr[i][j] = rr[i<span class="number">-1</span>][j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                str[i][j] = str[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="built_in">min</span>(str[i][j],rr[i][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = p;k&gt;ans;k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i][j+k<span class="number">-1</span>]&gt;=k &amp;&amp; lr[i][j+k<span class="number">-1</span>]&gt;=k) ans = <span class="built_in">max</span>(ans,k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度计算pi</title>
    <url>/2020/04/20/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97pi/</url>
    <content><![CDATA[<h2 id="高精度计算PI值"><a href="#高精度计算PI值" class="headerlink" title="高精度计算PI值"></a>高精度计算PI值</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    &nbsp;&nbsp;&nbsp;使用双向链表作为存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后 <strong>500</strong> 位），高精度计算PI值。<strong>提示：可以利用反三角函数幂级展开式来进行计算。</strong></p>
<a id="more"></a>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="求PI的算法"><a href="#求PI的算法" class="headerlink" title="求PI的算法"></a>求PI的算法</h4><p>​    &nbsp;&nbsp;&nbsp;首先这道题是要求必须使用双向链表作为存储结构的，这个需要注意，而且也不能用数组计算完了之后挨个赋值给链表的每个节点，<del>这是耍赖</del> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;那么我们开始再想，用什么公式来求 <strong>PI</strong> 呢？这是一个问题。先没管题目的提示，我去百度了一通，发现了一个很神奇的算法，用三行就可以计算到圆周率小数点后800+位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> a=<span class="number">1000</span>,b,c=<span class="number">2800</span>,d,e,f[<span class="number">2801</span>],g;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;b-c;) f[b++]=a/<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(;d=<span class="number">0</span>,g=c*<span class="number">2</span>;c-=<span class="number">14</span>,<span class="built_in">printf</span>(<span class="string">"%.3d"</span>,e+d/a),e=d%a)</span><br><span class="line">    <span class="keyword">for</span>(b=c;d+=f[b]*a,f[b]=d%--g,d/=g--,--b;d*=b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;实验了一下发现居然真的是，而且效率还挺高的？看了一会实现的原理一直没看懂，作罢。</p>
<p>​    &nbsp;&nbsp;&nbsp;最后发现是找不到什么除了幂级展开还有啥高效率的算法了好像，还是考虑题目提示的 <strong>三角函数幂级展开</strong>。然后继续在网上搜索了一下，在学长的一个博客里发现了公式。<br>$$<br>f_{i} =<br>        \begin{cases}<br>            1  &amp; {i=1}\\<br>            f_{i-1}\times \frac{i-1}{2\times i-1} &amp; {i&gt;1}<br>        \end{cases}<br>$$</p>
<p>$$<br>\frac{\pi}{2} = \sum_{i=1}^{\infty}{f_i}<br>$$</p>
<p>​    &nbsp;&nbsp;&nbsp;那么拿到了这个式子，我们就可以分析一下，怎么和链表结合起来做了。</p>
<h4 id="链表的设计"><a href="#链表的设计" class="headerlink" title="链表的设计"></a>链表的设计</h4><p>​    &nbsp;&nbsp;&nbsp;双向链表，也就是每个节点有一个数据域，有前和后两个指针。我考虑到我们做加法和乘法是需要从后往前做，除法是需要从前往后做。因此需要双向遍历，我又添加了一个尾指针，记录当前链表的尾节点的地址，方便从后往前遍历，头节点可以保证从前往后遍历。设计如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">nxt</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">tail</span>;</span></span><br><span class="line">    node()   <span class="comment">//构造函数，用于初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        nxt = <span class="literal">NULL</span>;</span><br><span class="line">        pre = <span class="literal">NULL</span>;</span><br><span class="line">       	tail = <span class="keyword">this</span>;</span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;数据域就用来存储每一位数字，好比 <strong>3.1415926</strong> 就从第一个节点到第八个节点依次存 <strong>31415926</strong> 。</p>
<h4 id="乘法的实现"><a href="#乘法的实现" class="headerlink" title="乘法的实现"></a>乘法的实现</h4><p>​    &nbsp;&nbsp;&nbsp;另出一个函数，函数声明类似于 <code>void Multi(List L,int k)</code> </p>
<p>​    &nbsp;&nbsp;&nbsp;乘法我们模拟竖式的乘法运算，考虑到这是一个 <strong>高精度大数 * 低精度整数</strong> ，因此我们只需要从尾部到头部依次对每一位做乘法即可，考虑到进位问题，可以有两种办法</p>
<ul>
<li>可以是先做完乘法，然后再回到尾部，再从尾到头依次处理进位，这样的好处是这两种操作分隔开了，操作起来难度不大，也比较好想。</li>
<li>可以是边做乘法边进位，我们定义一个 <code>temp</code> 用来存储低位到高一位的进位，这里要注意的是，对于某一位的操作不是先加上进位再做乘法，是先做乘法，再加低位的进位。</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;但是有一个问题我们需要注意，就是好比 <strong>52 * 3</strong> ，这时候原来的两位数变成三位数了，因此需要我们在头节点和第一个节点之间增加新的节点，并且可能增加的不只是一个，只要 <code>temp</code> 这个进位大于等于10就需要一直创建新的节点来保证进位。</p>
<h4 id="除法的实现"><a href="#除法的实现" class="headerlink" title="除法的实现"></a>除法的实现</h4><p>​    &nbsp;&nbsp;&nbsp;另出一个函数，函数声明类似于 <code>void Division(List L,int k)</code> </p>
<p>​    &nbsp;&nbsp;&nbsp;除法也是模拟竖式运算，这个是从头到尾进行处理，这一位的数据做完除法，余数作为下一位的<strong>“进位”</strong> ，这里可以边做边 <strong>“进位”</strong> 。这里这个进位不是乘法的那种进位，注意区分。</p>
<p>​    &nbsp;&nbsp;&nbsp;需要注意的是最后可能有除不尽的情况，这样我们就可以一直在尾部插入节点，然后处理一直处理数据到<strong>最大位数</strong> 或者 <strong>到 “进位” 为0为止</strong> 。最后不要忘记重置一下尾指针，指向新的尾节点。</p>
<h4 id="加法的实现"><a href="#加法的实现" class="headerlink" title="加法的实现"></a>加法的实现</h4><p>​    &nbsp;&nbsp;&nbsp;函数声明类似于 <code>void Sum(List L,List p)</code> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;加法的实现也是需要从后往前遍历，然后依次对每一位做加法。先取两个链表的尾节点出来，然后依次向前遍历相加，我们可以把相加的答案放在前面那个链表里面，注意这样是不需要返回值的，因为链表内部是通过地址索引的，我们改变的就是传入链表的值。</p>
<h4 id="最后的整合"><a href="#最后的整合" class="headerlink" title="最后的整合"></a>最后的整合</h4><p>​    &nbsp;&nbsp;&nbsp;最后我们总共需要一个和链表，一个 $f_{i}$ ，一个 $f_{i-1}$ 。 和链表用于计算所有式子的累加和，而 $f_{i-1}$ 用于推出 $f_i$ 。然后每次把 $f_i$ 和 和链表进行累加。 </p>
<p>​    &nbsp;&nbsp;&nbsp;最后再对<strong>和链表乘2</strong> 即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    &nbsp;&nbsp;&nbsp;代码先不贴了。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://blog.csdn.net/FSAHFGSADHSAKNDAS/article/details/88745656">数据结构实验：高精度计算圆周率</a></li>
<li><a href="https://blog.csdn.net/LittleWhiteLv/article/details/81587555">圆周率高精度算法</a></li>
</ul>
]]></content>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>Python初步学习</title>
    <url>/2020/04/18/Python%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Python学习笔记"><a href="#Python学习笔记" class="headerlink" title="Python学习笔记"></a>Python学习笔记</h1><h2 id="Python的不同解释器"><a href="#Python的不同解释器" class="headerlink" title="Python的不同解释器"></a>Python的不同解释器</h2><ol>
<li><p><strong>CPython</strong></p>
<p>这是自带的用C语言开发的解释器，因此叫CPython。它也是使用最广的Python解释器。</p>
</li>
<li><p><strong>IPython</strong></p>
<p>这是基于CPython之上的一个交互式解释器，只是相比于CPython多了交互上的优化。</p>
</li>
<li><p><strong>PyPy</strong></p>
<p>它的目标是执行速度。PyPy采用<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">JIT技术</a>，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。他与CPython略有不同。</p>
</li>
</ol>
<a id="more"></a>

<ol>
<li><p><strong>Jython</strong></p>
<p>这是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
</li>
<li><p><strong>IronPython</strong></p>
<p>这是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
</li>
</ol>
<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="简单的输入和输出-I-O"><a href="#简单的输入和输出-I-O" class="headerlink" title="简单的输入和输出(I/O)"></a>简单的输入和输出(I/O)</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>​    &nbsp;&nbsp;&nbsp;python提供了一个 <code>input()</code> 函数供我们输入使用，这读入的是字符串数据，并返回，可以将返回值存放在一个变量中。<strong>input</strong>函数中可以带字符串，这段字符串在输入前会打印在屏幕上，这使得我们具有很好的交互性，好比我们写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">"hello,friend! please input your name"</span>)</span><br><span class="line">print(<span class="string">"The input name is "</span>,name)</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;那么这时候我们运行上述程序，就会提示 <code>hello , friend! please input your name</code> ，这就提示我们应该输入名字。</p>
<p>​    &nbsp;&nbsp;&nbsp;这里需要注意的是，<code>input()</code> 函数读入的是一个字符串 <code>str</code> ，就算我们输入了整数他也是一个字符串，如果我们要用真正的整数，那么就需要用 <code>int()</code> 进行类型强制转换。如果其中不是合法的整数，那么会报错。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>​    &nbsp;&nbsp;&nbsp;python中的输出函数是 <code>print()</code> ，这和 <strong>C++</strong> 的<code>printf</code> 差了一个f。我们在函数的参数中传入什么，他就会打印什么。好比我们写  <code>print(&quot;heelo,world&quot;)</code> ，那么运行就会打印 <code>hello,world</code>  在屏幕上。<code>print</code> 支持我们传入多个参数，好比 <code>printf(&quot;my name is&quot;,&quot;zs&quot;)</code> ，两两之间用逗号隔开，这在输出时会被解析成空格，也就是说两段字符串之间有一个空格。当然此函数也可以打印整数等。</p>
<h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>​    &nbsp;&nbsp;&nbsp;Python中对代码块的区分，不是用C++的大括号，而是用缩进。处于连续同一缩进的是一个代码块，这也是为什么Python又被戏称为<strong>游标卡尺语言</strong>的原因。<strong>当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</strong>我们通常用<strong>一个Tab / 四个空格</strong> 的缩进。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>​    &nbsp;&nbsp;&nbsp;Python的注释用的是 <code>#</code> ，而 C++ 中的注释用的是 <code>\\</code> 。</p>
<h4 id="Case-Sensitive"><a href="#Case-Sensitive" class="headerlink" title="Case Sensitive"></a>Case Sensitive</h4><p>​    &nbsp;&nbsp;&nbsp;Python中是大小写敏感的，也就是 a 和 A 不是同一个东西。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="1-整数"><a href="#1-整数" class="headerlink" title="1. 整数"></a>1. 整数</h4><p>​    &nbsp;&nbsp;&nbsp;Python一个很大的好处就是可以处理任意大小的整数，包括负整数。这也是为什么很多大数题大家都喜欢用Python，hhhh。多数地方都用十进制，但是也是支持其他进制的哈~好比 <code>0x</code> 前缀就是16进制。</p>
<h4 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h4><p>​    &nbsp;&nbsp;&nbsp;浮点数是小数，之所以称为浮点数，是因为小数点位置在科学计数法中是可变的。这里需要注意，整数和浮点数在计算机内部存储方式不同，浮点数应该都是 <code>IEEE754</code> 标准吧？整数之间的运算永远都是精确的，包括除法。而浮点数的运算则会有一定的误差。Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</p>
<h4 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h4><p>​    &nbsp;&nbsp;&nbsp;字符串是以单引号 <code>&#39;&#39;</code> 或者双引号 <code>&quot;&quot;</code> 括起来的任意文本。我们注意到<strong>Python</strong>中<strong>没有单个字符的概念</strong>，就算是单个字符也是一个字符串。如果<code>&#39;&#39;</code> 括起来的字符串内部出现 <code>&#39;&#39;</code> 需要使用<code>\</code>转义，相同的，如果 <code>&quot;&quot;</code> 括起来的字符串内部出现 <code>&quot;&quot;</code> 需要转义。好比下面的程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"My name is 'zs'"</span>)  <span class="comment">#合法  My name is 'zs'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"My name is "</span>zs<span class="string">""</span>)  <span class="comment">#不合法 invalid syntax</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"My name is \"zs\""</span>) <span class="comment">#合法 My name is "zs" </span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'My name is "zs"'</span>)  <span class="comment">#合法  My name is "zs"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'My name is '</span>zs<span class="string">''</span>)  <span class="comment">#不合法 invalid syntax</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'My name is \'zs\''</span>) <span class="comment">#合法 My name is 'zs'</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;Python中也有很多转义字符，跟C++的很类似。<code>\n</code>,<code>\t</code>,<code>\\</code>  分别代表换行，横向制表，字符<code>\</code>  。在python中还支持用 <code>r&#39; &#39;</code> 表示 <code>&#39;&#39;</code>  内部的字符默认不转义。</p>
<p>​    &nbsp;&nbsp;&nbsp;Python在输出多行语句时，可以用 <code>print(&#39;&#39;&#39;content&#39;&#39;&#39;)</code> 其中content中的内容，支持用直觉上的换行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'''python</span></span><br><span class="line"><span class="string">name</span></span><br><span class="line"><span class="string">zs'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The output</span></span><br><span class="line">python</span><br><span class="line">name</span><br><span class="line">zs</span><br></pre></td></tr></table></figure>

<h4 id="4-布尔值"><a href="#4-布尔值" class="headerlink" title="4. 布尔值"></a>4. 布尔值</h4><p>​    &nbsp;&nbsp;&nbsp;含有 <strong>Ture</strong> 和 <strong>False</strong> 两种类型，代表真和假。支持 <code>and</code> ,  <code>or</code> ,<code>not</code> 三种运算。</p>
<h4 id="5-空值"><a href="#5-空值" class="headerlink" title="5. 空值"></a>5. 空值</h4><p>​    &nbsp;&nbsp;&nbsp;空值是Python中的一个特殊值，用 <code>None</code> 表示。 <code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​    &nbsp;&nbsp;&nbsp;变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头。</p>
<p>​    &nbsp;&nbsp;&nbsp;变量命名时最好能做到顾名思义，当然也有很多规范的命名规则，可以自行百度。</p>
<p>​    &nbsp;&nbsp;&nbsp;在 <strong>Python</strong> 中我们不需要指定一个变量是特定的类型，它可以在不同的类型之间变来变去，这确实很方便，不过感觉也是很占内存和时间的。</p>
<p>​    &nbsp;&nbsp;&nbsp;这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>​    &nbsp;&nbsp;&nbsp;Python中没有C++中的const来限制常量，但是通常用<strong>变量名全大写来代表这个变量为一个常量</strong>，但是这玩意是个约定俗成的，并不是说你这么写他就真是个常量了。</p>
<h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>​    &nbsp;&nbsp;&nbsp;字符编码有很多种，不同的语言也对应着不同的字符编码。常见的几个是 <code>ASCII</code> ,<code>Unicode</code> ,<code>UTF-8</code>,<code>GB2313</code> 他们分别是英文和特殊字符的编码，统一的一套编码，可变长的统一编码，常用的中文编码。</p>
<h4 id="Python的字符串存储"><a href="#Python的字符串存储" class="headerlink" title="Python的字符串存储"></a>Python的字符串存储</h4><p>​    &nbsp;&nbsp;&nbsp;Python 3的的字符串是 <code>Unicode</code> 编码的，也就是说Python的字符串支持多语言，因为这是一套统一的编码。</p>
<p>​    &nbsp;&nbsp;&nbsp;对于单个字符的编码，Python提供了 <code>Ord()</code> 函数获取字符的整数表示，<code>chr()</code> 函数通过整数获取对应字符。</p>
<p>​    &nbsp;&nbsp;&nbsp;Python中的字符串类型为 <code>str</code> ，一个字符对应若干字节。<strong>如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</strong>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示。</p>
<p>​    &nbsp;&nbsp;&nbsp;我们可以通过<code>encode(&#39;编码方式&#39;)</code> 将 <strong>str</strong> 转变成 <strong>bytes</strong> 。我们也可以通过 <code>decode(&#39;编码方式&#39;)</code> 将 <strong>bytes</strong> 转变为 <strong>str</strong> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;Python为我们提供了一个 <code>len()</code> 函数，如果字符串是 <strong>str</strong> ，那么计算出的是字符数，如果是 <strong>bytes</strong> ，那么计算的是字节数。我们为了防止乱码问题，在两者相互转换时推荐用 <strong>utf-8</strong> 编码。</p>
<p>​    &nbsp;&nbsp;&nbsp;由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。而且需要你的编辑器支持 UTF-8编码。</p>
<h4 id="字符串的格式化输出"><a href="#字符串的格式化输出" class="headerlink" title="字符串的格式化输出"></a>字符串的格式化输出</h4><h5 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h5><p>​    &nbsp;&nbsp;&nbsp;Python的 <code>print()</code> 格式化输出和C语言的很像，也是 <code>%d</code> 代表整数，<code>%f</code> 代表浮点数， <code>%s</code> 代表字符串，<code>%s</code>代表十六进制整数。关于格式的指定，好比补0什么的也和C的很像。具体格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'%2d-%02d'</span> % (<span class="number">3</span>,<span class="number">1</span>)) <span class="comment"># 输出 3-01</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'my name is %s'</span> % <span class="string">"zs"</span>) <span class="comment"># 输出 my name is zs</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;如果我们要在字符串里面输出 <code>%</code> ，那么就需要用 <code>%%</code> 来转义表示 <code>%</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"This is a common %% %s "</span> % <span class="string">"字符"</span>) <span class="comment"># 输出 This is a common % 字符</span></span><br></pre></td></tr></table></figure>

<h5 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h5><p>​    &nbsp;&nbsp;&nbsp;除了上面的方法，<code>print</code> 还可以用 .format 的方法进行格式化输出。例如下例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'&#123;0&#125; name is &#123;1&#125;'</span>.format(<span class="string">"who"</span>,<span class="string">"zs"</span>)) <span class="comment">#输出 who name is zs</span></span><br></pre></td></tr></table></figure>



<h3 id="List-amp-tuple-列表和元组"><a href="#List-amp-tuple-列表和元组" class="headerlink" title="List &amp; tuple (列表和元组)"></a>List &amp; tuple (列表和元组)</h3><h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h4><p>​    &nbsp;&nbsp;&nbsp;List像是一个大杂烩，里面可以有各种类型的东西，是一个有序的集合，也就是说可以通过下标索引。</p>
<p>​    &nbsp;&nbsp;&nbsp;我们创建一个列表可以用中括号， <code>Mylist = [&quot;zs&quot;,&quot;wx&quot;]</code> ，这就创建了具有两个元素的列表，第一个元素是字符串 <strong>zs</strong> 第二个元素是字符串 <strong>wx</strong> 。这个列表的名字就是 <strong>Mylist</strong> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;我们可以通过 <code>len()</code> 来获取列表中元素的个数，也可以通过下表索引列表的元素，但是要注意下表是从开始计数的，如果索引出界会报 <code>IndexError</code> 。有趣的是，我们可以通过负的下表来访问元素，是倒着访问的，好比上述列表中 <code>Mylist[-1]</code> 就代表元素 <strong>“wx”</strong> 。 </p>
<p>​    &nbsp;&nbsp;&nbsp;我们可以通过 <code>listk = []</code> ，来创建一个空列表 <strong>listk</strong> ，如果用 <code>len()</code> 查看长度那么长度为<strong>0</strong>. </p>
<p>​    &nbsp;&nbsp;&nbsp;此外列表中的元素也可以是列表，可以通过<strong>类似于二维数组的形式索引</strong>。</p>
<p>​    &nbsp;&nbsp;&nbsp;列表中，有许多的<strong>方法</strong>。就像是相对于这个类型内置的一些函数，用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Mylist = [<span class="string">"zs"</span>,<span class="string">"wx"</span>]</span><br><span class="line">print(Mylist) <span class="comment"># 输出 ['zs', 'wx']</span></span><br><span class="line"></span><br><span class="line">Mylist.append(<span class="string">'Better'</span>) <span class="comment"># 用于在列表后面追加一个元素</span></span><br><span class="line">print(Mylist) <span class="comment"># 输出 ['zs', 'wx', 'Better']</span></span><br><span class="line"></span><br><span class="line">Mylist.insert(<span class="number">1</span>,<span class="string">'Good'</span>) <span class="comment"># 用于在下标为1的位置，插入一个元素</span></span><br><span class="line">print(Mylist) <span class="comment"># 输出 ['zs', 'Good', 'wx', 'Better']</span></span><br><span class="line"></span><br><span class="line">popx = Mylist.pop() <span class="comment"># 用于删除列表中最后一个元素，并返回元素的值</span></span><br><span class="line">print(Mylist,popx) <span class="comment"># 输出 ['zs', 'Good', 'wx'] Better</span></span><br><span class="line"></span><br><span class="line">popx = Mylist.pop(<span class="number">1</span>) <span class="comment"># 用于删除列表中下标为1的元素，并返回元素的值</span></span><br><span class="line">print(Mylist,popx) <span class="comment"># 输出 ['zs', 'wx'] Good</span></span><br><span class="line"></span><br><span class="line">L = [] <span class="comment"># 创建了一个空列表 L</span></span><br><span class="line">print(len(L)) <span class="comment">#输出0</span></span><br></pre></td></tr></table></figure>



<h4 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h4><p>​    &nbsp;&nbsp;&nbsp;元组跟上面的链表差不多，只不过是<strong>不可变的，一旦初始化就不能修改</strong>，也是可以通过下标访问元素。</p>
<p>​    &nbsp;&nbsp;&nbsp;不同的的是，我们定义一个元组是用 <code>()</code> ，好比我们定义 <code>Mytuple = (&quot;zs&quot;,&quot;wx&quot;)</code> ，这是含有两个字符串元素的元组，我们可以通过 <code>Mytuple = ()</code> 来定义一个空的元组。</p>
<p>​    &nbsp;&nbsp;&nbsp;需要注意的是，当我们定义一个只有一个元素的元组，如果我们写成 <code>Mytuple = (&quot;zs&quot;)</code> ，那么Python会默认解析为这是一个字符串，把括号当初普通的括号，不解释成元组。 那么我们如何定义只有一个元素的元组呢，我们应该写 <code>Mytuple = (&quot;zs&quot;,)</code> 这样就是只有一个元素的元组。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>元组中的不可变，是指它的指向不变</strong>，那么如果好比元组的元素中有一个列表，那么其实这个元组中的列表的元素还是可以改变的。</p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>​    &nbsp;&nbsp;&nbsp;条件判断是一个经典的语句。用于分支结构。</p>
<p>​    &nbsp;&nbsp;&nbsp;用法跟C很像，不过 <strong>else if</strong> 可以缩写为 <strong>elif</strong> ，并且因为 <strong>if</strong> ，<strong>else</strong> , <strong>elif</strong>  后面接的都是语句块，因此要加 <code>:</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weight = <span class="number">120</span></span><br><span class="line"><span class="keyword">if</span> weight&gt;=<span class="number">200</span>:</span><br><span class="line">    print(<span class="string">"too fat"</span>)</span><br><span class="line"><span class="keyword">elif</span> weight&lt;=<span class="number">100</span>:</span><br><span class="line">    print(<span class="string">"too thin"</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    print(<span class="string">"Good"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>​    &nbsp;&nbsp;&nbsp;循环结构也是三大结构之一。</p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>​    &nbsp;&nbsp;&nbsp;for语句是我C++中最喜欢循环语句。在Python中，他的写法变成了 <code>for x in something:</code> ，下面接相应的循环语句块。这个 <strong>x</strong> 是变量的名字，<strong>something</strong> 是某一个容器，可以是列表可以是元组啥的，这个写法的意思就是 遍历 <strong>something</strong> 中的每个元素，带入变量 <strong>x</strong> 中，执行循环操作。</p>
<p>​    &nbsp;&nbsp;&nbsp;我们通常配合 <code>range()</code> 函数来执行循环操作，通过 <code>range(n)</code> 可以生成从 <strong>[0,n)</strong> 的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list(range(<span class="number">11</span>)):</span><br><span class="line">    print(x)  <span class="comment">#输出 0~10</span></span><br></pre></td></tr></table></figure>



<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>​    &nbsp;&nbsp;&nbsp;while语句也是和C语言差不多，当型循环，当满足条件时就执行循环，也记住不要忘记加 <code>:</code> 。</p>
<h4 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h4><p>​    &nbsp;&nbsp;&nbsp;<strong>break</strong> 的作用是结束整个循环。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>continue</strong> 的作用是跳过这一次循环。</p>
<h3 id="Dict-amp-Set-字典和集合"><a href="#Dict-amp-Set-字典和集合" class="headerlink" title="Dict &amp; Set (字典和集合)"></a>Dict &amp; Set (字典和集合)</h3><h4 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h4><p>​    &nbsp;&nbsp;&nbsp;这个字典其实就是C语言中的 <strong>map</strong> ，人家 Python 直接内置了，属实业界良心。其实就是利用键值对匹配，一个键对应一个值。实现方式为哈希 <strong>(Hash)</strong> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;创建就是 <code>Mydict = {&quot;zs&quot;:250 , &quot;wx&quot;:666</code>} 这样第一个元素的键为 “zs” ，对应值为 250 。第二个值与这个的解读类似。我们也可以通过类似于数组的形式往字典里面加元素. <code>Mydict[&quot;jjh&quot;] = 100</code>  ，那么这时候就往里面加入了一个键值对。</p>
<p>​    &nbsp;&nbsp;&nbsp;字典中每个键值是唯一的，但是值可以相同，类似于函数。我们也可以通过类似于数组的形式，下标为键来访问值。当我们下标在字典中不存在，利用下标访问就会直接报错。<strong>Python</strong> 为我们提供了另一种方法来满足我们的需求，利用 <code>Mydict.get(键)</code> 可以获得对应的值，当不存在这个键，会返回 <code>None</code> 。此外，我们也可以指定其返回值，<code>Mydict.get(键,something)</code> ，这样当不存在的时候就会返回这个 <strong>something</strong> 。</p>
<p>​    &nbsp;&nbsp;&nbsp; 最后，<strong>字典中的 Key 只能是不可变对象。</strong></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>​    &nbsp;&nbsp;&nbsp;set 就是数学中的集合，具有无序性和唯一性。里面元素不重复，并且无序导致没法通过下标访问。可以用来给一组数据去重。通过 <code>add(key)  remove(key)</code> 等函数去除对应值的元素。</p>
<p>​    &nbsp;&nbsp;&nbsp;可以通过 <code>&amp;</code> 求交集， <code>|</code> 求并集， <code>-</code> 求差集等。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>set 中的元素也只能是不可变对象。</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>​    &nbsp;&nbsp;&nbsp;调用函数的时候要保证<strong>参数个数、参数顺序、参数类型</strong>满足函数的定义。然后正确的处理好返回值。</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>​    &nbsp;&nbsp;&nbsp;普通函数的定义通过 <code>def</code> 来进行，好比我们要写一个求绝对值的函数，那么就可以如下定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;这样我们就可以类似调用 <code>myabs(-5)</code> 来获得 -5 的绝对值。</p>
<p>​    &nbsp;&nbsp;&nbsp;如果我们想要定义一个<strong>空的函数</strong>，也就是什么都不做，那么函数内部的语句可以写 <code>pass</code> 。这类似于C++中的分号的作用？大概是。</p>
<p>​    &nbsp;&nbsp;&nbsp;通过  <code>函数.__name__</code>  可以获得函数的真实名字。</p>
<h4 id="多个返回值的函数"><a href="#多个返回值的函数" class="headerlink" title="多个返回值的函数"></a>多个返回值的函数</h4><p>​    &nbsp;&nbsp;&nbsp;我们可以在 <strong>return</strong> 后面写多个参数，这样在返回的时候会返回一个元组。我们接受返回值的时候，也可以并拍写多个变量，这样就会把返回值的元组中的各个值依次赋给每个变量。</p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>​    &nbsp;&nbsp;&nbsp;Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数，可变参数，关键字参数，这使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>​    &nbsp;&nbsp;&nbsp;当我们调用一个函数，有几个参数大多数情况下是一个默认的值，少数时候是变的，那么我们可以用到默认参数，默认参数的使用我们可以在那个参数的后面加上 <code>=something</code> ，这意思说是，这个参数默认为 <strong>something</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poww</span><span class="params">(x,n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        n = n<span class="number">-1</span></span><br><span class="line">        k = k*x</span><br><span class="line">    <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;例如上面这个例子，我们要求 $2^5$ ，那么可以调用 <code>poww(2,5)</code> 。那么我们如果要求 $2^2$ ，那么就可以直接调用<code>poww(2)</code> ，另一个参数可以不写，那么就是默认的2。</p>
<p>​    &nbsp;&nbsp;&nbsp;需要注意的是，<strong>必选参数在前，默认参数要在后</strong>。否则话会产生歧义，因为解释器不知道你到底传入的参数是默认参数还是必选参数。</p>
<p>​    &nbsp;&nbsp;&nbsp;此外，当我们有多个默认参数的时候，我们要在前面几个默认参数使用默认值，而后面那个用传入参数的时候，我们需要加上参数名，也就是 <code>参数名 = value</code> 这样传入。例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poww</span><span class="params">(x,n=<span class="number">2</span>,z=<span class="number">3</span>)</span>:</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    f = n+z</span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        f = f<span class="number">-1</span></span><br><span class="line">        k = k*x</span><br><span class="line">    <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;这时候，我们如果要调用 <code>poww(5,4)</code> ，代表求的是 $5^{4+3}$ ，如果我们要求 $5^{2+7}$ ，可以按照如下方法调用，使用 <code>poww(5,z=7)</code> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;最后还有一点很重要，默认参数要指向 <strong>不变对象</strong> 。否则当我们重复调用会发生错误。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>​    &nbsp;&nbsp;&nbsp;我们很多时候可能需要一个函数内传入不定量个数的参数，这就要用到可变参数，可变参数就是数量可变。</p>
<p>​    &nbsp;&nbsp;&nbsp;我们很容易想到，可以往里面传<strong>列表或者元组</strong> ，不过这样当我们传之前还有要把所有的参数归到一个列表和元素中，这样太麻烦。Python给出了一个简便写法，我们只需要在参数面前加一个 <code>*</code> ，这样我们就可以传入可变个参数。而且调用的时候，按普通的调用方法来即可，不需要传入元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + i*i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 输出 14</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;那么当这时候我们想往里面传一个元组，或者列表。当然可以挨个用数组访问然后写，不过Python也给了我们一个简便做法，只需要在列表或者元组前面加一个 <code>*</code> ，就可以把它结构解开，然后挨个元素传入函数中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + i*i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">Mylist = list(range(<span class="number">5</span>))</span><br><span class="line">print(test(*Mylist))  <span class="comment">#输出30</span></span><br></pre></td></tr></table></figure>



<h4 id="关键词参数"><a href="#关键词参数" class="headerlink" title="关键词参数"></a>关键词参数</h4><p>​    &nbsp;&nbsp;&nbsp;可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">(**kw)</span>:</span></span><br><span class="line">    print(kw)</span><br><span class="line"></span><br><span class="line">myfun(city = <span class="string">"jz"</span>,name = <span class="string">"zs"</span>) <span class="comment"># 输出 &#123;'city': 'jz', 'name': 'zs'&#125;</span></span><br><span class="line">Mydict = &#123;<span class="string">"city"</span>:<span class="string">"jz"</span>,<span class="string">"name"</span>:<span class="string">"zs"</span>&#125;</span><br><span class="line">myfun(**Mydict)  <span class="comment"># 输出 &#123;'city': 'jz', 'name': 'zs'&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;参数前面加 <code>**</code> 即是关键词参数。当然我们也可以传入参数时，用dict，然后加 <code>**</code>  解开结构传入。</p>
<h4 id="命名关键词参数"><a href="#命名关键词参数" class="headerlink" title="命名关键词参数"></a>命名关键词参数</h4><p>​    &nbsp;&nbsp;&nbsp;我们可以在上述的基础上，传入特定的参数，给相应的参数命名。这需要我们在定义各个参数之前，在参数之前加上 <code>*</code> ，好比 <code>def person(name,age,*,city,job)</code> 规定了，我们传入的两个关键词参数名字只能是 <strong>city</strong> 和和 <strong>job</strong> 。不过，当我们前面有一个参数是可变参数，那么就可以不用加那个 <code>*</code> 。好比像如下方法定义上面那个函数， <code>def person(name,age,*city,job)</code> 。在这里 <strong>city</strong> 是一个可变参数，后面的 <strong>job</strong> 就是一个命名关键词参数。</p>
<h4 id="参数调用顺序"><a href="#参数调用顺序" class="headerlink" title="参数调用顺序"></a>参数调用顺序</h4><p>​    &nbsp;&nbsp;&nbsp;在函数的参数中，上述各类参数可以组合使用。但是要注意顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></p>
<h3 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h3><p>​    &nbsp;&nbsp;&nbsp;函数的递归调用就是自己调用自己，QAQ，C++里面搞得也挺多的，就不赘述了。</p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>​    &nbsp;&nbsp;&nbsp;切片操作感觉真的是Python很方便的一个特性了。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>字符串，列表，元组支持切片。</strong></p>
<p>​    &nbsp;&nbsp;&nbsp;好比我们有一个列表，里面有数，0~100，我们要取其中的奇数，那么我们就需要每隔一个数取一个数，我们可以通过for循环来实现这个操作，但是呢，Python有一种更便利的方法来实现，那就是切片。他的用法类似于matlab中的冒号表达式，<code>begin:end:step</code>  这三个变量分别代表起始，终止和步长，也就是每个多少取一个，这三个参数都可以省略，<strong>省略时默认为序列起始点，序列终止点，1。这里要注意</strong>，<strong>序列范围为 <code>[begin,end)</code> ，前闭后开</strong>，例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = list(range(<span class="number">101</span>))</span><br><span class="line">print(L[<span class="number">1</span>:<span class="number">100</span>:<span class="number">2</span>]) <span class="comment"># 输出0~100所有的奇数</span></span><br><span class="line"></span><br><span class="line">print(L[<span class="number">-10</span>::<span class="number">2</span>])  <span class="comment"># 从倒数第十个数开始输出奇数，输出 [91, 93, 95, 97, 99]</span></span><br><span class="line"></span><br><span class="line">print(L[<span class="number">-50</span>:<span class="number">0</span>:<span class="number">-2</span>])  <span class="comment"># 从倒数第50个数，往前开始输出奇数，为 51~0中所有奇数</span></span><br></pre></td></tr></table></figure>



<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>​    &nbsp;&nbsp;&nbsp;迭代就是类似于遍历吧，通过 <strong>for</strong> 可以迭代遍历一个容器内的所有元素。</p>
<p>​    &nbsp;&nbsp;&nbsp;字符串和列表，元组，集合，字典这些都是可以用<strong>for</strong>遍历的，这也叫做可迭代对象。需要注意的是，我们在遍历字典和集合时，因为是无序的，所以两次遍历顺序可能不太一样。</p>
<p>​    &nbsp;&nbsp;&nbsp;当我们遍历字典时，默认遍历的是键值。例如下面这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = &#123;<span class="string">"zs"</span>:<span class="string">"rj"</span>,<span class="string">"jjh"</span>:<span class="string">"nb"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> L:</span><br><span class="line">    print(key)  <span class="comment"># 输出 zs jjh</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> L.values():</span><br><span class="line">    print(value) <span class="comment"># 输出 rj nb</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> L.items():</span><br><span class="line">    print(k,v) <span class="comment"># 输出 zs rj jjh nb</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;可以注意到，可以同时迭代两个数，或者多个数。</p>
<h3 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h3><p>​    &nbsp;&nbsp;&nbsp;列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<p>​    &nbsp;&nbsp;&nbsp;好比我们生成 <code>[1*1,2*2,3*3,···,n*n]</code> 这样的列表，可以用循环实现，也可以用列表生成式。</p>
<p>​    &nbsp;&nbsp;&nbsp;列表生成式格式大概是 <code>[元素 规则]</code> 就是前面是要往里面加的元素的表达式，后面是生成的规则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(L)  <span class="comment"># 输出[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br><span class="line"></span><br><span class="line">D = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(D)  <span class="comment"># 输出[4, 16, 36, 64, 100]</span></span><br></pre></td></tr></table></figure>



<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>​    &nbsp;&nbsp;&nbsp;我们将上述列表生成式外面的 <code>[]</code> 改成 <code>()</code> ，就变成了一个列表生成器。列表生成器里面每个元素不是原来就存在的，而是你要用的时候他按照规则去生成，可以节省空间。他也是一个可迭代对象，可以通过for循环来访问，此外也可以用 <code>next(迭代器)</code> 来获取下一个元素。</p>
<p>​    &nbsp;&nbsp;&nbsp;除了上述方法，我们也可以用函数的方法来定义生成器，当一个函数中有了关键字 ： <code>yield</code> 他就不是一个普通的函数了，就变成了一个生成器，按照函数的规则来生成相应数据。规则如下：当我们进入函数的时候，开始从头开始执行，执行到 <strong>yield</strong> ，函数结束，返回 <strong>yield</strong> 后面接的内容。然后下次进入函数的时候，从上次结束的地方继续开始，然后这样一直循环，直到再不能取数为止。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    &nbsp;&nbsp;&nbsp;凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型，就是可迭代对象；</p>
<p>​    &nbsp;&nbsp;&nbsp;凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列，<strong>这感觉就像是一个指针呀其实（自我认为），可以通过指针访问可迭代对象中的元素</strong>；</p>
<p>​    &nbsp;&nbsp;&nbsp;集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p>
<p>​    &nbsp;&nbsp;&nbsp;Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>实际上完全等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先获得Iterator对象:</span></span><br><span class="line">it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 循环:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值:</span></span><br><span class="line">        x = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h4><p>​    &nbsp;&nbsp;&nbsp;<code>map()</code> 函数包括两个参数，第一个参数是一个函数，第二个参数是一个序列。<strong>map</strong> 的作用就是将序列中的每个元素代入到函数中并且求出每个元素对应的值，然后会返回一个相应的 <code>Iterator</code> ，我们可以通过对应的语句，好比 <code>list()</code> ，<code>tuple()</code> 啥的转成对应的序列。</p>
<p>​    &nbsp;&nbsp;&nbsp;<code>reduce()</code> 函数也是包括两个参数，一个是函数，一个是序列。<strong>reduce</strong> 的作用是类似于一个递归的感觉吧大概，好比序列是 <code>L = [1,2,3,4,5]</code> ，有一个函数是 <code>f</code> ，我们暂且不管这个函数的作用是什么，那么如果我们现在调用 <code>reduce(f,L)</code> ，他返回一个 <code>f</code> 函数的返回值，值为 <code>f(f(f(1,2),3),4)</code> 。就是类似于这种嵌套的结构。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>​    &nbsp;&nbsp;&nbsp;<code>filter()</code> 函数也包括两个参数，一个是函数，一个是序列。他是通过那个函数的返回值是 <code>True</code> or <code>False</code> 来判断是否保留那个序列中的每个元素。返回值也是 <code>Iterator</code> 。</p>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>​    &nbsp;&nbsp;&nbsp;<code>sorted()</code> 顾名思义，这是一个排序函数，我们往里面传入一个序列，那么他就会默认的对序列按升序排序，并且返回一个这个排序后序列。<strong>但是我们传入的序列不会有变动。</strong></p>
<p>​    &nbsp;&nbsp;&nbsp;此外，<code>sorted()</code> 里面还可以加关键词 key 键值来确定规则，好比我们可以加 <code>key=abs</code> 这样就可以将序列中所有的元素按照绝对值从小到大的顺序。我们也可以加 <code>reverse=True</code> 来变成降序排序。</p>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>​    &nbsp;&nbsp;&nbsp;我们知道，函数名只是一个指向函数的变量，我们也可以用另一个变量指向这个函数来引用函数，相当于起了一个别名。因此，我们也可以在函数的返回值中返回一个函数，然后将返回值赋值给一个变量，这样就可以通过这个变量来调用返回的函数。</p>
<blockquote>
<p>我们在一个函数中又定义了一个函数，并且，内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，这种称为“闭包<strong>（Closure）</strong>”的程序结构拥有极大的威力。</p>
</blockquote>
<p>​    &nbsp;&nbsp;&nbsp;返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为这个变量相当于一个静态变量，现在变了，前面相应的结果也会变。</p>
<blockquote>
<p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
</blockquote>
<p>​    &nbsp;&nbsp;&nbsp;通过  <code>函数.__name__</code>  可以获得函数的真实名字。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    &nbsp;&nbsp;&nbsp;通过 <code>lambda</code> 可以创建匿名函数，这个就类似于matlab里面的那个 <code>@</code> 创建的匿名函数。</p>
<p>​    &nbsp;&nbsp;&nbsp;格式为： <code>lambda 变量: 返回值</code>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(list(map(<span class="keyword">lambda</span> x: x*x,range(<span class="number">1</span>,<span class="number">11</span>)))) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;我们也可以把匿名函数当作函数的返回值返回。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>​    &nbsp;&nbsp;&nbsp;我们可能想在调用函数之前在前面打印一下函数的运行日志，或者其他的一些内容，其他的操作。</p>
<p>​    &nbsp;&nbsp;&nbsp;这样我们就可以通过装饰器来实现，装饰器是为了给函数加一些其他的修饰，但是不需要在原本函数的基础上做改变。</p>
<p>​    &nbsp;&nbsp;&nbsp;本质上，<strong>装饰器(decorator)</strong> 是一个返回函数的高阶函数，一个能打印日志的 <strong>decorator</strong> 可以如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">        print(<span class="string">"call %s()"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;调用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'2020-4-18'</span>)</span><br><span class="line">    </span><br><span class="line">print(now()) <span class="comment"># 输出 call now() 2020-4-18</span></span><br></pre></td></tr></table></figure>

<p>​    &nbsp;&nbsp;&nbsp;在这里， <code>@log</code> 可以等效为 <code>now = log(now)</code> ，那么我们应该怎么理解呢，首先，在我们调用之前，我们就把这个函数传入这个<code>log</code>函数，然后进入 <code>wrapper</code> 函数，先输出了日志，然后返回了一个 <code>func()</code> 函数，然后结束这个函数的定义，又返回了 <code>wrapper</code> 函数，这样就是将日志和原函数组合在一起了。所以最后一起输出</p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>​    &nbsp;&nbsp;&nbsp;偏函数可以看做一个函数其中某一个参数固定，然后另成一个新函数，这样到时候我们重复调用的时候就会比较方便了。</p>
<blockquote>
<p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
</blockquote>
<p>​    <strong>当用 <code>functools.partial</code> 之前我们需要引入 <code>functools</code> 模块。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">int2 = functools.partial(int,base=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(int(<span class="string">'10110'</span>,base=<span class="number">2</span>)) <span class="comment"># 以二进制来转化这个字符串，得到22</span></span><br><span class="line">print(int2(<span class="string">'10110'</span>)) <span class="comment"># 和上述等价</span></span><br></pre></td></tr></table></figure>





<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>​    &nbsp;&nbsp;&nbsp;这个就是类似于头文件的感觉，模块里面包含了很多别人已经写好了的函数，你引入之后可以直接拿来用，能够大大提高自己的编程效率。</p>
<p>​    &nbsp;&nbsp;&nbsp;模块是放在包里的，这样可以避免不同模块之间的冲突，包中可以有很多的模块，并且所有包里都有一个相同名字的模块 ， <code>__init__.py</code> ，这个文件说明这个目录是一个包，里面的其他的内容是模块。</p>
<p>​    &nbsp;&nbsp;&nbsp;模块命名为 <code>包名.模块名</code> ，这样就有效避免了模块与模块之间的冲突</p>
<blockquote>
<p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p>
<p>创建自己的模块时，要注意：</p>
<ul>
<li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li>
<li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行<code>import abc</code>，若成功则说明系统存在此模块。</li>
</ul>
</blockquote>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>​    &nbsp;&nbsp;&nbsp;在使用模块之前只需要  <code>import 模块名</code> ，就可以通过 <strong>模块名.方法</strong> 的方式来调用这个模块里面的方法。</p>
<p>​    &nbsp;&nbsp;&nbsp;当我们在命令行运行模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​    &nbsp;&nbsp;&nbsp;在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p>
<p>​    &nbsp;&nbsp;&nbsp;正常的函数和变量名是公开的（public）。但是外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><p>​    &nbsp;&nbsp;&nbsp;我们用包管理工具  <code>pip</code>  来安装第三方模块。</p>
<p>​    &nbsp;&nbsp;&nbsp;安装一个模块只需要 <code>pip install 库名</code> ，这样就成功安装了一个包了。</p>
<p>​    &nbsp;&nbsp;&nbsp;此外，我们也可以直接安装 <a href="https://www.anaconda.com/">Anaconda</a> ，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>​    &nbsp;&nbsp;&nbsp;下载地址为 ： <a href="https://www.anaconda.com/download/">Anaconda官网</a> </p>
<h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    &nbsp;&nbsp;&nbsp;当我们加载一个模块时，Python会在指定路径搜索对应的模块文件，如果找不到就会返回错误。</p>
<p>​    &nbsp;&nbsp;&nbsp;默认情况下，Python解释器会搜索当前目录，所有已安装的内置模块和第三方模块，搜索路径存放在  <code>sys</code> 模块的 <code>path</code> 变量中。我们可以通过 <code>sys.path</code> 来查看。</p>
<p>​    &nbsp;&nbsp;&nbsp;我们要改动这个目录，往里面添加我们需要的，有两个方法。</p>
<ul>
<li>直接通过 <code>sys.path.append()</code> 添加对应的路径，但是运行结束后会失效。</li>
<li>设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</li>
</ul>
<h2 id="资料补充"><a href="#资料补充" class="headerlink" title="资料补充"></a>资料补充</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的Python教程</a></li>
<li><a href="https://www.jianshu.com/p/62f155eb6ac5">Anaconda介绍、安装及使用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++大数类的实现</title>
    <url>/2020/04/06/C-%E5%A4%A7%E6%95%B0%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="C-大数类设计思路"><a href="#C-大数类设计思路" class="headerlink" title="C++大数类设计思路"></a>C++大数类设计思路</h1><h3 id="洛谷大数类的评测结果-开了氧气优化"><a href="#洛谷大数类的评测结果-开了氧气优化" class="headerlink" title="洛谷大数类的评测结果(开了氧气优化)"></a><a href="https://www.luogu.com.cn/problem/U111551">洛谷大数类</a>的评测结果(开了氧气优化)</h3><p><img src="/images/BigNumber/BigNumber.png" alt="image-BigNumber"></p>
<p> <strong>这个第四个点真的优化不过去了QAQ，24W的数据，<del>丧心病狂</del></strong></p>
<a id="more"></a>

<h3 id="整体构思"><a href="#整体构思" class="headerlink" title="整体构思"></a>整体构思</h3><p>​    &nbsp;&nbsp;&nbsp;构造大数类名为 <strong>BigNumber</strong> ,首先想法是用字符串读入大数，然后将其转化为vector数组倒序分位存储的整数，然后通过一个 <strong>len</strong> 来记录数字的位数，便于做运算。还设计了一个标记变量，用于标记这数为正数还是负数。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>​    &nbsp;&nbsp;&nbsp;我用了两种构造函数，一个是无参构造函数，一个是拷贝构造函数，当然还有一个有参构造函数，但是实际过程中我没有用到。无参构造函数用于上述类成员的初始化，拷贝构造函数用于复制一个相同的大数类进行运算。有参构造函数可以用于对类成员的复制。</p>
<h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><h4 id="重载-“-”"><a href="#重载-“-”" class="headerlink" title="重载 “+”"></a>重载 “+”</h4><ul>
<li>首先在类中进行了声明, <code>BigNumber operator + (const BigNumber &amp;b);</code> ，用当前类 <strong>*this</strong>  来和引入的类 <strong>b</strong> 进行加法运算，返回值为一个 <strong>BigNumber</strong> 类。</li>
<li>在类的外部进行重载的定义，先将用拷贝构造函数将当前的类 <strong>*this</strong> 拷贝为 <strong>a</strong> ，然后对 <strong>a</strong> 和 <strong>b</strong> 进行加法运算，模拟竖式，对应位相加，大于10则进位，最后去掉尾部的 0 即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> + (<span class="keyword">const</span> BigNumber &amp;b) <span class="comment">//重载 "+" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	Result.len = <span class="built_in">max</span>(a.len,b.len)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Result.len||add!=<span class="number">0</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p=add;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.len) p+=a.v[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.len) p+=b.v[i];</span><br><span class="line">		add=p/<span class="number">10</span>;</span><br><span class="line">		Result.v.push_back(p%<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Result.v[Result.v.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.v.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	Result.len=Result.v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重载-“-lt-”"><a href="#重载-“-lt-”" class="headerlink" title="重载 “&lt;”"></a>重载 “&lt;”</h4><p>​    &nbsp;&nbsp;&nbsp;因为进行减法前需要比较两个大数类的大小，我就先重载了 <strong>&lt;</strong> 。思路就是先比较<strong>a、b</strong>两个大数的长度，长的那个肯定比较大，如果两个长度相等。从尾部开始依次向前比较，如果不相等的话，就看两个数的相对大小，大的那个肯定整体比较大。如果总是相等，到了最后，就返回相应的值表示他们相等。<strong>这里我的返回值为int类型，用的标记是：如果两个相等，返回-1，如果前者小于后者，返回1，如果前者大于后者，返回0.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  BigNumber::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigNumber &amp;b) <span class="comment">// 重载 "&lt;" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(a.len &lt; b.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a.len &gt; b.len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.v[i]!=b.v[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a.v[i] &lt; b.v[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重载-“-“"><a href="#重载-“-“" class="headerlink" title="重载 “-“"></a>重载 “-“</h4><ul>
<li>首先在类中进行了声明, <code>BigNumber operator - (BigNumber &amp;b);</code> ，用当前类 <strong>*this</strong>  来和引入的类 <strong>b</strong> 进行减法运算，返回值为一个 <strong>BigNumber</strong> 类。</li>
<li>在类的外部进行重载的定义，先将用拷贝构造函数将当前的类 <strong>*this</strong> 拷贝为 <strong>a</strong> ，然后对 <strong>a</strong> 和 <strong>b</strong> 进行减法运算。如果 <strong>a&lt;b</strong> ，那么我们就把 <strong>flag</strong> 设为 <strong>true</strong> ，标志得数为一个负数，然后用 <strong>swap</strong> 交换两个类，保证总是大数减小数。减法的话就是从前往后扫，对应位相减，如果不够减的就进行借位。如果借完位当前位置小于0了，那么就再向前借位。最后要去掉结尾多于的0.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> - (BigNumber &amp;b) <span class="comment">// 重载 "-" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(a,b);</span><br><span class="line">		Result.flag=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Result.len=a.len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.v[i]&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			a.v[i]+=<span class="number">10</span>;</span><br><span class="line">			a.v[i+<span class="number">1</span>]--;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(a.v[i] &lt; b.v[i]&amp;&amp;i&lt;b.len)</span><br><span class="line">		&#123;</span><br><span class="line">			a.v[i]+=<span class="number">10</span>;</span><br><span class="line">			a.v[i+<span class="number">1</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.len)</span><br><span class="line">		Result.v.push_back(a.v[i]-b.v[i]);</span><br><span class="line">		<span class="keyword">else</span> Result.v.push_back(a.v[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Result.v[Result.len<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.len &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.pop_back();</span><br><span class="line">		Result.len--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重载-“-”-1"><a href="#重载-“-”-1" class="headerlink" title="重载 “*”"></a>重载 “*”</h4><ul>
<li>首先在类中进行了声明, <code>BigNumber operator * (BigNumber &amp;b);</code>，用当前类 <strong>*this</strong>  来和引入的类 <strong>b</strong> 进行乘法运算，返回值为一个 <strong>BigNumber</strong> 类。</li>
<li>在类的外部进行重载的定义，先将用拷贝构造函数将当前的类 <strong>*this</strong> 拷贝为 <strong>a</strong> ，然后对 <strong>a</strong> 和 <strong>b</strong> 进行乘法运算。乘法也是模拟竖式运算，两个位数相乘对应的得数中的哪一位不难发现，因此只需要边乘边进位即可，一开始想的是所有乘完之后再进位，后来想了想运算的次序不会影响除和模的运算，所以就可以边乘边取商和模，可以少掉两层循环。算是一个小小的优化。最后要去掉结尾多于的0.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> * (BigNumber &amp;b) <span class="comment">// 重载 "*"  定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	Result.len=a.len+b.len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Result.len;i++) Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.v[i+j]+=a.v[i]*b.v[j];</span><br><span class="line">			Result.v[i+j+<span class="number">1</span>]+=Result.v[i+j]/<span class="number">10</span>;</span><br><span class="line">			Result.v[i+j]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Result.v[Result.v.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.v.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	Result.len=Result.v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重载-“-“-1"><a href="#重载-“-“-1" class="headerlink" title="重载  “/“"></a>重载  “/“</h4><ul>
<li><p>首先在类中进行了声明,<code>BigNumber operator / (BigNumber &amp;b);</code>，用当前类 <strong>*this</strong>  来和引入的类 <strong>b</strong> 进行除法运算，返回值为一个 <strong>BigNumber</strong> 类。</p>
</li>
<li><p>在类的外部进行重载的定义，先将用拷贝构造函数将当前的类 <strong>*this</strong> 拷贝为 <strong>a</strong> ，然后对 <strong>a</strong> 和 <strong>b</strong> 进行除法法运算。我选择了做除法的时候大数类中同时存储商和余数，这样可以加快效率，因为我自己的想法是把除法和取模一起处理，求得商的同时，模也能求出来。因此他们的框架肯定是相差无几的，所以我选择了一次性算出来两个，在大数类中用两个vector数组分别存商和余数，求商和余数我用的是减法的策略，分下面三种情况来讨论</p>
<ul>
<li><strong>a&lt;b</strong> ：很显然商为0，余数为a。</li>
<li><strong>a==b</strong> ：很显然商为1，余数为0。</li>
<li><strong>a&gt;b</strong> ：这个是最难处理的，我们想想一下模拟除法的竖式运算，先在b的后面填0，让a和b的位数相同，然后再一直对a进行减法运算，将得到的数排列起来即可。里面细节还是挺多的，具体的看代码。最后要去掉结尾多于的0.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> / (BigNumber &amp;b) <span class="comment">// 重载 "/" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.v.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.m.push_back(a.v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.push_back(<span class="number">1</span>);</span><br><span class="line">		Result.m.push_back(<span class="number">0</span>);</span><br><span class="line">		Result.len=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">size</span> = a.len-b.len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">BigNumber <span class="title">p</span><span class="params">(b)</span></span>;</span><br><span class="line">			<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				p.v.insert(p.v.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			p.len = p.v.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">while</span>((a-p).flag==<span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a=a-p;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="built_in">size</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">size</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				Result.v.push_back(cnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				Result.v[i] = cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(Result.v[Result.v.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.v.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.v.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">		Result.len=Result.v.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.v.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.m.push_back(a.v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重载-“-”-2"><a href="#重载-“-”-2" class="headerlink" title="重载 “%”"></a>重载 “%”</h4><p>​    这个和除法的类似，我们除法的其实已经求出来模了，这个只是象征性的搞一搞。QAQ。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> % (BigNumber &amp;b) <span class="comment">//重载 "%" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> Result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">size</span> = a.len-b.len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">BigNumber <span class="title">p</span><span class="params">(b)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				p.v.insert(p.v.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			p.len = p.v.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">while</span>((a-p).flag==<span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a=a-p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.v.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.v.push_back(a.v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其中遇到的问题"><a href="#其中遇到的问题" class="headerlink" title="其中遇到的问题"></a>其中遇到的问题</h3><ul>
<li>在做减法的时候，会出现莫名奇怪的数据，后来发现是由于访问b数组的时候越界，而且vector数组的clear只是将数组的size置为了0，而不是将所有数据都莫抹除，而且vector通过下标访问越界还不会报错，我整个人都傻了，调了巨长时间。</li>
<li>在做除法的时候，一度自闭。本来是只是一直减，这样效率真的巨tm慢。后来想到了用这个办法好像可以优化到 log 级别的，但是好难调试啊。。从昨天下午一直搞到现在。</li>
<li>因为swap这个东西，好像会影响到类的源数据，所以我就多定义了几个数，分别对他们进行操作，这样就不会相互影响，虽然看起来挺丑的。</li>
</ul>
<h3 id="整体的代码实现"><a href="#整体的代码实现" class="headerlink" title="整体的代码实现"></a>整体的代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Name: BigNumber Class</span></span><br><span class="line"><span class="comment">	Copyright: Zs</span></span><br><span class="line"><span class="comment">	Author: Zs</span></span><br><span class="line"><span class="comment">	Date: 04/04/20 09:08</span></span><br><span class="line"><span class="comment">	Description: A BigNumber Class</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="comment">// 和，差，积，商 </span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m; <span class="comment">// 余数，当无余数的时候 size 为0 </span></span><br><span class="line">		<span class="keyword">int</span> len;  <span class="comment">// 数字的长度 = v.size() </span></span><br><span class="line">		<span class="keyword">bool</span> flag; <span class="comment">//是否为负数的标志 </span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		BigNumber();<span class="comment">//无参构造函数 </span></span><br><span class="line">		BigNumber(<span class="built_in">string</span> s)  <span class="comment">//带参数的构造函数 </span></span><br><span class="line">		&#123;</span><br><span class="line">			*<span class="keyword">this</span>=s;</span><br><span class="line">		&#125;</span><br><span class="line">		BigNumber(<span class="keyword">const</span> BigNumber &amp;); <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="built_in">string</span> s);  <span class="comment">// 重载 "=" 声明 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> = (<span class="keyword">int</span> k);  <span class="comment">// 重载输入的数为整型的时候的 "=" 声明</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigNumber &amp;b);  <span class="comment">// 重载 "&lt;" 声明 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> + (<span class="keyword">const</span> BigNumber &amp;b); <span class="comment">// 重载 "+" 声明 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> - (BigNumber &amp;b); <span class="comment">// 重载 "-" 声明 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> * (BigNumber &amp;b);  <span class="comment">// 重载 "*" 声明 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> / (BigNumber &amp;b); <span class="comment">//重载 "/" 声明 </span></span><br><span class="line">		BigNumber <span class="keyword">operator</span> % (BigNumber &amp;b); <span class="comment">//重载 "%" 声明 </span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//输出函数 </span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">				flag=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=v.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>,v[i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=m.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>,m[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigNumber::BigNumber() <span class="comment">//无参构造函数 </span></span><br><span class="line">&#123;</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	len = <span class="number">0</span>;</span><br><span class="line">	flag=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber::BigNumber(<span class="keyword">const</span> BigNumber &amp;T) <span class="comment">// 拷贝构造函数 </span></span><br><span class="line">&#123;</span><br><span class="line">	v.assign(T.v.<span class="built_in">begin</span>(),T.v.<span class="built_in">end</span>());</span><br><span class="line">	len = T.len;</span><br><span class="line">	flag = T.flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="built_in">string</span> s) <span class="comment">// 重载 "=" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	len = s.length();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(s[len<span class="number">-1</span>-i]-<span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> = (<span class="keyword">int</span> k) <span class="comment">// 重载输入的数为整型的时候的 "=" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(k%<span class="number">10</span>);</span><br><span class="line">		k/=<span class="number">10</span>;</span><br><span class="line">		len++; </span><br><span class="line">	&#125;</span><br><span class="line">	len--;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  BigNumber::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigNumber &amp;b) <span class="comment">// 重载 "&lt;" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(a.len &lt; b.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a.len &gt; b.len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.v[i]!=b.v[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a.v[i] &lt; b.v[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> + (<span class="keyword">const</span> BigNumber &amp;b) <span class="comment">//重载 "+" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	Result.len = <span class="built_in">max</span>(a.len,b.len)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> add=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Result.len||add!=<span class="number">0</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p=add;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.len) p+=a.v[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.len) p+=b.v[i];</span><br><span class="line">		add=p/<span class="number">10</span>;</span><br><span class="line">		Result.v.push_back(p%<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Result.v[Result.v.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.v.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	Result.len=Result.v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> - (BigNumber &amp;b) <span class="comment">// 重载 "-" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(a,b);</span><br><span class="line">		Result.flag=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Result.len=a.len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.v[i]&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			a.v[i]+=<span class="number">10</span>;</span><br><span class="line">			a.v[i+<span class="number">1</span>]--;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(a.v[i] &lt; b.v[i]&amp;&amp;i&lt;b.len)</span><br><span class="line">		&#123;</span><br><span class="line">			a.v[i]+=<span class="number">10</span>;</span><br><span class="line">			a.v[i+<span class="number">1</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.len)</span><br><span class="line">		Result.v.push_back(a.v[i]-b.v[i]);</span><br><span class="line">		<span class="keyword">else</span> Result.v.push_back(a.v[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Result.v[Result.len<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.len &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.pop_back();</span><br><span class="line">		Result.len--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> * (BigNumber &amp;b) <span class="comment">// 重载 "*"  定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	Result.len=a.len+b.len;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Result.len;i++) Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.v[i+j]+=a.v[i]*b.v[j];</span><br><span class="line">			Result.v[i+j+<span class="number">1</span>]+=Result.v[i+j]/<span class="number">10</span>;</span><br><span class="line">			Result.v[i+j]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Result.v[Result.v.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.v.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	Result.len=Result.v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> / (BigNumber &amp;b) <span class="comment">// 重载 "/" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.v.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.m.push_back(a.v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.push_back(<span class="number">1</span>);</span><br><span class="line">		Result.m.push_back(<span class="number">0</span>);</span><br><span class="line">		Result.len=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">size</span> = a.len-b.len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">BigNumber <span class="title">p</span><span class="params">(b)</span></span>;</span><br><span class="line">			<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				p.v.insert(p.v.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			p.len = p.v.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">while</span>((a-p).flag==<span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a=a-p;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="built_in">size</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">size</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				Result.v.push_back(cnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				Result.v[i] = cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(Result.v[Result.v.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">0</span> &amp;&amp; Result.v.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.v.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">		Result.len=Result.v.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.v.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.m.push_back(a.v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line">BigNumber BigNumber::<span class="keyword">operator</span> % (BigNumber &amp;b) <span class="comment">//重载 "%" 定义 </span></span><br><span class="line">&#123;</span><br><span class="line">	BigNumber Result;</span><br><span class="line">	<span class="function">BigNumber <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		Result.v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> Result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">size</span> = a.len-b.len;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">BigNumber <span class="title">p</span><span class="params">(b)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				p.v.insert(p.v.<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			p.len = p.v.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">while</span>((a-p).flag==<span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a=a-p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.v.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Result.v.push_back(a.v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("test.out","w",stdout);</span></span><br><span class="line">	<span class="built_in">string</span> s1,s2;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	BigNumber a,b,c,e,f,k,j;</span><br><span class="line">	a=s1,b=s2;</span><br><span class="line">	e=s1,f=s2;</span><br><span class="line">	k=s1,j=s2;</span><br><span class="line">	c=a+b;</span><br><span class="line">	c.<span class="built_in">print</span>();</span><br><span class="line">	c=a-b;</span><br><span class="line">	c.<span class="built_in">print</span>();</span><br><span class="line">	c=k*j;</span><br><span class="line">	c.<span class="built_in">print</span>();</span><br><span class="line">	c=e%f;</span><br><span class="line">	c.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
      <tags>
        <tag>大数类</tag>
      </tags>
  </entry>
  <entry>
    <title>软件组考核第一周学习报告</title>
    <url>/2020/03/30/%E8%BD%AF%E4%BB%B6%E7%BB%84%E8%80%83%E6%A0%B8%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="Linux系统常见命令"><a href="#Linux系统常见命令" class="headerlink" title="Linux系统常见命令"></a>Linux系统常见命令</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><p><strong>cd (Change Directory)</strong>命令：跳转目录</p>
<ul>
<li><strong>cd path</strong> ： path为路径，进入相应目录</li>
<li><strong>cd #</strong> 或 <strong>cd ~</strong> ：回到主目录</li>
<li><strong>cd -</strong> ： 回到上次所在目录</li>
<li><strong>cd !$</strong> ：将上个命令的参数做为输入</li>
<li><strong>cd ..</strong> ：回到上层目录</li>
</ul>
<p><img src="/images/first/image-20200330164354765.png" alt="image-20200330164354765"></p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><strong>ls (List)</strong> 命令：列出当前目录文件</p>
<ul>
<li><p><strong>ls</strong> ： 显示当前目录文件</p>
</li>
<li><p><strong>ls -a</strong>：显示全部的文件及文件夹，包括隐藏的文件和文件夹。</p>
</li>
<li><p><strong>ls -l</strong>  ： 显示较全的文件信息，包括权限，用户，用户组。</p>
</li>
</ul>
<p><img src="/images/first/image-20200330164408910.png" alt="image-20200330164408910"></p>
</li>
<li><p><strong>Tab</strong> 键：通过按Tab可以进行自动补全。如果当前目录有前缀相同的文件，则按两下Tab可以显示出所有以具有该前缀的文件。</p>
</li>
<li><p><strong>mv (Move)</strong> 命令：移动（剪切）文件，也可以用作一个等效给文件或目录的重命名。</p>
<p>通过 <code>mv 文件x 目录a</code> 可以将当前目录下的文件x移入目录k。</p>
<p><img src="/images/first/image-20200330164434299.png" alt="image-20200330164434299"></p>
</li>
<li><p><strong>cp (Copy)</strong> 命令：拷贝，将一个文件或目录拷贝到另一个文件或目录。</p>
<p>通过 <code>cp [options] 文件x 目录a</code> 可以将当前目录下的文件x复制到目录a。</p>
<ul>
<li><strong>-a</strong>：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
</ul>
</li>
<li><p><strong>-d</strong>：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</p>
<ul>
<li><strong>-f</strong>：覆盖已经存在的目标文件而不给出提示。</li>
</ul>
</li>
<li><p><strong>-i</strong>：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</p>
<ul>
<li><strong>-p</strong>：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
</ul>
</li>
<li><p><strong>-r</strong>：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</p>
<ul>
<li><strong>-l</strong>：不复制文件，只是生成链接文件。</li>
</ul>
</li>
<li><p><strong>pwd(Print Working Directory)</strong>  命令：打印出当前工作目录</p>
</li>
<li><p><strong>mkdir</strong> 命令 ： <code>mkdir name</code>创建一个名为name的文件夹</p>
</li>
<li><p><strong>rm (Remove)</strong> 命令 ：删除文件，删除文件后不可恢复。特殊的 ，<strong>rmdir ** 为删除文件夹命令，</strong>rm -r<strong>是先删除目录内的内容，再删除目录。 **rm -i</strong> 为交互式进行删除，一个个确定。<strong>rm -f</strong> 为强制删除（慎用）。</p>
</li>
<li><p><strong>gedit</strong> 命令：<code>gedit path</code>  打开编辑某个文件。path为绝对路径或相对路径。</p>
</li>
<li><p><strong>touch</strong> 命令：<code>touch name</code> 创建一个文件，name包含拓展名。</p>
</li>
<li><p><strong>cat</strong> 命令：打开指定文件， 并显示其中内容在终端，并且可以将其复制到一个另文件中。如果cat后面加多个文件名，那么就会打开多个文件。</p>
</li>
<li><p><strong>tar</strong> 命令：压缩或解压命令。<code>tar [参数] 打包文件名 要打包的各个文件</code> 。</p>
<p>参数表：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td>-f</td>
<td>指定档案文件名称，f后面一定是.tar文件，所以放选项最后</td>
</tr>
<tr>
<td>-t</td>
<td>列出档案中包含的文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开档案文件</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;打包实例： <code>tar -cvf 文件名 要打包的文件</code>  解压实例：<code>tar -xvf 压缩包名</code></p>
</li>
</ul>
<p><img src="/images/first/image-20200330164654339.png" alt="image-20200330164654339"></p>
<h3 id="不同的查找方式"><a href="#不同的查找方式" class="headerlink" title="不同的查找方式"></a>不同的查找方式</h3><ul>
<li><p><strong>find</strong> ：使用方法为<code>find &lt;指定目录&gt;&lt;指定条件&gt;&lt;指定动作&gt;</code> ，如何find后面不加任何参数，那么就默认搜索当前目录及其子目录，并显示在屏幕上。</p>
<ul>
<li><p>&lt;指定目录&gt;：用于指定要搜索的目录，默认为当前所在目录。</p>
</li>
<li><p>&lt;指定条件&gt;：指定所要搜索文件的特征。</p>
<ul>
<li><strong>-name</strong> ：按文件名查找</li>
<li><strong>-perm</strong>：按文件权限查找</li>
<li><strong>-depth</strong>：查找时先在当前目录查找，然后查找其他子目录。</li>
<li><strong>-prune</strong>：不在当前指定路径查找。如果同时指定-depth，则此选项被忽略。</li>
<li><strong>-user/-nouser</strong>：按照文件属主查找/查找无效属主文件</li>
<li><strong>-group/-nogroup</strong>：按照文件属组查找/查找无效属组文件</li>
<li><strong>-newer file1 !file2</strong>：查找更改时间比file1新比file2旧的文件。</li>
<li><strong>-type</strong>：查找某一类型文件，b：块设备文件，d：目录，c：字符设备文件，P：管道文件，l：符号链接文件，f：普通文件。</li>
</ul>
<p><img src="/images/first/image-20200330164709797.png" alt="image-20200330164709797"></p>
<p><img src="/images/first/image-20200330164721033.png" alt="image-20200330164721033"></p>
</li>
</ul>
</li>
<li><p><strong>locate</strong> ：等价于 <code>find -name</code> ，但是速度要快，因为locate在一个本地数据库中存放了所有本地文件信息，每天自动更新，我们查找之前需要通过 <code>updatedb</code> 手动更新其中内容，不然可能会导致新改动的文件查找不到。</p>
<p><img src="/images/first/image-20200330164733755.png" alt="image-20200330164733755"></p>
</li>
<li><p><strong>whereis</strong> ：whereis可以用于程序名的搜索，可以通过参数 <strong>-s，-m，-s</strong> 分别搜索二进制文件，man说明文件，和源代码文件。如果省略参数，则返回所有信息。不过这个也是从本地数据库里面进行搜索。</p>
</li>
<li><p><strong>which</strong> ：只能用于寻找可执行文件，并通过path变量寻找。</p>
<p><strong>关于查找方式的总结，find命令非常强大，搜索全盘，而且可以配合多种参数进行各种各样的搜索。</strong><br><strong>而locate能做到搜索的更快，因为一种特殊的搜索位置，但是功能要略逊于find。whereis和which都是对于指定类型的搜索，专精某一方面。</strong></p>
</li>
</ul>
<h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><p>​    &nbsp;&nbsp;&nbsp;首先我了解到，linux文件系统中，每一个文件都会有一个编号，称为索引节点号inode。也就是i节点。</p>
<p>​    &nbsp;&nbsp;&nbsp;链接呢，我的感觉就是，建立一个源文件和链接文件的映射，两个之间会有一定的关系存在。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>创建链接</strong>的方式为 <code>ln 源文件 目标文件</code> ，默认为硬链接，软链接为 <code>ln -s 源文件 目标文件</code> 。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>对于软链接</strong>，很像快捷方式，可以跨文件系统（也就是说可以存在于不同的文件系统中），而且他有一个单独的inode，然后通过软连接可以打开源文件。</p>
<p>​    &nbsp;&nbsp;&nbsp;<strong>对于硬链接</strong>，就像是整了一个毛一样的东西出来，很像备份吧，而且两者名字可不同，他们的inode是同一个，只是把<strong>inode link count</strong> 域增加了1，也就是多了加了一个索引项，因为他们是一毛一样的东西，那么就肯定不能跨文件系统了，因为你这个东西在这个文件系统里面是代表这个东西，在另一个里面就不一定是了，会产生错误。</p>
<p>​    关于他们的几点其他区别如下</p>
<ul>
<li><p>软链接可以对一个不存在的文件名进行链接，如果用编辑器打开这个目标文件，那么会默认创建一个名为filename的文件，而硬链接肯定不行了，因为你文件不存在，他也就没有inode，无从创建链接。</p>
</li>
<li><p>软链接可以跨文件系统，硬链接不行。</p>
</li>
<li><p>软链接可以链接目录，硬链接不行。百度了解到，因为硬链接和源文件用的一个inode，用硬链接链接可以会形成循环依赖，导致系统死机。</p>
</li>
<li><p>硬链接在源文件删除后依然可以访问，因为它具有源文件的inode，而软链接在源文件删除后无法对源文件进行访问，因为inode没有了，索引不到了。</p>
</li>
<li><p>我们对硬链接文件中的内容进行修改也会影响到源文件，因为他们是同一个文件。当然软链接也可以，因为他就是相当于打开了源文件。</p>
</li>
<li><p>其他常见操作</p>
<ul>
<li><p>新建一个用户：通过<code>sudo useradd -m name</code> 会创建一个名为name的用户，看/home文件下会显示名为name的用户，可以通过 <code>sudo passwd name</code> 来为用户设置密码，通过<code>su name</code>来切换用户，如果想要删除则通过<code>sudo userdel [-r] name</code> 来删除，加上-r代表删除对应文件夹。我们可以通过命令来查看etc中的passwd文件，就能够看到是否创建成功。</p>
<p><img src="/images/first/image-20200330164751936.png" alt="image-20200330164751936"></p>
<p><img src="/images/first/image-20200330164808040.png" alt="image-20200330164808040"></p>
</li>
<li><p>权限的修改：我们可以通过<code>sudo gedit /etc/sudoers</code> 打开sudoers文件修改 # User privilege specification 下的目录，添加<code>&lt;用户名&gt; ALL=(ALL:ALL) ALL</code> 来为用户添加sudo权限。</p>
</li>
<li><p>连接网络</p>
<ul>
<li>无线网<ul>
<li><code>nmcli dev wifi</code> 查看可连接的无线网络</li>
<li><code>nmcli dev wifi connect name  password password</code> name为对应的wifi名称，而后面的password则是对应的密码。</li>
</ul>
</li>
<li>有线网拨号上网<ul>
<li><code>sudo ifconfig eth0 down/up</code> 为关闭或者开启网卡驱动。</li>
<li><code>sudo pppoeconf</code> 建立拨号连接，对于有线网卡输入 <code>sudo pppoeconf eth0</code> 然后输入拨号的用户名以及密码即可连接到网络。</li>
</ul>
</li>
</ul>
</li>
<li><p>sudo和su一些区别</p>
<ul>
<li>su（substitute user）：切换用户。</li>
<li>sudo：sudo是通过另一个用户来执行命令，也就是说一个命令需要root权限，你并不需要直接跑到root用户下执行，只需要通过sudo然后输入root的密码即可执行相应的命令。</li>
</ul>
</li>
<li><p>apt-get</p>
<ul>
<li><em>apt-get</em>，是一条linux命令，适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。通常搭配sudo命令使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Vim的常用操作"><a href="#Vim的常用操作" class="headerlink" title="Vim的常用操作"></a>Vim的常用操作</h2><ul>
<li>首先通过 <code>sudo apt-get install vim</code> 来安装Vim</li>
</ul>
<p><img src="/images/first/image-20200330164821953.png" alt="image-20200330164821953"></p>
<ul>
<li><p>通过 <code>vim name</code> 来编辑name这个文件，如果不存在那么就会创建一个。</p>
</li>
<li><p>Vim的使用</p>
<p>Vim分为了三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>，<strong>底线命令模式（Last line mode）</strong>。</p>
<ul>
<li><p>命令模式</p>
<p>我们刚进入vim就是进入了命令模式，可以通过输入 <strong>i或a或o</strong> 来切换到输入模式，也可以通过输入x来删除当前光标后的字符，还有一系列操作可以进行，也可以输入 <strong>:</strong> 来进入底线命令模式。</p>
<p>一些常用命令</p>
<ul>
<li><strong>/word</strong> 或 <strong>?word</strong> ：向光标之下 / 光标之上搜索word这个字符串。</li>
<li><strong>n / N</strong> ：继续上一个搜索操作 / 进行与上一个搜索操作相反的搜索</li>
<li><strong>ZZ</strong> ：按两下大写的Z，那么就是直接保存后离开。</li>
</ul>
</li>
<li><p>输入模式</p>
<p>输入模式也就是对文本进行编辑，和普通的类似。里面好像有挺多快捷键的，可以通过<strong>Page Up/Page Down</strong> 来上下翻页，可以通过 <strong>HOME/END</strong> 来将光标移到行首/行尾。通过 <strong>Insert</strong> 可以将光标切换为<strong>输入/替换模式</strong>，光标相应的变为<strong>竖线/下划线</strong>。通过 <strong>Esc</strong> 可以退出输入模式，切换到命令模式。</p>
</li>
<li><p>底线命令模式</p>
<p>输入 <code>:命令</code> 可以执行非常多的操作，一些常用命令如下。</p>
<ul>
<li><strong>:set nu / :set nonu</strong> ： 设置行号，取消行号。</li>
<li><strong>:n1,n2s/word1/word2/g</strong> ：将n1~n2行中所有的word1替换为word2，g后加c则每次替换前需要用户手动确认，如果加上i则忽略大小写。</li>
<li><strong>:1,$s/word1/word2/g</strong> 或 <strong>$s/word1/word2/g</strong> ：将第一行到最后一行中的word1替换为word2，g后加 <strong>c</strong> 则每次替换前需要用户确认，如果加上 <strong>i (ignore)</strong> 则忽略大小写。</li>
<li><strong>:w / :w!</strong> ：分别为保存，强制保存。</li>
<li><strong>:q / :q!</strong> ：分别为离开vim，强制离开vim，后者是不需要保存的时候可以选择直接退出。</li>
<li><strong>:wq / :wq!</strong> : 分别为存储后离开，强制存储后离开，我们发现加个叹号！一般就是强制的意思。</li>
<li><strong>:w [filename]</strong> ：将文本保存成一个叫filename的文件，类似于另存为。</li>
<li><strong>:r [filename]</strong> ：将文本文件filename读入写在光标之后。</li>
<li><strong>:n1,n2 w filename</strong> ：将文本n1~n2行保存在的filename中（新建一个文件保存）。</li>
<li><strong>:! command</strong> ：暂时离开vim到终端中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/first/vim.png" alt="img"></p>
]]></content>
      <categories>
        <category>Software group</category>
      </categories>
      <tags>
        <tag>Assessment</tag>
      </tags>
  </entry>
  <entry>
    <title>专题四:MATLAB绘图</title>
    <url>/2020/03/23/%E4%B8%93%E9%A2%98%E5%9B%9B-MATLAB%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="4-1-二维曲线"><a href="#4-1-二维曲线" class="headerlink" title="4.1 二维曲线"></a>4.1 二维曲线</h2><h3 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a><span id="jump">plot函数</span></h3><ul>
<li><strong>基本用法</strong>：<code>plot(x,y)</code> ，x和y分别代表横纵坐标，plot函数会将各个点连接起来，形成线，x和y一般为长度相等的向量。</li>
<li><strong>最简单的调用格式</strong>：<code>plot(x)</code><ul>
<li><strong>当x为实向量时</strong>，则以该元素下表为横坐标，元素的值为纵坐标绘制曲线。</li>
<li><strong>当x为复向量时</strong>，则以<strong>实部</strong>和<strong>虚部</strong>分别为横纵坐标绘制曲线。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><strong>plot(x,y)函数参数的变化形式</strong><ul>
<li><strong>当x为向量，y为矩阵</strong>：这时x的长度和y的列数（或行数）必须相等。这时候绘制多条曲线，分别是x为横坐标，取与x长度相等的那一个参数作为纵坐标，另一个参数为曲线的条数。<strong>如果y的行、列两个参数相等，那么用y的每一列作为纵坐标，曲线条数等于矩阵列数。</strong></li>
<li><strong>当x和y为同型矩阵</strong>：这时以x，y对应列元素为横、纵坐标绘制曲线，曲线条数等于矩阵列数。</li>
<li><strong>含多个输入参数</strong>：形如 <code>plot(x1,y1,x2,y2,···,xn,yn)</code> ，那么就是以每一个向量对组成一个点，绘制曲线。</li>
</ul>
</li>
<li><strong>含选项的plot函数，plot(x,y,选项)</strong><ul>
<li><strong>线型</strong> ：通过<code>&quot;-&quot;,&quot;:&quot;,&quot;-.&quot;,&quot;--&quot;</code> 等参数来实现实线，虚线，点画线，双画线。</li>
<li><strong>颜色</strong> ：通过 <code>&quot;r&quot;,&quot;g&quot;</code> 等实现曲线颜色的切换。当颜色选项省略，绘图自动循环使用。</li>
<li><strong>数据点标记</strong> ：通过 <code>&quot;*&quot;,&quot;o&quot;,&quot;s&quot;</code> 等来实现将数据点用星号，圆圈，方块标记。</li>
</ul>
</li>
</ul>
<h3 id="fplot函数"><a href="#fplot函数" class="headerlink" title="fplot函数"></a><span id="jump2">fplot函数</span></h3><p>​    可根据参数函数的变化特性自适应地设置采样间隔，当函数值变化缓慢，采样间隔大，当变化快的时候，采样间隔小。</p>
<ul>
<li><p><strong>基本用法</strong>：<code>fplot(f,lims,选项)</code> ，参数分别函数（一般采用函数句柄表示），lims为x轴的取值范围，采用二元向量  <code>[xmin,xmax]</code> 来表示，默认值为 <code>[-5,5]</code> 。选项参数与plot函数相同。</p>
</li>
<li><p><strong>双输入参数函数的用法</strong>：<code>fplot(funx,funy,tlims,选项)</code> ，前两个分别为x，y的参数表示，通常以函数句柄的形式给出。tlims为前方函数参数 <strong>t</strong> 的取值范围，用二元向量 <code>[tmin,tmax]</code> 表示，默认的值为 <code>[-5,5]</code> ，选项参数与上述相同。</p>
</li>
</ul>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><ul>
<li>利用不同的线型和颜色在同一坐标内绘制曲线 $y=2e^{-0.5x}sin(2\pi x)$ 以及其包络线。（包络线：在<a href="https://baike.baidu.com/item/几何学/342546">几何学</a>，某个曲线族的<strong>包络线</strong>（<a href="https://baike.baidu.com/item/Envelope/7364077">Envelope</a>），是跟该曲线族的每条线都有至少一点相切的一条曲线。）</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>)';</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>]; <span class="comment">%这里绘制的是上下两条包络线，是有两行的矩阵。</span></span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x); <span class="comment">%这里绘制的是曲线本身</span></span><br><span class="line">x1=<span class="number">0</span>:<span class="number">0.5</span>:<span class="number">6</span>;</span><br><span class="line">y3=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x1).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x1); <span class="comment">%这里标记的是正弦函数和x轴的交点。</span></span><br><span class="line"><span class="built_in">plot</span>(x, y1, <span class="string">'k:'</span>, x, y2, <span class="string">'b--'</span>, x1, y3, <span class="string">'rp'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/plot1.png" alt="plot"></p>
<ul>
<li>利用fplot函数绘制  $y=sin{\frac{1}{x}}$  在区间 $[0,0.2]$ 的图像。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fplot(@x <span class="built_in">sin</span>(<span class="number">1.</span>/x),[<span class="number">0</span>,<span class="number">0.2</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/images/plot2.png" alt="plot2"></p>
<hr>
</br>

<h2 id="4-2-绘制图形的辅助操作"><a href="#4-2-绘制图形的辅助操作" class="headerlink" title="4.2 绘制图形的辅助操作"></a>4.2 绘制图形的辅助操作</h2><h3 id="添加图形标注"><a href="#添加图形标注" class="headerlink" title="添加图形标注"></a>添加图形标注</h3><ul>
<li><p><strong>title函数</strong>：用于给图形添加标题说明</p>
<ul>
<li><strong>基本用法</strong>：<code>title(&#39;图形标题&#39;)</code> ，如果是有多行，就用逗号分隔，大括号<code>{}</code>括起来。</li>
<li><strong>LaTeX排版</strong>：可在在图形标题中使用LaTeX格式控制符，要用LaTeX时将其控制字符用大括号<code>{}</code>括起来。</li>
<li><strong>控制字体</strong>：用 <code>&quot;\bf&quot;</code> ,<code>&quot;\it&quot;</code>，<code>&quot;\rm&quot;</code> 分别控制字体加粗，斜体以及正体。</li>
<li><strong>设置title函数属性</strong> ： <code>title(图形标题，属性名，属性值)</code> 其中属性名和属性值对应成对出现。<ul>
<li><strong>Color属性</strong>：用于设置图形标题文本的颜色，缺省时为黑色。</li>
<li><strong>FontSize属性</strong> ：用于设置标题文字字号，缺省时为11。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>xlable和ylable函数</strong>：给x轴和y轴添加说明</p>
<ul>
<li><strong>基本用法</strong>： <code>xlable(x轴说明)</code> ，<code>ylable(y轴说明)</code> ，同样还有 zlable等。</li>
</ul>
</li>
<li><p><strong>text函数和gtext函数</strong>：给特定位置说明</p>
<ul>
<li><strong>基本用法</strong>：<ul>
<li><code>text(x,y,说明)</code>，x、y参数用来指明说明的位置，<strong>后面的说明和title函数类似</strong>。</li>
<li><code>gtext(说明)</code>  这里没有坐标指定位置，通过鼠标的点击来指定位置。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>legend函数</strong>：用于给图形添加图例</p>
<ul>
<li><strong>基本用法</strong>：<code>legend(图例1，图例2,···)</code> 其中图例顺序要与plot函数中参数顺序相对应，<strong>图例的说明方式与tiele函数标题说明类似</strong>。</li>
</ul>
</li>
</ul>
<h3 id="坐标控制"><a href="#坐标控制" class="headerlink" title="坐标控制"></a>坐标控制</h3><ul>
<li><p><strong>axis函数</strong>：用于设置坐标轴的范围</p>
<ul>
<li><p><strong>基本用法</strong>：<code>axis([xmin,xmax,ymin,ymax,zmin,zmax])</code> ，分别代表了x，y，z轴范围。</p>
</li>
<li><p><strong>其他用法</strong>：通过在axis函数下面加语句来实现控制其他格式。</p>
<ul>
<li><strong>axis equal</strong>：横纵坐标刻度等长。</li>
<li><strong>axis square</strong>：采用正方形坐标系（默认为矩形）。</li>
<li><strong>axis auto</strong>：使用默认设置。</li>
<li><strong>axis off/on</strong>：不显示/显示坐标轴。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>给坐标系加网格和边框</strong></p>
<ul>
<li><strong>添加网格</strong>：通过 <code>grid on/off</code> 控制显示和不显示网格线，而直接用 <code>grid</code> 用于切换两种形式，如果是带网格则切换为不带，反之亦然。如果不添加语句，则默认不带。</li>
<li><strong>添加边框</strong>：通过 <code>box on/off</code> 控制显示不显示边框，用法与 <strong>grid</strong> 类似，如果不添加语句，则默认带网格。</li>
</ul>
</li>
</ul>
<h3 id="图形保持"><a href="#图形保持" class="headerlink" title="图形保持"></a>图形保持</h3><p>​    一般情况下绘图命令每执行一次，图形界面就刷新一次，去掉原有图形，绘制新图形，如果要保留原有图形，可使用图形保持命令。通过<code>hold on\off</code> 来控制是否保留，通过 <code>hold</code> 切换保留和不保留两种选择。</p>
<h3 id="图形窗口分割"><a href="#图形窗口分割" class="headerlink" title="图形窗口分割"></a>图形窗口分割</h3><ul>
<li><strong>子图</strong>：同一图形窗口中的不同坐标系下的图形称为子图。</li>
<li><strong>subplot函数</strong> ：<code>subplot(m,n,p)</code>  意思是将图形窗口分成 $m\times n$ 个子图区域，当前绘制的是第p个子图，区号按行编号。我们在一个图形窗口内，绘制不同的图可以采用不同的分割。</li>
</ul>
<h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><ul>
<li><p>绘制 $sinx$ 、$sin2x$ 、$sin(\frac{x}{2})$  的图像，并添加相应的图形标注。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">6</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">y=[<span class="built_in">sin</span>(x);<span class="built_in">sin</span>(<span class="number">2</span>*x);<span class="built_in">sin</span>(x./<span class="number">2</span>)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">6</span>*<span class="built_in">pi</span>,<span class="number">-1.1</span>,<span class="number">1.1</span>]);</span><br><span class="line">title(<span class="string">'不同频率正弦函数曲线'</span>);</span><br><span class="line">xlabel(<span class="string">'X-axis'</span>);</span><br><span class="line">ylabel(<span class="string">'Y-axis'</span>);</span><br><span class="line">text(<span class="number">2.5</span>,<span class="built_in">sin</span>(<span class="number">2.5</span>),<span class="string">'sin(x)'</span>);</span><br><span class="line">text(<span class="number">1.5</span>,<span class="built_in">sin</span>(<span class="number">3</span>),<span class="string">'sin(2*x)'</span>);</span><br><span class="line">text(<span class="number">5.5</span>,<span class="built_in">sin</span>(<span class="number">0.5</span>*<span class="number">5.5</span>),<span class="string">'sin(x/2)'</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'sin(x)'</span>,<span class="string">'sin(2x)'</span>,<span class="string">'sin(x/2)'</span>);</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/plot3.png" alt="plot3"></p>
<ul>
<li>利用子图函数在不同区域绘出不同图形。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">sin</span>(x));</span><br><span class="line">title(<span class="string">'sin(x)'</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">cos</span>(x));</span><br><span class="line">title(<span class="string">'cos(x)'</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">tan</span>(x));</span><br><span class="line">title(<span class="string">'tan(x)'</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">cot</span>(x));</span><br><span class="line">title(<span class="string">'cot(x)'</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-35</span>,<span class="number">35</span>]);</span><br></pre></td></tr></table></figure>

<p><img src="/images/plot4.png" alt="plot4"></p>
<hr>
</br>

<h2 id="4-3-其他形式的二维曲线"><a href="#4-3-其他形式的二维曲线" class="headerlink" title="4.3 其他形式的二维曲线"></a>4.3 其他形式的二维曲线</h2><h3 id="其他坐标系下的二维曲线图"><a href="#其他坐标系下的二维曲线图" class="headerlink" title="其他坐标系下的二维曲线图"></a>其他坐标系下的二维曲线图</h3><ul>
<li><p><strong>对数坐标图</strong></p>
<ul>
<li><strong>semilogx</strong> 函数：调用形式与plot函数类似，<code>semilogx(x,y,选项)</code>为其中一种调用格式，其他的可参考plot函数，此函数绘图采用半对数坐标，x轴采用常用对数刻度，y轴为线性刻度。</li>
<li><strong>semilogy</strong> 函数：调用形式与plot函数类似，<code>semilogy(x,y,选项)</code>为其中一种调用格式，其他的可参考plot函数，此函数绘图采用半对数坐标，y轴采用常用对数刻度，x轴为线性刻度。</li>
<li><strong>loglog</strong> 函数：调用函数与上述类似，x和y都为常用对数刻度。</li>
</ul>
</li>
<li><p><strong>极坐标图</strong></p>
<ul>
<li>基本调用格式：<code>polar(theta,rho,选项)</code> <strong>theta</strong>为极角，<strong>rho</strong> 为极径，选项与plot函数类似。</li>
</ul>
</li>
</ul>
<h3 id="统计图"><a href="#统计图" class="headerlink" title="统计图"></a>统计图</h3><ul>
<li><p><strong>条形类图形</strong></p>
<ul>
<li><p><strong>条形图</strong></p>
<ul>
<li><p><strong>bar</strong> 函数：绘制二维垂直条形图</p>
<ul>
<li>调用格式为<code>bar(y,style)</code> ：y如果为向量，则以每个元素值作为每一个柱的高度，元素下标代表横坐标。如果y为矩阵，则以每一行作为一组，以行号作为组号绘图。后方的 <strong>style</strong> 有 <code>&quot;grouped&quot;</code> 和<code>&quot;stacked&quot;</code> 两种模式，分别为簇状分组和堆积分组。默认为簇状分组。</li>
<li>调用格式为<code>bar(x,y,style)</code> ：其中x存储横坐标，y为矩阵，存储每一个横坐标对应的数据，y的行数必须与x的长度相对应。</li>
</ul>
</li>
<li><p><strong>barh</strong> 函数：绘制二维水平条形图。调用格式与<strong>bar</strong>函数相同。</p>
</li>
</ul>
</li>
<li><p><strong>直方图</strong></p>
<ul>
<li><p><strong>hist</strong> 函数：绘制直角坐标系下的直方图。</p>
<ul>
<li>调用格式为 <code>hist(y)</code> ，y为向量，绘图时将 $[miny,maxy]$ 区间等分成十组，并求出每个区间内对应元素的个数，然后绘出直方图。</li>
<li>调用格式为<code>hist(y,x)</code>，如果x为标量，则将y区间分成x个区间，如果x为向量，则向量中的每一个数指定分组的中心值，元素的个数为指定分成的组数，x缺省默认均分十组。</li>
</ul>
</li>
<li><p><strong>rose</strong> 函数：用于绘制极坐标系下的直方图。</p>
<ul>
<li>调用格式为 <code>rose(theta,x)</code> 其中参数 <strong>theta</strong> 用于确定每一数据与圆点的角度，如果x为标量，则x代表均分组数，缺省默认为20。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>面积类图形</strong></p>
<ul>
<li><strong>扇形图/饼图</strong><ul>
<li><strong>pie</strong> 函数：调用格式为 <code>pie(x,explode)</code> 其中参数x为待统计的数据，通常为向量，其中每一个数据在整体中占用的比例在扇形图中表示出来，后续的 <strong>explode</strong> 为每个x对应的分离参数，如果非0，则将其分离出来。<strong>explode</strong> 缺省则饼图为一个整体。</li>
</ul>
</li>
<li><strong>面积图</strong><ul>
<li><strong>area</strong> 函数：与plot函数类似，下方与坐标轴围成的区域进行填充。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>散点类图形</strong></p>
<ul>
<li><strong>散点图</strong><ul>
<li><strong>scatter</strong> 函数：<code>scatter(x,y,选项,&#39;filled&#39;)</code> ，其中x和y通常为同等大小向量，代表了一定数量的点。选项与<a href="#jump">plot函数</a>类似，用于限制颜色，线型，以及数据点标记，如果采用数据点标记，则可以用 <strong>‘filled’</strong> 参数来填充数据点，如果缺省，则标记数据点为空心。</li>
</ul>
</li>
<li><strong>阶梯图</strong><ul>
<li><strong>stairs</strong> 函数：使用方法与上述 <strong>scatter</strong> 函数类似。</li>
</ul>
</li>
<li><strong>杆图</strong><ul>
<li><strong>stem</strong> 函数： 使用方法与上述 <strong>scatter</strong> 函数类似。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>矢量类图形</strong></p>
<ul>
<li><p><strong>箭头图</strong></p>
<ul>
<li><strong>quiver</strong> 函数：常用此绘制磁力线，矢量。调用格式为<code>quiver(x,y,u,v)</code> ， 其中 <strong>(x,y)</strong> 为矢量起点，<strong>(u,v)</strong> 为矢量终点，如果x，y省略，则均匀取若干个点作为起点。</li>
</ul>
</li>
<li><p><strong>罗盘图</strong></p>
<ul>
<li><strong>compasser</strong>函数：与 <a href="#jump"><strong>plot</strong> 函数</a>类似。</li>
</ul>
</li>
<li><p><strong>羽毛图</strong></p>
<ul>
<li><strong>feather</strong> 函数：与 <a href="#jump"><strong>plot</strong> 函数</a>类似。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h3><ul>
<li>某次考试成绩优秀，良好，中等，及格，不及格人数分别为：7、13，23，9，4，用扇形统计图作成绩统计。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">score = [<span class="number">7</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">9</span>,<span class="number">4</span>];</span><br><span class="line">tag = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">pie(score,tag);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">"Excellent"</span>,<span class="string">"Good"</span>,<span class="string">"Middle"</span>,<span class="string">"Qualified"</span>,<span class="string">"Bad"</span>,<span class="string">'Location'</span>,<span class="string">'eastoutside'</span>);</span><br><span class="line"><span class="comment">%上方legend中的location是用于指定图例出现位置的，如果不指定，会与统计图重合</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不加location参数</p>
</blockquote>
<p><img src="/images/pie.png" alt="pie"></p>
<blockquote>
<p>加入location参数</p>
</blockquote>
<p><img src="/images/pie2.png" alt="pie2"></p>
<hr>
</br>

<h2 id="4-4-三维曲线"><a href="#4-4-三维曲线" class="headerlink" title="4.4 三维曲线"></a>4.4 三维曲线</h2><h3 id="plot3函数：绘制三维曲线最常用的函数。"><a href="#plot3函数：绘制三维曲线最常用的函数。" class="headerlink" title="plot3函数：绘制三维曲线最常用的函数。"></a>plot3函数：绘制三维曲线最常用的函数。</h3><ul>
<li><p><strong>基本用法</strong>：<code>plot3(x,y,z)</code> 其中三个参数分别为坐标对，一般为等长向量，plot3函数用直线将所有点连起来。</p>
</li>
<li><p><strong>变化形式</strong>：</p>
<ul>
<li><p>当<code>plot(x,y,z)</code> 当x，y，z为同型矩阵，则绘制多条曲线，曲线条数等于矩阵列数。</p>
</li>
<li><p>当x，y，z中有向量也有矩阵的时候，向量的长度应与矩阵相符，如果是行向量，那么行向量的长度应与矩阵列数相同，如果是列向量，那么列向量的长度应与矩阵行数相同。</p>
</li>
<li><p>也可以用多组向量对来绘制多组曲线，<code>plot(x1,y1,z1,x2,y2,z2···,xn,yn,zn)</code> ；</p>
</li>
</ul>
</li>
<li><p><strong>含选项的plot3函数</strong>：<code>plot(x,y,z,选项)</code> 选项与功能与<a href="#jump">plot函数</a>类似。</p>
</li>
</ul>
<h3 id="fplot3函数"><a href="#fplot3函数" class="headerlink" title="fplot3函数"></a>fplot3函数</h3><ul>
<li><strong>基本用法</strong>：与<a href="#jump2">fplot函数</a>类似</li>
</ul>
<hr>
</br>

<h2 id="4-5-三维曲面"><a href="#4-5-三维曲面" class="headerlink" title="4.5 三维曲面"></a>4.5 三维曲面</h2><h3 id="生成平面网格数据"><a href="#生成平面网格数据" class="headerlink" title="生成平面网格数据"></a>生成平面网格数据</h3><ul>
<li><strong>meshgrid</strong> 函数：调用格式 <code>[X,Y]=meshgrid(x,y)</code> ，其中x，y为向量，X，Y为存储网格坐标系横纵坐标的矩阵。如果只填一个 <strong>x</strong> ，那么就相当于 <strong>x=y</strong> 。</li>
</ul>
<h3 id="绘制三维曲面的函数"><a href="#绘制三维曲面的函数" class="headerlink" title="绘制三维曲面的函数"></a>绘制三维曲面的函数</h3><ul>
<li><p><strong>mesh</strong> 函数 &amp; <strong>surf</strong> 函数</p>
<ul>
<li><p><strong>基本调用格式</strong>：<code>mesh(x,y,z,c) &amp; surf(x,y,z,c)</code>，两者可以用来绘制三维曲面，其中<strong>x，y</strong>为网格坐标矩阵，<strong>z</strong> 是网格点上的高度矩阵，<strong>c</strong> 用于指定在不同高度下的曲面颜色。如果 <strong>c</strong> 缺省，则默认 <strong>c=z</strong> ，也就是说颜色正比于高度。</p>
</li>
<li><p><strong>其他调用格式</strong>： <code>mesh(z,c) &amp; surf(z,c)</code> 这样的话就用z矩阵的<strong>列，行</strong>坐标代表<strong>x，y</strong>的值，z的值代表高度，c的意义与上面相同。</p>
</li>
<li><p><strong>其他花里胡哨的</strong> ：</p>
<ul>
<li>带等高线的三维网格曲面函数 <code>meshc</code> 和 带底座的三维网格曲面函数<code>meshz</code> ，用法与 <strong>mesh</strong> 函数相同。前者带等高线，后者带底座（就是说下面是实体的）。</li>
<li>带等高线的曲面函数 <code>surfc</code> 和具有光照效果的曲面函数 <code>surfl</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="标准三维曲面"><a href="#标准三维曲面" class="headerlink" title="标准三维曲面"></a>标准三维曲面</h3><ul>
<li><strong>sphere</strong> 函数：生成三维球面对应坐标。格式<code>[x,y,z]=sphere(n)</code> ，这将产生x，y，z三个(n+1)阶的方阵，通过这三个方针结合绘制三维曲面的函数 (<strong>surf</strong>或者<strong>mesh</strong>)，可以绘制出圆心在圆点，半径为一的单位球面。如果不加输出参数<strong>x,y,z</strong>，则直接绘制球面。n的值代表<strong>圆滑程度</strong>，默认为<strong>20</strong>.</li>
<li><strong>cylinder</strong> 函数：生成三维柱面对应坐标。格式为 <code>[x,y,z]=cylinder(R,n)</code> R为一个向量，存放柱面各个等间隔高度上的半径，n表示圆柱圆周上的间隔点个数，默认为20。如果R为标量，则生成一个柱面。</li>
</ul>
<h3 id="fsurf和fmesh函数"><a href="#fsurf和fmesh函数" class="headerlink" title="fsurf和fmesh函数"></a>fsurf和fmesh函数</h3><p>​    用于绘制参数方程表示的函数，并且有两个变参。调用格式为 <code>fsurf(funx,funy,funz,uvlims)</code>，其中前三个通常为函数句柄形式给出的函数，<strong>uvlims</strong> 表示前三个函数自变量取值范围，用四元向量组来进行描述，形如<code>[umin,umax,vmin,vmax]</code>，默认值为<code>[-5,5,-5,5]</code> 。</p>
<h3 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h3><ul>
<li>绘制螺旋曲面。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">funx = @(u,v) u.*<span class="built_in">sin</span>(v);</span><br><span class="line">funy = @(u,v) -u.*<span class="built_in">cos</span>(v);</span><br><span class="line">funz = @(u,v) v;</span><br><span class="line">fsurf(funx,funy,funz,[<span class="number">-5</span> <span class="number">5</span> <span class="number">-5</span> <span class="number">-2</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">fmesh(funx,funy,funz,[<span class="number">-5</span> <span class="number">5</span> <span class="number">-2</span> <span class="number">2</span>])</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>

<p><img src="/images/luoxuan.png" alt="luoxuan"></p>
<ul>
<li>绘制函数$z=(x-1)^2+(y-2)^2-1$ 的曲面图，分别用带等高线的mesh函数，带底座的mesh函数，带等高线的surf函数，带光照效果的surf函数绘制。$x\in[0,2],y\in[1,3]$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[x,y]=<span class="built_in">meshgrid</span>(<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">0.1</span>:<span class="number">3</span>);</span><br><span class="line">z=(x<span class="number">-1</span>).^<span class="number">2</span>+(y<span class="number">-2</span>).^<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">meshc(x,y,z);title(<span class="string">'meshc(x,y,z)'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">meshz(x,y,z);title(<span class="string">'meshz(x,y,z)'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">surfc(x,y,z);title(<span class="string">'surfc(x,y,z)'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">surfl(x,y,z); title(<span class="string">'surfl(x,y,z)'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/mesh.png" alt="mesh"></p>
]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>专题三:MATLAB程序流程控制</title>
    <url>/2020/03/18/%E4%B8%93%E9%A2%98%E4%B8%89-MATLAB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="3-1-顺序结构程序"><a href="#3-1-顺序结构程序" class="headerlink" title="3.1 顺序结构程序"></a>3.1 顺序结构程序</h2><h3 id="程序设计的基本步骤"><a href="#程序设计的基本步骤" class="headerlink" title="程序设计的基本步骤"></a>程序设计的基本步骤</h3><p><img src="/images/step.png" alt="step"></p>
<a id="more"></a>

<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul>
<li>在matlab中程序文件扩展名为<strong>.m</strong> ，因此程序文件又叫 <strong>M文件</strong>。</li>
<li>程序文件分<strong>两种</strong><ul>
<li><strong>脚本文件</strong>：是可以在命令行窗口直接执行的文件，也叫命令文件。</li>
<li><strong>函数文件</strong>：定义一个函数，以函数调用方式来调用，不能单独执行。</li>
</ul>
</li>
</ul>
<h3 id="文件的建立"><a href="#文件的建立" class="headerlink" title="文件的建立"></a>文件的建立</h3><ul>
<li>可以在主页点击新建脚本，即可创建脚本文件，并且打开MATLAB编辑器。</li>
<li>在命令行窗口写 <code>edit test</code> 即可在当前文件下创建 <strong>test</strong> 脚本文件。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%利用脚本文件求两矩阵乘积</span></span><br><span class="line"><span class="comment">%脚本文件f1.m</span></span><br><span class="line">A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>];</span><br><span class="line">B=[<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">C=A*B;</span><br><span class="line"><span class="comment">%在命令行窗口运行脚本文件</span></span><br><span class="line">&gt;&gt; f1</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">22</span>    <span class="number">28</span></span><br><span class="line">    <span class="number">49</span>    <span class="number">64</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%利用函数文件求两矩阵乘积</span></span><br><span class="line"><span class="comment">%函数文件f1.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>=<span class="title">f2</span><span class="params">(A,B)</span></span></span><br><span class="line">C=A*B;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&gt;&gt; C=f1(A,B)</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">22</span>    <span class="number">28</span></span><br><span class="line">    <span class="number">49</span>    <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ul>
<li>数据的输入 ： <code>A=input(提示信息，参数选项)</code> ，输入时会将提示信息打印出来，后面的参数选项用于限定输入数据的类型等。</li>
<li>数据的输出： <code>disp(输出项)</code> </li>
<li>程序的暂停： <code>pause(延迟秒数)</code> ，<strong>如果延迟秒数省略，那么就会一直暂停直到用户下次动作</strong>。如果程序运行中要强行暂停可以通过 <strong>Ctrl+C</strong> 实现。</li>
</ul>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><ol>
<li><strong>通过脚本文件和函数文件求一个向量的四舍五入向量。</strong></li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">脚本</span><br><span class="line">A=[<span class="number">1.2</span>,<span class="number">3.4</span>,<span class="number">4.7</span>,<span class="number">0.5</span>];</span><br><span class="line">B=<span class="built_in">round</span>(A);</span><br><span class="line"><span class="built_in">disp</span>(B)</span><br><span class="line">函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>=<span class="title">f2</span><span class="params">(A)</span></span></span><br><span class="line">B=<span class="built_in">round</span>(A);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>求两点之间距离以及黄金分割点坐标（其中点坐标通过复数形式输入）。</strong></li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=input(<span class="string">'a='</span>);</span><br><span class="line">b=input(<span class="string">'b='</span>);</span><br><span class="line">c=a+<span class="number">0.618</span>*(b-a);</span><br><span class="line">s=<span class="built_in">abs</span>(b-a);</span><br><span class="line"><span class="built_in">disp</span>(s)</span><br><span class="line"><span class="built_in">disp</span>(c)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-2-用if语句实现选择结构"><a href="#3-2-用if语句实现选择结构" class="headerlink" title="3.2 用if语句实现选择结构"></a>3.2 用if语句实现选择结构</h2><h3 id="单分支if语句"><a href="#单分支if语句" class="headerlink" title="单分支if语句"></a>单分支if语句</h3><p>​    &nbsp;&nbsp;&nbsp;<strong>如果成立执行语句组，如果不成立则跳出if，语句格式如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件(关系运算或逻辑运算)</span><br><span class="line">   语句组</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="双分支if语句"><a href="#双分支if语句" class="headerlink" title="双分支if语句"></a>双分支if语句</h3><p>​    &nbsp;&nbsp;&nbsp;<strong>如果成立执行语句组1，不成立执行语句组2，然后跳出if，语句格式如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件(关系运算或逻辑运算)</span><br><span class="line">   语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="多分支if语句"><a href="#多分支if语句" class="headerlink" title="多分支if语句"></a>多分支if语句</h3><p>​    &nbsp;&nbsp;&nbsp;<strong>根据上述双分支的类推，依次判断条件1~n，成立则执行对应语句组，然后跳出if，不成立则往下寻找，语句格式如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span></span><br><span class="line">   语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">elseif</span> 条件<span class="number">2</span></span><br><span class="line">   语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">elseif</span> 条件<span class="number">3</span></span><br><span class="line">   语句组<span class="number">3</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">elseif</span> 条件n<span class="number">-1</span></span><br><span class="line">   语句组n<span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span> 语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="条件成立的判断"><a href="#条件成立的判断" class="headerlink" title="条件成立的判断"></a>条件成立的判断</h3><ul>
<li>当条件结果为标量，非零表示真，零表示假。</li>
<li>当条件为矩阵，如果<strong>矩阵非空且不包含零元素</strong>，则条件成立，否则不成立。</li>
</ul>
<hr>
<h2 id="3-3-用switch语句实现选择结构"><a href="#3-3-用switch语句实现选择结构" class="headerlink" title="3.3 用switch语句实现选择结构"></a>3.3 用switch语句实现选择结构</h2><h3 id="switch语句的基本格式"><a href="#switch语句的基本格式" class="headerlink" title="switch语句的基本格式"></a>switch语句的基本格式</h3><p>​    &nbsp;&nbsp;&nbsp;表示在C++里面就不喜欢用switch，感觉太麻烦了。这个和多分支if有点像吧，只是他的区别在于首先给出一个表达式，在下方每一个语句组对应着一个结果表，如果结果表对应着表达式的值，就执行当前语句组，<strong>执行完之后跳出switch语句，这个和C++的有所区别。</strong>此外，如果都不满足的话，我们还可以加入一个条件<strong>otherwise</strong>，顾名思义，如果上述结果都不满足，就执行这个otherwise下对应的语句，switch的语句格式如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式</span><br><span class="line">  <span class="keyword">case</span> 结果表<span class="number">1</span></span><br><span class="line">     语句组<span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> 结果表<span class="number">2</span></span><br><span class="line">     语句组<span class="number">2</span></span><br><span class="line">···</span><br><span class="line">  <span class="keyword">case</span> 结果表n</span><br><span class="line">     语句组n</span><br><span class="line">  <span class="keyword">otherwise</span></span><br><span class="line">     语句组k</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="switch的使用规则"><a href="#switch的使用规则" class="headerlink" title="switch的使用规则"></a>switch的使用规则</h3><ul>
<li>case结果表为switch表达式的取值，<strong>当取值有多个时，我们可以用单元数据表示</strong>。将这多个结果用大括号<code>{}</code>括起来，如果表达式值满足其中一个，就执行相应语句组。</li>
</ul>
<hr>
<h2 id="用for语句实现循环结构"><a href="#用for语句实现循环结构" class="headerlink" title="用for语句实现循环结构"></a>用for语句实现循环结构</h2><h3 id="常用的for语句"><a href="#常用的for语句" class="headerlink" title="常用的for语句"></a>常用的for语句</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% for语句格式：</span></span><br><span class="line"><span class="keyword">for</span> 循环变量=表达式<span class="number">1</span>:表达式<span class="number">2</span>:表达式<span class="number">3</span></span><br><span class="line">    循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以发现循环变量后面对应的是一个冒号表达式，分别是起始，步长，终止。</li>
<li>循环执行时，先求出冒号表达式对应的行向量，然后依次遍历行向量中的每一个元素，执行循环体语句。</li>
<li>for语句针对向量每一个元素执行一次循环体，有几个元素执行几次，当冒号表达式对应的向量为空向量，则一次也不执行。</li>
<li>当退出循环后，循环变量值为行向量组中的最后一个元素。</li>
</ul>
<h3 id="更一般的for语句"><a href="#更一般的for语句" class="headerlink" title="更一般的for语句"></a>更一般的for语句</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=矩阵表达式</span><br><span class="line">	循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更一般的for语句循环遍历后对应的是矩阵表达式，执行过程中将矩阵的各列元素，赋值给循环变量，这时候，循环变量为一个列向量，而不是上述常用for语句中的标量，可以发现，常用的for语句是一般格式下的特例。<strong>循环的次数为矩阵的列数。</strong></li>
</ul>
<h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><p>计算圆周率 $\pi$</p>
<ul>
<li>利用循环求无穷级数展开求 $\pi$</li>
</ul>
<p>$$<br>1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}+\cdots+(-1)^{n+1}\frac{1}{2n-1} =\frac{\pi}{4}<br>$$</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">y=<span class="number">0</span>;</span><br><span class="line">g=<span class="number">-1</span>;</span><br><span class="line">n=input(<span class="string">'n='</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">	g=-g;</span><br><span class="line">	y=y+g*<span class="number">1</span>/(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="number">4</span>*y)</span><br></pre></td></tr></table></figure>

<ul>
<li>利用矩阵求和求无穷级数展开求 $\pi$ </li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">n=input(<span class="string">'n='</span>);</span><br><span class="line">x=<span class="number">1</span>:<span class="number">2</span>:(<span class="number">2</span>*n<span class="number">-1</span>);</span><br><span class="line">y=(<span class="number">-1</span>).^(<span class="number">2</span>:n+<span class="number">1</span>)./x;</span><br><span class="line"><span class="built_in">disp</span>(sum(y)*<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-5-用while语句实现循环结构"><a href="#3-5-用while语句实现循环结构" class="headerlink" title="3.5 用while语句实现循环结构"></a>3.5 用while语句实现循环结构</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>​    &nbsp;&nbsp;&nbsp;通过一个条件来判定是否执行循环体语句，当条件成立时，成立。不像是for循环先去设定循环多少次，循环变量依次取什么值，这个是根据条件限定，又叫<strong>条件循环语句</strong>。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件</span><br><span class="line">     循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h3><ul>
<li><strong>break语句</strong>：当循环执行到break语句会跳出当前循环，进行循环外的语句。</li>
<li><strong>continue语句</strong>：当循环执行到continue语句，会结束本次循环，进行下一次判断是否继续循环体。</li>
</ul>
<h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>​    &nbsp;&nbsp;&nbsp;如果一个循环结构循环体又包括循环结构，那么就称为<strong>循环嵌套</strong>or<strong>多重循环结构</strong>。通过嵌套的层数不同来不同的命名，例如二重循环，三重循环等等。</p>
<h3 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h3><ol>
<li><p>从键盘输入若干数，<strong>当输入0时结束输入</strong>，求这些数的和和他们的平均值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">msum=<span class="number">0</span>;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">x=input(<span class="string">'Enter your numbers: '</span>);</span><br><span class="line"><span class="keyword">while</span> x~=<span class="number">0</span></span><br><span class="line">    msum=msum+x;</span><br><span class="line">    cnt=cnt+<span class="number">1</span>;</span><br><span class="line">    x=input(<span class="string">'Enter your numbers: '</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> cnt&gt;<span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(msum);</span><br><span class="line">    <span class="built_in">disp</span>(msum/cnt);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用筛法求 <strong>1~m</strong> 范围内的素数。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">m=input(<span class="string">'m='</span>);</span><br><span class="line">p=<span class="number">1</span>:m;</span><br><span class="line">p(<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:<span class="built_in">sqrt</span>(m)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>*<span class="built_in">i</span>:<span class="built_in">i</span>:m</span><br><span class="line">		p(<span class="built_in">j</span>)=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">n=<span class="built_in">find</span>(p~=<span class="number">0</span>);</span><br><span class="line">p(n)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="3-6-函数文件的定义与调用"><a href="#3-6-函数文件的定义与调用" class="headerlink" title="3.6 函数文件的定义与调用"></a>3.6 函数文件的定义与调用</h2><h3 id="函数文件的基本结构"><a href="#函数文件的基本结构" class="headerlink" title="函数文件的基本结构"></a>函数文件的基本结构</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出参数表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">注释说明部分</span><br><span class="line">函数体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当有多个形参时，形参之间用 <code>,</code> 逗号分隔，组成形参表。当输出形参多于一个，用方括号 <code>[]</code> 括起来，形成输出矩阵。</li>
</ul>
<h3 id="函数使用中的一些规定"><a href="#函数使用中的一些规定" class="headerlink" title="函数使用中的一些规定"></a>函数使用中的一些规定</h3><ul>
<li><p>函数文件名通常由 <strong>函数名再加上拓展名.m</strong> 组成，函数文件名与函数名也可以不同，当两者不同时，MATLAB默认忽视函数名，调用时使用函数文件名。<strong>但一般我们将函数名和函数文件名进行统一</strong></p>
</li>
<li><p>如果函数文件中有 <strong>return</strong> 语句，就结束函数的执行，返回栈底。</p>
</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[输出实参表]=函数名(输入实参表)</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    &nbsp;&nbsp;&nbsp;MATLAB提供了一种特殊的函数，函数句柄变量相当于这个函数的别名，通过函数句柄可以间接的调用函数，多个参数之间用逗号分隔。</p>
<ul>
<li><p><strong>函数定义的基本格式如下</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">函数句柄变量 = @(匿名函数输入参数) 匿名函数表达式</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数调用的基本格式如下</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">函数句柄变量(匿名函数输入实参)</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊的，我们可以将一个已知的内部函数或者自定义函数，赋值给一个函数句柄变量，这样我们就可以通过函数句柄变量变量来简洁的调用函数。<strong>(类似于改个名字)</strong></p>
</li>
</ul>
<h3 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h3><ul>
<li><p>通过函数文件和匿名函数两个形式，求出 $x^2+y^2$ 的值。</p>
<ul>
<li>函数文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function z&#x3D;f2(x,y)</span><br><span class="line">    z&#x3D;x^2+y^2;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名函数</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f=@(x,y) x^<span class="number">2</span>+y^<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="3-7-函数的递归调用"><a href="#3-7-函数的递归调用" class="headerlink" title="3.7 函数的递归调用"></a>3.7 函数的递归调用</h2><h3 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h3><p>​    &nbsp;&nbsp;&nbsp;如果一个函数在函数体内部调用自己本身称为递归调用（如果是其他函数称为嵌套调用）。<strong>递归是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</strong></p>
<ul>
<li><strong>直接递归调用</strong>：在一个函数体内部直接调用自己本身。</li>
<li><strong>简介递归调用</strong>：在一个函数体内不嵌套调用其他函数，其他函数又调用自己。</li>
</ul>
<h3 id="例程-4"><a href="#例程-4" class="headerlink" title="例程"></a>例程</h3><ul>
<li>求 $n!=1\times2\times3\cdots \times n$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">fact</span><span class="params">(n)</span></span></span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">1</span></span><br><span class="line">   f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   f=fact(n<span class="number">-1</span>)*n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-8-函数参数与变量的作用域"><a href="#3-8-函数参数与变量的作用域" class="headerlink" title="3.8 函数参数与变量的作用域"></a>3.8 函数参数与变量的作用域</h2><h3 id="函数参数的可调性"><a href="#函数参数的可调性" class="headerlink" title="函数参数的可调性"></a>函数参数的可调性</h3><p>​    &nbsp;&nbsp;&nbsp;可调性顾名思义，就是可以调节的。MATLAB函数在调用过程中函数传递参数的数目是可以调节的。在调用时，函数有两个预定义变量，<strong>nargin</strong> 和 <strong>nargout</strong>  ，前者记录调用函数时输入实参的个数，后者记录调用函数时输出实参的个数。通过这两个变量，可以针对不同的变量个数进行不同的处理。</p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul>
<li>函数中定义的变量是局部变量，不能被其他函数引用</li>
<li>我们可以通过 <code>global 变量名</code> 来定义一个全局变量，如果不加 <strong>global</strong> ，默认是局部变量。</li>
<li>全局变量的作用域是整个MATLAB工作空间，全程有效，所有函数都可以对他进行存取和修改。</li>
<li>但是要注意的是，这里的全局变量使用方式和C++的有所区别，如果你要在函数中调用工作区中的全局变量，那么你需要在函数体内部定义相同的全局变量，这样才可以对其进行引用，函数体内部和工作区中的变量值是共享的。</li>
</ul>
<h3 id="例程-5"><a href="#例程-5" class="headerlink" title="例程"></a>例程</h3><ul>
<li>求 $x1\times x+y1\times y$ ，其中<strong>x1</strong> 和 <strong>y1</strong> 是全局工作区中全局变量的值。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%函数文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">solve</span><span class="params">(x,y)</span></span></span><br><span class="line"><span class="keyword">global</span> x1 y1</span><br><span class="line">f=x1*x+y1*y</span><br><span class="line"><span class="comment">%工作区</span></span><br><span class="line"><span class="keyword">global</span> x1 y1;</span><br><span class="line">x1=<span class="number">1</span>;</span><br><span class="line">y1=<span class="number">2</span>;</span><br><span class="line">s=solve(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>专题二:MATLAB矩阵处理</title>
    <url>/2020/03/15/%E4%B8%93%E9%A2%98%E4%BA%8C-MATLAB%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="2-1-特殊矩阵"><a href="#2-1-特殊矩阵" class="headerlink" title="2.1 特殊矩阵"></a>2.1 特殊矩阵</h2><h3 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h3><ul>
<li><p><strong>zeros函数</strong>： 产生全0矩阵，即零矩阵。</p>
</li>
<li><p><strong>ones函数</strong>：  产生全1函数，即幺矩阵。</p>
</li>
<li><p><strong>eye函数</strong>： 产生对角线为1的矩阵，当矩阵为方针时，为单位矩阵。</p>
</li>
<li><p><strong>rand函数</strong>： 产生 <strong>(0,1)</strong> 区间均匀分布的随机矩阵。</p>
</li>
<li><p>通过 <code>fix(a+(b-a+1)*rand(x))</code> 可产生[a,b]区间上均匀分布的随机整数。</p>
</li>
<li><p><strong>randn函数</strong>： n为normal的意思，产生均值为0，方差为1的标准正态分布随机矩阵。</p>
<ul>
<li>通过 $\mu+\sigma x$  来得到均值为 $\mu$ ，方差为 $\sigma{^2}$ 的随机数据。<strong>(高中数学知识，证明可百度)</strong></li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>对于上述函数的调用格式，我们都有如下规定，<code>zeros(m)</code>为产生 $m\times m$ 的零矩阵，<code>zeros(m,n)</code>为产生类型为 $m\times n$ 的零矩阵， <code>zeros(size(A))</code> 为产生和 <strong>A</strong> 同类型的零矩阵，其余函数和此类似。</li>
</ul>
<h3 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h3><ol>
<li><p><strong>魔方/幻方矩阵 (Magic Square)</strong></p>
<ul>
<li>n阶幻方矩阵每行，每列，主副对角线的和相等。</li>
<li>n阶幻方矩阵每行每列的元素之和为 $(1+2+3+\cdots+n^2)/n=(n+n^3)/2$</li>
</ul>
</li>
<li><p><strong>范德蒙矩阵 (Vandermonde)</strong></p>
<ul>
<li><p>利用 <strong>Vander(V)</strong> 生成以向量 V 为基础的<strong>范德蒙(Vandermonde)</strong>矩阵。</p>
<p><img src="/images/Vander.png" alt="Vander"></p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="built_in">vander</span>(<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>     <span class="number">4</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">    <span class="number">81</span>    <span class="number">27</span>     <span class="number">9</span>     <span class="number">3</span>     <span class="number">1</span></span><br><span class="line">   <span class="number">256</span>    <span class="number">64</span>    <span class="number">16</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">   <span class="number">625</span>   <span class="number">125</span>    <span class="number">25</span>     <span class="number">5</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>希尔伯特矩阵 (Hilbert)</strong> </p>
<ul>
<li>利用 <strong>hilb(n)</strong> 可以生成n阶希尔伯特矩阵。</li>
</ul>
<p><img src="/images/Hilbert.png" alt="Hilbert"></p>
</li>
<li><p><strong>伴随矩阵</strong>  </p>
<ul>
<li><p>通过 <strong>compan(p)</strong> 可以生成向量p对应的多项式的伴随矩阵。<strong>p向量中高次系数在前，低次系数在后。</strong>(我感觉我学过伴随矩阵，但看了之后又感觉没学过QAQ)</p>
<p><img src="/images/Company.png" alt="Company"></p>
</li>
</ul>
</li>
<li><p><strong>帕斯卡矩阵</strong></p>
<ul>
<li>通过 <strong>pascal(n)</strong> 生成一个n阶帕斯卡矩阵。</li>
</ul>
<p><img src="/images/Pascal1.png" alt="Pascal"></p>
<p><img src="/images/Pascal2.png" alt="Pascal"></p>
</li>
</ol>
<hr>
<h2 id="2-2-矩阵变换"><a href="#2-2-矩阵变换" class="headerlink" title="2.2 矩阵变换"></a>2.2 矩阵变换</h2><h3 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h3><ul>
<li>对角矩阵：只有对角线上有非0元素的矩阵是对角矩阵。如果对角线上元素相等，则称为数量矩阵。当对角线上元素相等且为1，称为单位矩阵。</li>
<li>提取矩阵的对角线元素<ul>
<li><strong>diag(A):</strong> 提取矩阵A主对角线元素，产生一个列向量。</li>
<li><strong>diag(A,k):</strong> 提取矩阵A第k条对角线元素，产生一个列向量。主对角线为第0条，往上依次为1，2···n，往下依次为-1，-2 ··· -n。</li>
</ul>
</li>
<li>构造对角矩阵<ul>
<li><strong>diag(V):</strong> 以向量V为主对角线元素，产生对角矩阵。</li>
<li><strong>diag(V,k):</strong> 以向量V为第k条对角线元素，产生对角矩阵。</li>
</ul>
</li>
</ul>
<h3 id="三角阵"><a href="#三角阵" class="headerlink" title="三角阵"></a>三角阵</h3><ul>
<li>矩阵对角线以上元素全为0为上三角矩阵，以下全为0为下三角矩阵。</li>
<li>上，下三角矩阵 <strong>(上 up，下 low)</strong>，关于下三角的只需要把 <strong>triu</strong> 换为 <strong>tril</strong><ul>
<li><strong>triu(A):</strong> 提取矩阵A的主对角线及以上的元素。</li>
<li><strong>triu(A,k):</strong> 提取矩阵A的第k条对角线及以上的元素。</li>
</ul>
</li>
</ul>
<h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><ul>
<li>普通转置运算符为 <code>.&#39;</code> ，共轭转置为 <code>&#39;</code> ，它在转置的基础上还会求每个数的复共轭。</li>
</ul>
<h3 id="矩阵的旋转"><a href="#矩阵的旋转" class="headerlink" title="矩阵的旋转"></a>矩阵的旋转</h3><ul>
<li><strong>rot90(A,k):</strong> 将矩阵A逆时针方向旋转 $90^{\circ}$ 的k倍，当k为1时可以省略。</li>
</ul>
<h3 id="矩阵的翻转"><a href="#矩阵的翻转" class="headerlink" title="矩阵的翻转"></a>矩阵的翻转</h3><ul>
<li><strong>fliplr(A):</strong>  对矩阵A实施左右翻转。</li>
<li><strong>flipud(A):</strong>  对矩阵A进行上下反转。</li>
</ul>
<h3 id="矩阵的求逆"><a href="#矩阵的求逆" class="headerlink" title="矩阵的求逆"></a>矩阵的求逆</h3><ul>
<li><strong>inv(A):</strong> 求A的逆阵。 </li>
</ul>
<h3 id="矩阵的阶梯状"><a href="#矩阵的阶梯状" class="headerlink" title="矩阵的阶梯状"></a>矩阵的阶梯状</h3><ul>
<li><strong>rref(A):</strong>  将矩阵A化为阶梯状（具体不再解释，不懂可百度）</li>
</ul>
<hr>
<h2 id="2-3-矩阵求值"><a href="#2-3-矩阵求值" class="headerlink" title="2.3 矩阵求值"></a>2.3 矩阵求值</h2><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><ul>
<li>通过 <strong>det(A)</strong> 可以求A矩阵的行列式值。</li>
</ul>
<h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><ul>
<li>通过 <strong>rank(A)</strong> 可以求A矩阵的秩。</li>
</ul>
<h3 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h3><ul>
<li>矩阵的迹等于对角线元素之和，也等于特征值之和。通过 <strong>trace(A)</strong> 可以求A矩阵的迹。</li>
</ul>
<h3 id="向量和矩阵的范数"><a href="#向量和矩阵的范数" class="headerlink" title="向量和矩阵的范数"></a>向量和矩阵的范数</h3><ul>
<li><p>范数用来度量矩阵或向量在某种意义下的长度。</p>
</li>
<li><p>向量的范数</p>
<ul>
<li>向量 1-范数 : 为向量元素的绝对值之和。通过 <strong>norm(V,1)计算V的1-范数</strong>  </li>
</ul>
<p>$$<br>||V||{_1}=\sum\limits^n_{i=1}|v_i|<br>$$</p>
</li>
</ul>
<ul>
<li><p>向量 2-范数 : 为向量元素绝对值的平方和的平方根。通过<strong>norm(V)或者norm(V,2)计算向量V的2-范数</strong></p>
<p>$$<br>||V||_2=\sqrt{\sum\limits^n_{i=1}|v_i|^2}<br>$$</p>
</li>
</ul>
<ul>
<li><p>向量 ∞-范数 : 所有向量元素绝对值中的最大值。通过<strong>norm(V,inf)计算向量V的∞-范数</strong></p>
<p>$$<br>||V||_{\infty}=\mathop{max}\limits_{0&lt;=i&lt;=n}{|v_i|}<br>$$</p>
</li>
</ul>
<ul>
<li><p>矩阵的范数<strong>（对不起我实在不想写latex了，直接截图了）</strong></p>
<ul>
<li>矩阵的范数求法和向量的一样一样滴</li>
</ul>
<p><img src="/images/fanshu.png" alt="fanshu"></p>
</li>
</ul>
<h3 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h3><ul>
<li>用于描述矩阵性能的数，等于矩阵的范数乘逆阵的范数，条件数约接近一，矩阵性能越好。</li>
<li>通过 <strong>cond(A,1)</strong> ，<strong>cond(A)或cond(A,2) ，cond(A,inf)</strong> 分别求矩阵A三种范数下的条件数。</li>
</ul>
<hr>
<h2 id="2-4-矩阵的特征值与特征向量"><a href="#2-4-矩阵的特征值与特征向量" class="headerlink" title="2.4 矩阵的特征值与特征向量"></a>2.4 矩阵的特征值与特征向量</h2><h3 id="求矩阵的特征值"><a href="#求矩阵的特征值" class="headerlink" title="求矩阵的特征值"></a>求矩阵的特征值</h3><ul>
<li><strong>E=eig(A)</strong> ：求矩阵A的全部特征值，构成向量E。</li>
<li><strong>[X,D]=eig(A)</strong> ：求矩阵A的全部特征值，构成对角阵D，并产生矩阵X，X各列为相应特征值对应的特征向量。</li>
</ul>
<h3 id="特征值的几何意义"><a href="#特征值的几何意义" class="headerlink" title="特征值的几何意义"></a>特征值的几何意义</h3><p>​    这里没太听懂，回头来补，咕咕咕QAQ。 </p>
<hr>
<h2 id="2-5-稀疏矩阵"><a href="#2-5-稀疏矩阵" class="headerlink" title="2.5 稀疏矩阵"></a>2.5 稀疏矩阵</h2><p>​    <strong>稀疏矩阵就是零元素个数远远大于非0元素个数的矩阵</strong>。</p>
<h3 id="矩阵的存储方式"><a href="#矩阵的存储方式" class="headerlink" title="矩阵的存储方式"></a>矩阵的存储方式</h3><ul>
<li><strong>完全存储方式</strong>：把所以元素按列依次存储</li>
<li><strong>稀疏存储方式</strong>：只存储非0元素的行列下标和数值，不改变存储顺序，依次按列存储。</li>
</ul>
<h3 id="稀疏存储方式的产生"><a href="#稀疏存储方式的产生" class="headerlink" title="稀疏存储方式的产生"></a>稀疏存储方式的产生</h3><ul>
<li><p>完全存储方式与稀疏存储方式的转化</p>
<ul>
<li>通过 <strong>A=sparse(S)</strong> 可以将矩阵S转化为稀疏存储方式的矩阵A</li>
<li>通过 <strong>S=full(A)</strong> 可以将矩阵A转化为完全存储方式的矩阵S。 </li>
</ul>
</li>
<li><p>直接建立稀疏存储矩阵</p>
<ul>
<li><p><strong>sparse(m,n)</strong> 可以建立一个 $m\times n$ 的所有元素都为0的稀疏矩阵。</p>
</li>
<li><p><strong>sparse(u,v,S)</strong>  其中u，v，S为3个等长向量，分别表示行下标，列下标，非零元素。</p>
</li>
<li><p><strong>B=spconvert(A)</strong> ，A是一个 $m\times 3$ 或 $m\times4$ 的矩阵，每一行元素依次表示一个稀疏矩阵的非零元素，从1~4列分别为，行下标，列下标，元素实部，元素虚部，若元素为实数，则第四列省略。</p>
</li>
</ul>
</li>
<li><p>单位矩阵的稀疏存储</p>
<ul>
<li><strong>speye(m,n)</strong> 可返回一个 $m\times n$ 的稀疏存储单位矩阵。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>专题一:MATLAB基础知识</title>
    <url>/2020/03/14/%E4%B8%93%E9%A2%98%E4%B8%80-MATLAB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1-1-MATLAB系统环境"><a href="#1-1-MATLAB系统环境" class="headerlink" title="1.1 MATLAB系统环境"></a>1.1 MATLAB系统环境</h2><h3 id="MATLAB操作界面的组成"><a href="#MATLAB操作界面的组成" class="headerlink" title="MATLAB操作界面的组成"></a>MATLAB操作界面的组成</h3><ol>
<li><strong>MATLAB主窗口</strong></li>
<li><strong>命令行窗口</strong><ul>
<li>命令行窗口含有 <code>&gt;&gt;</code> 命令提示符，表示MATLAB处于准备状态，可以接受并执行命令，按下回车键后MATLAB会执行输入命令，并在后面显示执行结果</li>
<li>如果指令过长可以分行输入，在一行末尾写 <code>...</code> 并按下回车键，在下个命令行继续输入，<code>...</code>称为续行符。</li>
</ul>
</li>
<li><strong>当前文件夹窗口</strong><ul>
<li>在MATLAB编程过程中生成的文件自动存放在当前文件夹，我们可以通过cd命令(例如我们要进入E盘下的work文件夹，可以<code>cd e:\work</code>)或者选择文件工具栏中的文件夹来设置当前文件夹。</li>
</ul>
</li>
<li><strong>工作区窗口</strong><ul>
<li>可用于变量的显示和操作，可显示你当前创建的变量。并且可对其保存，修改，删除。</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h3 id="MATLAB的搜索路径"><a href="#MATLAB的搜索路径" class="headerlink" title="MATLAB的搜索路径"></a>MATLAB的搜索路径</h3><ul>
<li><strong>检索命令对象的顺序如下</strong></li>
</ul>
<p><img src="/images/search.png" alt="search"></p>
<ul>
<li><strong>设置文件搜索路径</strong><ul>
<li>用path命令设置文件搜索路径。例如： path{path,`e:\work`}</li>
<li>用对话框设置文件搜索路径。在MATLAB主窗口的主页中设置。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-2-MATLAB数值数据"><a href="#1-2-MATLAB数值数据" class="headerlink" title="1.2 MATLAB数值数据"></a>1.2 MATLAB数值数据</h2><h3 id="数值数据类型的分类"><a href="#数值数据类型的分类" class="headerlink" title="数值数据类型的分类"></a>数值数据类型的分类</h3><ul>
<li><p><strong>整型</strong></p>
<ul>
<li>无符号整数：含有8，16，32，64四种</li>
<li>带符号整数：含有8，16，32，64四种</li>
</ul>
<p>范围和C语言一样,通过<code>类型(数据)</code> 来进行强转。</p>
</li>
<li><p><strong>浮点型</strong></p>
<ul>
<li>单精度：占四字节</li>
<li>双精度：占八字节，数值数据默认为双精度</li>
</ul>
<p>通过single和double函数进行强转。</p>
</li>
<li><p><strong>复型</strong></p>
<ul>
<li><p>复型数据包括实部和虚部两部分，都默认为浮点型，虚数单位用<strong>i</strong>或<strong>j</strong>来表示。</p>
</li>
<li><p>通过read和imag函数来求复型数据的实部和虚部。</p>
</li>
</ul>
</li>
<li><p><strong>字符型</strong></p>
<ul>
<li><strong>字符在内部作为数字存储，而不会采用浮点格式存储。</strong></li>
</ul>
</li>
</ul>
<h3 id="数值数据的输出格式"><a href="#数值数据的输出格式" class="headerlink" title="数值数据的输出格式"></a>数值数据的输出格式</h3><ul>
<li>format命令的格式，使用方法 <code>format 格式符</code>，不带格式符的format会恢复默认格式。<strong>ps：format只影响数据的输出，不影响数据的存储和计算。</strong></li>
</ul>
<h3 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h3><ol>
<li><p><strong>函数的调用格式为</strong>： <strong>函数名(函数自变量的值)</strong></p>
<ul>
<li>函数自变量规定为矩阵变量，也可以为标量（为矩阵的特例）。</li>
<li>函数在运算时将函数逐项作用在每个元素上，最后运算出来是一个与自变量同类型矩阵。</li>
</ul>
</li>
<li><p><strong>常用函数的应用</strong></p>
<ul>
<li>三角函数有两类，例如sin和sind两种，前面是弧度制，后面是角度制，其余cos等类似。</li>
<li>abs函数可以求实数的绝对值、复数的模、字符串的ASCII码值。</li>
<li>用于取整的函数有fix，floor，ceil，round。分别为靠0取整，向下取整，向上取整，四舍五入取整。</li>
<li>判断是否为素数的函数isprime，是素数返回1，不是返回0。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x=[<span class="number">1</span>:<span class="number">100</span>];</span><br><span class="line">&gt;&gt; k=<span class="built_in">isprime</span>(x);</span><br><span class="line">&gt;&gt; k1=<span class="built_in">find</span>(k);</span><br><span class="line">&gt;&gt; p=x(k1)</span><br><span class="line"></span><br><span class="line">p =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> 至 <span class="number">16</span> 列</span><br><span class="line"></span><br><span class="line">     <span class="number">2</span>     <span class="number">3</span>     <span class="number">5</span>     <span class="number">7</span>    <span class="number">11</span>    <span class="number">13</span>    <span class="number">17</span>    <span class="number">19</span>    <span class="number">23</span>    <span class="number">29</span>    <span class="number">31</span>    <span class="number">37</span>    <span class="number">41</span>    <span class="number">43</span>    <span class="number">47</span>    <span class="number">53</span></span><br><span class="line"></span><br><span class="line">  <span class="number">17</span> 至 <span class="number">25</span> 列</span><br><span class="line"></span><br><span class="line">    <span class="number">59</span>    <span class="number">61</span>    <span class="number">67</span>    <span class="number">71</span>    <span class="number">73</span>    <span class="number">79</span>    <span class="number">83</span>    <span class="number">89</span>    <span class="number">97</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<h2 id="1-3-变量及其操作"><a href="#1-3-变量及其操作" class="headerlink" title="1.3 变量及其操作"></a>1.3 变量及其操作</h2><h3 id="变量与赋值语句"><a href="#变量与赋值语句" class="headerlink" title="变量与赋值语句"></a>变量与赋值语句</h3><ul>
<li>变量本质是一个内存单元的抽象，变量名以字母开头，后接数字、字母或下划线，最多63个字符。</li>
<li>变量名区分字母大小写(case sensitive)，<strong>标准函数名以及命令名必须用小写字母</strong>。</li>
<li>赋值语句有两种格式<ul>
<li>变量 = 表达式</li>
<li>表达式的值赋值MATLAB预定义变量ans</li>
</ul>
</li>
<li>如果赋值后不加分号，会显示变量的结果，如果加了分号，则不显示。</li>
</ul>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>预定义变量是系统自身定义的变量</p>
<ul>
<li><strong>ans</strong> 是默认赋值变量，命令行表达式值默认赋值给 <strong>ans</strong></li>
<li><strong>i</strong> 和 <strong>j</strong> 代表虚数单位</li>
<li><strong>pi</strong> 表示圆周率</li>
<li><strong>NaN</strong> 代表非数</li>
</ul>
<h3 id="变量的管理"><a href="#变量的管理" class="headerlink" title="变量的管理"></a>变量的管理</h3><ol>
<li><strong>变量的删除和修改</strong></li>
</ol>
<ul>
<li>在工作区进行变量的删除和修改<ul>
<li>通过 <strong>who</strong> 和 <strong>whose</strong> 命令来查看变量清单，前者只显示名称，后者显示各种信息</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>内存变量文件</strong></li>
</ol>
<ul>
<li>用于保存MATLAB工作区变量的文件交内存变量文件，扩展名为.mat，也叫MAT文件，是一种二进制文件。<ul>
<li>save命令：创建内存变量文件，load命令：载入内存变量文件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-4-MATLAB矩阵的表示"><a href="#1-4-MATLAB矩阵的表示" class="headerlink" title="1.4 MATLAB矩阵的表示"></a>1.4 MATLAB矩阵的表示</h2><h3 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h3><ul>
<li><p><strong>直接输入法建立矩阵</strong></p>
<p>将矩阵的元素用中括号<code>[]</code> 括起来，按行输入元素，同一行元素用逗号或者空格分隔，用分号换行。</p>
</li>
<li><p><strong>利用已有矩阵建立更大矩阵</strong></p>
<p>个人感觉类似于分块矩阵，例子如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">&gt;&gt; B=[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>;<span class="number">-4</span>,<span class="number">-5</span>,<span class="number">-6</span>;<span class="number">-7</span>,<span class="number">-8</span>,<span class="number">-9</span>];</span><br><span class="line">&gt;&gt; C=[A,B;B,A]</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>    <span class="number">-1</span>    <span class="number">-2</span>    <span class="number">-3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>    <span class="number">-4</span>    <span class="number">-5</span>    <span class="number">-6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>    <span class="number">-7</span>    <span class="number">-8</span>    <span class="number">-9</span></span><br><span class="line">    <span class="number">-1</span>    <span class="number">-2</span>    <span class="number">-3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">    <span class="number">-4</span>    <span class="number">-5</span>    <span class="number">-6</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">    <span class="number">-7</span>    <span class="number">-8</span>    <span class="number">-9</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用两个实矩阵矩阵通过矩阵的运算可以建立复数矩阵</strong>，<strong>要确保两个矩阵同类型</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; B=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;&gt; C=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&gt;&gt; D=B+<span class="built_in">i</span>*C</span><br><span class="line"></span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.0000</span> + <span class="number">7.0000</span><span class="built_in">i</span>   <span class="number">2.0000</span> + <span class="number">8.0000</span><span class="built_in">i</span>   <span class="number">3.0000</span> + <span class="number">9.0000</span><span class="built_in">i</span></span><br><span class="line">   <span class="number">4.0000</span> + <span class="number">1.0000</span><span class="built_in">i</span>   <span class="number">5.0000</span> + <span class="number">2.0000</span><span class="built_in">i</span>   <span class="number">6.0000</span> + <span class="number">3.0000</span><span class="built_in">i</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="冒号表达式"><a href="#冒号表达式" class="headerlink" title="冒号表达式"></a>冒号表达式</h3><ul>
<li><p><strong>通过冒号表达式可以产生行向量</strong></p>
<p>一般格式为<code>e1:e2:e3</code> 分别是初始值，步长，终止值。可以省略e2，省略时步长为默认为1。</p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; t=<span class="number">0</span>:<span class="number">1</span>:<span class="number">5</span></span><br><span class="line">t=</span><br><span class="line">	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span></span><br><span class="line">&gt;&gt; s=<span class="number">0</span>:<span class="number">5</span></span><br><span class="line">s</span><br><span class="line">	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>通过linspace函数产生行向量</strong></p>
<p>linspace(a,b,n) 代表首元素为a，末尾元素为b，产生n个元素，相应的，步长为(b-a)/(n-1)。当n可以省略，省略时默认n为100。</p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="built_in">pi</span>,<span class="number">5</span>)</span><br><span class="line">x=</span><br><span class="line">	<span class="number">0</span>    <span class="number">0.7854</span>    <span class="number">1.5708</span>    <span class="number">2.3562</span>    <span class="number">3.1416</span></span><br></pre></td></tr></table></figure>

<h3 id="结构矩阵和单元矩阵"><a href="#结构矩阵和单元矩阵" class="headerlink" title="结构矩阵和单元矩阵"></a>结构矩阵和单元矩阵</h3><ul>
<li><p><strong>结构矩阵</strong></p>
<ul>
<li><p>类似于C语言的结构体，把很多个数据写成一个结构体，矩阵里的每个元素个元素都是结构体变量。给对应元素赋值格式为 <strong>结构体元素.成员名=表达式</strong> 。我们应该注意到，当一个结构体内没有我们赋值的成员，那么他会自动扩充矩阵来满足你的要求。</p>
</li>
<li><p>我们可以通过 <code>s=struct(&#39;name&#39;,{&#39;next&#39;,&#39;what&#39;},&#39;sex&#39;,{&#39;male&#39;,&#39;unknow&#39;})</code> 来创建一个包含 <strong>name</strong> 和 <strong>sex</strong> 两个成员的结构体。</p>
</li>
</ul>
</li>
<li><p><strong>单元矩阵</strong></p>
<p>矩阵里的每个元素的类型可以不同，通过直接输入法建立，所有元素用大括号<code>{}</code>而不是中括号<code>[]</code></p>
</li>
</ul>
<hr>
<h2 id="1-5-矩阵元素的引用"><a href="#1-5-矩阵元素的引用" class="headerlink" title="1.5 矩阵元素的引用"></a>1.5 矩阵元素的引用</h2><h3 id="矩阵元素的引用方式"><a href="#矩阵元素的引用方式" class="headerlink" title="矩阵元素的引用方式"></a>矩阵元素的引用方式</h3><ol>
<li>通过下标来引用矩阵，例如A(3,2)表示A矩阵第三列第二个元素。如果我们引用的元素超出矩阵范围，那么会默认扩充矩阵至满足要求，拓展元素默认为0。</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;&gt; A(<span class="number">4</span>,<span class="number">5</span>)=<span class="number">10</span></span><br><span class="line">A=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line">	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>通过序号来引用，<strong>注意矩阵元素按列存储</strong>，依次存放第一列，第二列···最后一列。</p>
</li>
<li><p>矩阵元素的序号和下标可以通过 <code>sub2ind</code> 和 <code>ind2sub</code> 两个函数完成相互转化</p>
<ul>
<li><strong>sub2ind</strong> 函数：将矩阵中指定元素的行列下标转换成存储的序号，格式为<code>D=sub2ind(S,I,J)</code>，三个参数依次为<strong>行数和列数组成的二维向量(可以通过size函数获取)</strong>，<strong>转换矩阵元素的行下标</strong>，<strong>转换矩阵元素的列下标</strong>。如果I，J为矩阵的话，那么就说明要将对应的一个下标矩阵求对应序号。注意结合下例来进行理解，我们注意到A(1,1)的序号为1，A(2,1)的序号为2，那么就是给定下标矩阵的顺序来生产的这个序号矩阵，类型相同。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">A=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></span><br><span class="line">	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></span><br><span class="line">&gt;&gt; D=<span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">D=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span></span><br><span class="line">	<span class="number">6</span>	<span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ind2sub</strong> 函数：将矩阵元素的序号转换成下标，格式为 <code>[I,J]=ind2sub(S,D)</code> ，S,D分别为<strong>行数和列数组成的二维向量(可以通过size函数获取)</strong>，<strong>要获取下标的元素的序号(可以是一个向量，标志要获取多个元素的下标)</strong> ，那么前方的 I和J就是对应的行下标和列下标，类似于一个 <strong>sub2ind</strong> 函数的逆用。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; [I,J]=<span class="built_in">ind2sub</span>([<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">I=</span><br><span class="line">	<span class="number">1</span>	<span class="number">3</span>	<span class="number">2</span></span><br><span class="line">J=</span><br><span class="line">	<span class="number">1</span>	<span class="number">1</span>	<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="利用冒号表达式获得子矩阵"><a href="#利用冒号表达式获得子矩阵" class="headerlink" title="利用冒号表达式获得子矩阵"></a>利用冒号表达式获得子矩阵</h3><ul>
<li>我们可以用冒号表达式作为矩阵的行或列下标，也可以用单个<code>:</code>来当行或列下标，这代表取遍全部行或列。<strong>end运算符：</strong> 表示某一维的末尾元素下标。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A(<span class="built_in">i</span>,:)	表示第<span class="built_in">i</span>行的全部元素</span><br><span class="line">A(:,<span class="built_in">j</span>)	表示第<span class="built_in">j</span>行的全部元素</span><br><span class="line">A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,<span class="built_in">j</span>:<span class="built_in">j</span>+m)	表示第<span class="built_in">i</span>~<span class="built_in">i</span>+m行和<span class="built_in">j</span>~<span class="built_in">j</span>+m列全部元素</span><br><span class="line">A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,:)	表示第<span class="built_in">i</span>~<span class="built_in">i</span>+m行全部元素</span><br><span class="line">A(<span class="number">1</span>:<span class="number">3</span>;<span class="number">1</span>:<span class="keyword">end</span>) 这代表取<span class="number">1</span>~<span class="number">3</span>行和<span class="number">1</span>~最后一列元素</span><br></pre></td></tr></table></figure>

<h3 id="利用空矩阵删除矩阵元素"><a href="#利用空矩阵删除矩阵元素" class="headerlink" title="利用空矩阵删除矩阵元素"></a>利用空矩阵删除矩阵元素</h3><ul>
<li>空矩阵就是不含任何元素的矩阵，例如<code>x=[]</code> 就建立了一个空矩阵x。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; C=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">&gt;&gt; C(:,<span class="number">1</span>:<span class="number">2</span>)=[]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">6</span></span><br><span class="line">     <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h3><ul>
<li>通过reshape函数可以在矩阵元素个数不变的情况下改变矩阵形状，例如 <code>reshape(A,m,n)</code> 就是将A矩阵变成m行n列的矩阵，<strong>不改变矩阵元素的存储顺序，也就是依次按列存储，对应序号相同。</strong></li>
</ul>
<h3 id="特殊的约定"><a href="#特殊的约定" class="headerlink" title="特殊的约定"></a>特殊的约定</h3><ul>
<li>通过指令<code>A(:)</code> 可以将所有元素堆叠成一个列向量，不改变存储顺序。</li>
</ul>
<hr>
<h2 id="1-6-MATLAB基本运算"><a href="#1-6-MATLAB基本运算" class="headerlink" title="1.6  MATLAB基本运算"></a>1.6  MATLAB基本运算</h2><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><ol>
<li><p>基本算术运算：<strong>+(加)，-(减)，*(乘)，/(右除)，\(左除)，^(乘方)</strong></p>
<ul>
<li><strong>MATLAB的算数运算在矩阵意义下进行</strong>，单个数据运算是矩阵的特例。</li>
<li><strong>加减运算</strong><ul>
<li>两矩阵同型，对应元素相加减。<strong>不同型，发生错误。</strong></li>
<li><strong>一个标量可以和矩阵进行运算，这时把标量对全体矩阵元素进行操作。</strong></li>
</ul>
</li>
<li><strong>乘法运算</strong><ul>
<li>很明显必须满足矩阵乘的条件，也就是当<code>A*B</code>时必须满足A的行数等于B的列数，此时称A，B矩阵是可乘的，或称两矩阵维数和大小相容。<strong>不相容就会发生错误</strong> </li>
</ul>
</li>
<li><strong>除法运算</strong><ul>
<li>如果A是<strong>非奇异矩阵(A的行列式不为0) *<em>,则B/A等效于B\</em>inv(A)，A\B等效为inv(A)*B。</strong>inv(A)是指A的逆阵** 。</li>
</ul>
</li>
<li><strong>乘法运算</strong><ul>
<li>A矩阵的x次方可以表示成<strong>A^x</strong> ，要求A为<strong>方阵</strong>，x为<strong>标量</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>点运算</strong></p>
<ul>
<li><strong>点运算符</strong>：在相应算术运算符前面加.，有点乘，点右除，点左除，点乘方。</li>
<li><strong>点运算</strong>：两个同型矩阵对应元素进行相关运算。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&gt;&gt; A^<span class="number">2</span>  </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">     <span class="number">7</span>    <span class="number">10</span></span><br><span class="line">    <span class="number">15</span>    <span class="number">22</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A.^<span class="number">2</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">9</span>    <span class="number">16</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul>
<li><strong>关系运算符： &lt; ，&lt;=，&gt;，&gt;=，==(等于)，~=(不等于)</strong> </li>
<li>两个比较量为<strong>标量</strong>，直接比较两个数大小，如果成立表达式值为1，否则为0。</li>
<li>如果两个矩阵是<strong>同型矩阵</strong>，对每两个对应元素进行比较，形成一个由0，1构成的同型矩阵。</li>
<li>如果一个是<strong>标量</strong>一个是<strong>矩阵</strong>，则用标量和每个矩阵元素比较，形成一个同型矩阵。</li>
</ul>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li>逻辑运算符： &amp;(与)，|(或)，~(非)。各自对应的运算法则和C语言类似，不再赘述。</li>
<li>标量，矩阵之间进行运算，对应规则和关系运算类似，不再赘述。</li>
</ul>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>​    算术运算优先级最高，逻辑运算优先级最低，但是逻辑非运算是单目运算符，优先级比双目运算符高。</p>
<hr>
<h2 id="1-7-字符串处理"><a href="#1-7-字符串处理" class="headerlink" title="1.7 字符串处理"></a>1.7 字符串处理</h2><h3 id="字符串的表达"><a href="#字符串的表达" class="headerlink" title="字符串的表达"></a>字符串的表达</h3><ul>
<li>用单引号括起来的字符序列就是字符串，MATLAB把他当成一个行向量。若字符串中含有单引号，则单引号字符要用两个单引号表示。</li>
<li>可以建立多行字符串，建立字符矩阵<strong>（注意每一行的字符串长度要相等）</strong>。和数值矩阵无异。</li>
</ul>
<h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><ul>
<li><p><strong>字符串的执行</strong></p>
<ul>
<li>通过<code>eval(s)</code> 函数可以执行字符串 <strong>s</strong> 对应的命令行命令。</li>
</ul>
</li>
<li><p><strong>字串与数值之间的转换</strong></p>
<ul>
<li><strong>abs</strong> 和 <strong>double</strong> 函数都可以获取字符串矩阵对应的<strong>ASCII码</strong>矩阵。</li>
<li><strong>char</strong> 函数可以把<strong>ASCII码</strong>矩阵转换成字符串矩阵。</li>
</ul>
</li>
<li><p><strong>字符串的比较</strong></p>
<ul>
<li><strong>关系运算符比较</strong>：两个等长字符串比较，两两对应字符比较，成立为1，不成立为0，得到是一个含0，1的行向量。</li>
<li><strong>字符串比较函数比较</strong><ul>
<li>strcmp(s1,s2)：比较s1和s2是否相等，返回值为一个标量，相等为0，不等为1。后缀加i表示比较时忽略大小写。</li>
<li>strncmp(s1,s2,n)：比较s1和s2前n个字符是否相等，返回值为一个标量。相等为0，不等为1。后缀加i表示比较时忽略大小写。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字符串的查找和替换</strong></p>
<ul>
<li>findstr(s1,s2)：返回短字符串在长字符串中的开始位置。如果出现多次，则返回一个行向量。</li>
<li>strrep(s1,s2,s3)：将s1中所有子字符串s2替换为s3。</li>
</ul>
</li>
<li><p><strong>数值转换为字符</strong></p>
<ul>
<li>通过 <strong>num2str</strong> 或 <strong>int2str</strong> 等函数可以将数字转换为字符</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>树形dp例题</title>
    <url>/2020/02/20/%E6%A0%91%E5%BD%A2dp%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    &nbsp;&nbsp;&nbsp;学OI的时候就做过树形dp的题，不过那时候全在划水。看了看题解还不太懂就直接照着题解写了，现在再回来看还是不会QAQ，所以就再看看然后自己写了一遍。</p>
<a id="more"></a>

</br>

<h2 id="A-没有上司的舞会"><a href="#A-没有上司的舞会" class="headerlink" title="A. 没有上司的舞会"></a>A. <a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有 $N$ 个职员被邀请去参加公司的舞会，他们每个人对应着一个快乐指数 $h_i$ ，如果该职员来了就会为舞会增加$h_i$ 点快乐指数。这 $N$ 个职员之间有从属关系，也就是说他们的关系就像一棵以顶级上司为根的树，父结点就是子结点的直接上司。如果一个职员的<strong>直接</strong>上司来到了舞会，那么他本人就不会再来。问邀请哪些职员可获得最大的快乐指数，最大为多少。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;职员之间的关系是以树的形式给出的，所以先用链式前向星来存储数。存的时候我们用vis数组记录一下如何那个人有上司，就将他标记一下，最终没有标记的就是没有上司的，也就是顶级上司，也就是我们的根节点root。<br>​    &nbsp;&nbsp;&nbsp;树形dp，顾名思义，在树上进行dp，通过递归dfs，先算出子树的状态，再通过递归的回溯来合并。那么我们考虑一下设计状态，很明显一个人的状态有来和不来，两个情况。所以我们设计状态 $dp[i][0/1]$  来表示职员 <strong>i</strong> 来或者不来，我们用u来表示当前节点，用v来表示当前节点的子节点，那么状态转移如下：</p>
<ul>
<li><p>$dp[u][0]=max(dp[v][0],dp[v][1]) $ （上司u没有来，那么下属v可以来，也可以不来，选一个大的策略）</p>
</li>
<li><p>$dp[u][1]=dp[v][0]+h[u]$  （上司u来了，下属v肯定不来）</p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;最终的答案就是 $max(dp[root][0],dp[root][1])$ ，上司来和不来两种策略中的最大一种。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6005</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,n,l,k,vis[maxn],root;</span><br><span class="line"><span class="keyword">int</span> r[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].next=head[l];</span><br><span class="line">	e[cnt].to=k;</span><br><span class="line">	head[l]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	dp[u][<span class="number">1</span>]=r[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">		dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">		dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;k);</span><br><span class="line">		add(k,l);</span><br><span class="line">		vis[l]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) root=i;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="B-战略游戏"><a href="#B-战略游戏" class="headerlink" title="B. 战略游戏"></a>B. <a href="https://www.luogu.com.cn/problem/P2016">战略游戏</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;小姜老师要建立一个树，树节点两两之间通过道路连接，他要在这些节点上放一些小人，每个小人可监管与该节点相连的道路，问最少放置多少小人可以监管所有道路。（数据保证0为根节点）</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个题跟上个题有点像，首先我们也是用链式前向星把树给存下来，不过这个题的输入跟上道题有点不一样，本质都是一样的。因为我们只需要dfs下去，然后向上回溯的时候合并，所以只需要存单向边即可。<br>​    &nbsp;&nbsp;&nbsp;对于一个节点我们也是有两种策略，选或者不选，那么我们也可以把状态写成  $dp[i][1/0]$ ，对应着 <strong>i</strong> 这个节点选或者不选，我们把当前节点看作u，子节点看作v，状态转移如下：</p>
<ul>
<li><p>$dp[u][1]+=\Sigma (dp[v][0],dp[v][1]) +1$ （u选了，v选不选都可以，加上自身的1）</p>
</li>
<li><p>$dp[u][0]+=\Sigma dp[v][1]$    （如果u没有选，那么v一定要选，才能监管到u的道路）</p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;很显然这个答案是  $min(dp[0][0],dp[0][1])$  </p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1505</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].next=head[u];</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">		dp[u][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">		dp[u][<span class="number">0</span>]+=dp[v][<span class="number">1</span>];</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;num);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">			add(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">min</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-二叉苹果树"><a href="#C-二叉苹果树" class="headerlink" title="C. 二叉苹果树"></a>C. <a href="https://www.luogu.com.cn/problem/P2015">二叉苹果树</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有一颗二叉苹果树，也就是说树枝如果分叉，一定是分二叉。苹果树有 $n$ 个节点，树根编号为 1 。每个树枝上都有一定数量的苹果，如果最终保留 $q$ 根树枝，问最多能够保留多少苹果。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个树形dp要比上面的还要难一些，因为我们的状态不能够只考虑是否保留当前的树枝了，因为保留当前树枝也会有很多种关于保留子树枝选择。看了题解大佬的说法是，可以定义成 $f[u][j]$ 来表示 u 的子树上保留 j 条边时所能获得最大的苹果数。所以我们考虑一下转移方程，首先我们能保留的最大边数是当前子树所具有的所有树枝，对于一个节点下的两个树枝，我们可以选择取，或者不取，那么这就类似于一个背包问题，对于一定的容量（一定量的树枝），我们取几个树枝才能获得最大的价值。但是我们注意，对于一个节点u，我们如果要取他的节点v，那么我们u-v之间这个树枝一定要保留，不然会不能取得v，这是一个隐藏的条件。<br>​    &nbsp;&nbsp;&nbsp;因此转移方程： $dp[u][i]=max(dp[u][i],dp[u][i-j-1]+dp[v][j]+w[u][v] $ ，$w[u][v]$为当前u-v树枝的苹果数。代码里面因为我懒得计算子树的树枝数了，所以就直接从最大的q来枚举了，就没考虑那么多，可能复杂度稍微高一点，但是高不到哪去其实QAQ…</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt,q;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].next=head[u];</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	e[cnt].w=w;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=q;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[u][j]=<span class="built_in">max</span>(dp[u][j],dp[u][j<span class="number">-1</span>-k]+dp[v][k]+e[i].w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		add(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="number">1</span>][q]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#620 (Div.2)</title>
    <url>/2020/02/19/Codeforces620/</url>
    <content><![CDATA[<h2 id="A-Two-Rabbits"><a href="#A-Two-Rabbits" class="headerlink" title="A. Two Rabbits"></a>A. <a href="https://codeforces.com/contest/1304/problem/A">Two Rabbits</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;两个兔子分别位于 $(x,0)$ 和 $(y,0)$  ，两个人对头蹦，前者往前蹦 $a$ ，后者往前蹦 $b$ ，问两人是否能恰好相遇。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;算一下两个人直接得距离 $s$ ，每次两者距离减少 $a+b$ ，看 $s$ 是否能被 $a+b$ 整除，如果可以就能够相遇。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> x,y,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">int</span> p=a+b;</span><br><span class="line">		<span class="keyword">int</span> f=y-x;</span><br><span class="line">		<span class="keyword">if</span>(f%p==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f/p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="B-Longest-Palindrome"><a href="#B-Longest-Palindrome" class="headerlink" title="B. Longest Palindrome"></a>B. <a href="https://codeforces.com/contest/1304/problem/B">Longest Palindrome</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出 $n$ 段长度为 $m$ 的字符串，从中挑选出一些组成最长的回文字串，输出这个回文子串的长度和内容，如果有多种情况输出一种即可。如果没有符合的，就输出0 。$(1\le n\le 100,1\le m\le 50)$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;因为这个数据规模非常小，所以 $O(n^2m)$ 也是可以接受的（说实话我不是很会算，大概是个差不多的式子），那么我们可以选择暴力匹配，用每个字符串去匹配后面的，如果是两个互为回文串，那么就把其中任何一个计入到sub字符串中，然后用一个 vis 数组来标记他们两个已经被使用过了，最终一个字符串匹配完后面所有的发现没有合适的，那么就考虑他自己是不是一个回文串，如果是一个回文串，单独标记它是放在中间。最后我们的sub是存放了一半回文串。<br>​    &nbsp;&nbsp;&nbsp;统计答案的时候，先将sub加到答案ans中，检查一下是否中间有合适的回文串，如果有的话也加到ans里面，最后讲sub逆序一下，加到ans里面。最终输出答案的时候，看一下ans是不是空串，如果是空串，就输出0，否则输出长度和ans。（string是真的好用！！！）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> ans,sub,mid;</span><br><span class="line"><span class="keyword">bool</span> ifmid;</span><br><span class="line"><span class="built_in">string</span> str[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(str[i][k]==str[j][m-k<span class="number">-1</span>]) </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i]=vis[j]=<span class="literal">true</span>;</span><br><span class="line">				sub+=str[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(str[i][j]!=str[i][m<span class="number">-1</span>-j])</span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				mid=str[i];</span><br><span class="line">				ifmid=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=sub;</span><br><span class="line">	reverse(sub.<span class="built_in">begin</span>(),sub.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span>(ifmid) ans+=mid;</span><br><span class="line">	ans+=sub;</span><br><span class="line">	<span class="keyword">if</span>(!ans.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans.length()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-Air-Conditioner"><a href="#C-Air-Conditioner" class="headerlink" title="C. Air Conditioner"></a>C. <a href="https://codeforces.com/contest/1304/problem/C">Air Conditioner</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;餐厅老板有一个空调，餐厅初始温度为 $m$ ，会陆续来 $n$ 个顾客。餐厅老板每分钟可以控制空调的温度+1，-1，或者是不变。这 $n$ 个顾客会按来的时间顺序给出，每个人有一个感到舒适的温度范围，如果空调的温度在这个范围里面，那么顾客就会满意。问餐厅老板是否可以达到让每个人都满意。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们先思考从餐厅开始到第一个客人来临的时候，假设第一个人来临的时间是 $t$ ，舒适区间为 $[l,r]$，那么我们可以很容易发现只要 $[l,r]$ 与 $[m-t,m+t]$  有交集，那么就是可以满足第一个客人条件。如果第二个和第一人的时间差为 $\Delta t$  ，那么这个时候要计算可达到的舒适区间就是在上次交集的区间上左右变化 $\Delta t$ ，为什么是交集呢。我一开始想错了。。一直写成并集，然后一直调不出来。但实际上不是这样的，我们可以理解为只有交集那部分才是符合上个顾客要求的，如果超出那个范围，就不能够满足上个顾客要求。所以挨个顾客扫一遍就行了。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q,n,m;</span><br><span class="line"><span class="keyword">int</span> last,l,h,t;</span><br><span class="line"><span class="keyword">int</span> nowl,nowr,delt;</span><br><span class="line"><span class="keyword">int</span> lef,righ;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		lef=righ=m;</span><br><span class="line">		last=<span class="number">0</span>;</span><br><span class="line">		flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;l,&amp;h);</span><br><span class="line">			delt=t-last;</span><br><span class="line">			nowl=lef-delt;</span><br><span class="line">			nowr=righ+delt;</span><br><span class="line">			last=t;</span><br><span class="line">			<span class="keyword">if</span>(nowl&gt;h||nowr&lt;l) flag=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				lef=<span class="built_in">max</span>(nowl,l);</span><br><span class="line">				righ=<span class="built_in">min</span>(nowr,h);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>dp练习</title>
    <url>/2020/02/18/dp%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="A-矩阵取数游戏"><a href="#A-矩阵取数游戏" class="headerlink" title="A. 矩阵取数游戏"></a>A. <a href="https://www.luogu.com.cn/problem/P1005">矩阵取数游戏</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个 $n\times m$ 的矩阵，其中每个元素为非负整数。每次你可以从每行的行首或行末取一个元素，得到的分数为当前元素的值 $a_{ij}\times 2^k$  ，$k$ 为当前是第几次取该行上的元素。 问最大得分为多少。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们发现，虽然答案问的是 $n$ 行，但是我们发现，不同行之间是不会相互影响的，我们只需要讨论一行的情况，然后对每行都处理一遍就可以了。<br>​    &nbsp;&nbsp;&nbsp;那么对于一行上的 $m$ 个元素，我们每一次取都有两种选择，一个是取行首，一个是取行尾。我们发现这是一个区间问题，对于区间 $[i,j]$ 的最优情况，我们可以从 $[i+1,j]$  和 $[i,j-1]$ 这两个的最优情况转移过来，因此我们可以定义 $f[i][j]$ 是从第 $i$ 个元素到第 $j$ 的元素得分的最大值，然后从上述两个状态转移过来。<br>​    &nbsp;&nbsp;&nbsp;还有一个问题就是我们的 $2^k$ 问题，我们考虑到大区间的最优值是从小区间转移来，也就是说小区间乘的指数高，大区间乘的指数低，我们又是从小区间推到大区间，转移一次就乘一次，最后肯定是大区间的少，小区间的多了。qwq因为这个题的次数可能很高，会爆long long，实在是不想写高精度，就用了__int128，第一次用，感觉还不错QAQ..</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">85</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">__int128 <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line">__int128 dp[maxn][maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(__int128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&lt;<span class="string">'0'</span>) ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">		ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>) out(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">read</span>(<span class="built_in">map</span>[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">1</span>;f&lt;=m;f++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[f][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=m;len++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+len<span class="number">-1</span>&lt;=m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> k=j+len<span class="number">-1</span>;</span><br><span class="line">				dp[j][k]=<span class="built_in">max</span>(dp[j+<span class="number">1</span>][k]*<span class="number">2</span>+<span class="built_in">map</span>[i][j]*<span class="number">2</span>,dp[j][k<span class="number">-1</span>]*<span class="number">2</span>+<span class="built_in">map</span>[i][k]*<span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=dp[<span class="number">1</span>][m];</span><br><span class="line">	&#125;</span><br><span class="line">	out(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="B-关路灯"><a href="#B-关路灯" class="headerlink" title="B. 关路灯"></a>B. <a href="https://www.luogu.com.cn/problem/P1220">关路灯</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;在一条街道上有 $n$ 个路灯开着，他们可以看作分布在 $x$ 轴上，每个路灯有一定的坐标，也就是代表他们的位置。每个路灯也有一定的功率 $x$ ，代表一秒钟消耗多少电能。姜大佬初始位置在 $c$  ，他每天早晨出来关掉路灯。它可以先关左边的也可以先关右边的，他的行走速率是 $1m/s$ ，问最少消耗多少电能能关掉所有路灯。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;又是一道区间dp的题，那么我们可以思考一下，首先小姜老师肯定不能跳着关路灯，也就是说这个区间内中间的路灯都被关闭了，他会关一个区间的左端点或者右端点，而不会关这个区间外面的。那么我们就可以枚举区间长度来解决这个问题，从小的枚举到大的。<br>​    &nbsp;&nbsp;&nbsp;那么我们思考一下如何定义这个状态。我们可以定义关闭区间 $[i,j]$ 的路灯，最少消耗电能为 $f[i][j]$ ，如果需要转移状态的话，我们想到，对于一个方向，小姜老师可以继续往前走，关掉前面那盏灯，也可以返回去，关闭它屁股后面那盏灯。因为是有两个方向的，所以我们可以拓宽一维，用 $f[i][j][0/1]$ 来表示小姜老师现在是在往左走还是往右走，那么很明显 $f[i][j][0]$ 这个状态可以从 $f[i+1][j][0/1]$  来转移分别对应着小姜老师继续往前走关眼前的，和返回关屁股后的。相应的 $f[i][j][1]$ 就可以从 $f[i][j-1][0/1]$ ，转移的时候再加上消耗的电能即可！</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> lt[maxn]; <span class="comment">//lantern pos</span></span><br><span class="line"><span class="keyword">int</span> en[maxn]; <span class="comment">//energy </span></span><br><span class="line"><span class="keyword">int</span> sum[maxn]; <span class="comment">//prefix sum</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum[n]-(sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++) dp[i][j][k]=inf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;lt[i],&amp;en[i]);</span><br><span class="line">		sum[i]=en[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[c][c][<span class="number">0</span>]=dp[c][c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">			dp[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j][<span class="number">0</span>]+(lt[i+<span class="number">1</span>]-lt[i])*calc(i+<span class="number">1</span>,j),dp[i+<span class="number">1</span>][j][<span class="number">1</span>]+(lt[j]-lt[i])*calc(i+<span class="number">1</span>,j));</span><br><span class="line">			dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+(lt[j]-lt[i])*calc(i,j<span class="number">-1</span>),dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+(lt[j]-lt[j<span class="number">-1</span>])*calc(i,j<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">min</span>(dp[<span class="number">1</span>][n][<span class="number">0</span>],dp[<span class="number">1</span>][n][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-小a和uim之大逃离"><a href="#C-小a和uim之大逃离" class="headerlink" title="C. 小a和uim之大逃离"></a>C. <a href="https://www.luogu.com.cn/problem/P1373">小a和uim之大逃离</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个 $n\times m$ 的矩阵，每个格子中有 $0\sim k$ 滴魔液，小姜老师和它朋友可以从任意地点开始，一起向右或者向下走，他们每个人有一个容量为 $k$ 的瓶子，由小姜老师开始轮流收集地上的魔液，当收集魔液大于 $k$ 的时候，会对 $k+1$ 取模，问他们有多少种方法使得收集的魔液数量相同。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;很显然我们可以写一个5维dp，用 $f[i][j][p][l][0/1]$ 来表示，当到了坐标为 $(i,j)$ 的格子的时候，小姜老师拥有魔液 $p$ 滴，他的朋友拥有魔液 $l$ 滴，并且这一次是由小姜老师采集的/由他的朋友采集的。这样的话，感觉比较好些，但是。。空间占用非常的高，我们优化一下，因为问的是收集相等，所以只需要维护他们的差就可以了，也就是说，只需要将 $(p-l+k)\%k$ 维护一下就可以了，因此循环枚举坐标以及他们的差，从低的向高的转移就可以了。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">805</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][<span class="number">16</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	k++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">			dp[i][j][<span class="built_in">map</span>[i][j]%k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j][t%k][<span class="number">0</span>]+=dp[i<span class="number">-1</span>][j][(t-<span class="built_in">map</span>[i][j]+k)%k][<span class="number">1</span>];dp[i][j][t%k][<span class="number">0</span>]%=mod;</span><br><span class="line">				dp[i][j][t%k][<span class="number">0</span>]+=dp[i][j<span class="number">-1</span>][(t-<span class="built_in">map</span>[i][j]+k)%k][<span class="number">1</span>];dp[i][j][t%k][<span class="number">0</span>]%=mod;</span><br><span class="line">				dp[i][j][t%k][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][j][(t+<span class="built_in">map</span>[i][j])%k][<span class="number">0</span>];dp[i][j][t%k][<span class="number">1</span>]%=mod;</span><br><span class="line">				dp[i][j][t%k][<span class="number">1</span>]+=dp[i][j<span class="number">-1</span>][(t+<span class="built_in">map</span>[i][j])%k][<span class="number">0</span>];dp[i][j][t%k][<span class="number">1</span>]%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=dp[i][j][<span class="number">0</span>][<span class="number">1</span>]%mod;</span><br><span class="line">			ans%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>关于STL的一些总结</title>
    <url>/2020/02/16/STL%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    &nbsp;&nbsp;&nbsp;STL之前只会用 stack 和 queue ，set 和 map 啥的也不太会用。学习一下。</p>
<a id="more"></a>

<hr>
<h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;首先使用之前需要声明头文件 <code>#include&lt;queue&gt;</code> ，通过 <code>queue&lt;typename&gt; q</code> 的形式来进行定义队列，上述为定义了一个队列元素类型为 typename 的队列，队列名称为 q，typename可以为C++原有数据类型，例如int，char，string这些，也可以是自定义的结构体类型等。</p>
<h3 id="主要函数及用途"><a href="#主要函数及用途" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><p>​    &nbsp;&nbsp;&nbsp;使用下述函数都是用类似于 队列名称.函数名()  的形式，好比pop函数就是 q.pop()</p>
<blockquote>
<ol>
<li>push(x)   将元素x从队尾入队</li>
<li>front( ) &amp; back( )    分别为获取队首元素和队尾元素，使用的时候必须确保队列不为空</li>
<li>pop( )  弹出队首元素，使用的时候必须确保队列不为空</li>
<li>empty( )  判断队列是否为空，空返回true，不空返回false</li>
<li>size( ) 查询队列中有多少个元素</li>
</ol>
</blockquote>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.front()); <span class="comment">//</span></span><br><span class="line">	q.push(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.back());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">if</span>(q.empty()) <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"queue is not empty\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">if</span>(q.empty()) <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">queue is not empty</span></span><br><span class="line"><span class="comment">queue is empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
</br>

<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;与队列相对应，是一种先进后出（FILO）的数据结构，限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;首先使用之前需要声明头文件 <code>#include&lt;stack&gt;</code> ，通过 <code>stack&lt;typename&gt; s</code> 的形式来进行定义栈，上述为定义了一个队列元素类型为 typename 的栈，栈名称为 s，typename可以为C++原有数据类型，例如int，char，string这些，也可以是自定义的结构体类型等。</p>
<h3 id="主要函数及用途-1"><a href="#主要函数及用途-1" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><p>​    使用下述函数都是用类似于 栈名称.函数名()  的形式，好比pop函数就是 s.pop()</p>
<blockquote>
<ol>
<li>push(x)  将元素x压栈</li>
<li>pop( )  将栈顶元素出栈，使用时确保栈不为空</li>
<li>top( ) 获取栈顶元素的值，使用时要确保栈不为空</li>
<li>size( ) 返回栈中元素的个数</li>
<li>empty( ) 查询栈是否为空，空返回true，不空返回false</li>
</ol>
</blockquote>
<h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s.push(<span class="number">1</span>);</span><br><span class="line">	s.push(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the top element is %d\n"</span>,s.top()); <span class="comment">//Now the top element is 2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the stack size is %d\n"</span>,s.<span class="built_in">size</span>()); <span class="comment">//Now the stack size is 2</span></span><br><span class="line">	<span class="keyword">if</span>(!s.empty()) s.pop(); <span class="comment">//元素2 弹出栈</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the top element is %d\n"</span>,s.top()); <span class="comment">//Now the top element is 1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the stack size is %d\n"</span>,s.<span class="built_in">size</span>()); <span class="comment">//Now the stack size is 1</span></span><br><span class="line">	<span class="keyword">if</span>(s.empty()) <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>); </span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"stack is not empty\n"</span>); <span class="comment">//stack is not empty</span></span><br><span class="line">	<span class="keyword">if</span>(!s.empty()) s.pop(); <span class="comment">//元素1 弹出栈</span></span><br><span class="line">	<span class="keyword">if</span>(s.empty()) <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>); <span class="comment">//stack is empty</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"stack is not empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">Now the top element is 2</span></span><br><span class="line"><span class="comment">Now the stack size is 2</span></span><br><span class="line"><span class="comment">Now the top element is 1</span></span><br><span class="line"><span class="comment">Now the stack size is 1</span></span><br><span class="line"><span class="comment">stack is not empty</span></span><br><span class="line"><span class="comment">stack is empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
</br>

<h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;map是STL的一个关联容器，提供一对一的数据处理能力，可以建立两个数据之间一一映射关系，map的定义需要关键字和存储值两个参数，我们可以通过关键字来查找对应的存储值（感觉类似于下标可以为任何类型的数组）吧，因为map的底层实现为红黑树（虽然我没学过），所以具有自动排序功能，也就是说map内部有序。</p>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;使用之前声明头文件 <code>#include&lt;map&gt;</code> ，通过 <code>map&lt;typename,typename&gt; m</code>  的形式来定义映射，如果我们要建立string和int这两个类型之间的一一映射，就可以写成 <code>map&lt;string,int&gt; m</code> ，我们可以通过关键字string来查找对应的int值。下述的讲述我们用这个m这个映射来进行。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    &nbsp;&nbsp;&nbsp;迭代器就是类似于指针吧，我们可以通过<code>map&lt;string,int&gt;::iterator it</code> ，来定义一个对应映射的迭代器，他能够用来指向map中的元素，通过它们我们可以对map执行定点删除，遍历等操作。</p>
<h3 id="主要函数及用途-2"><a href="#主要函数及用途-2" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h4><ul>
<li>通过insert函数进行插入<ul>
<li><code>m.insert(pair&lt;string,int&gt;(&quot;zs&quot;,1))</code></li>
<li><code>m.insert(make_pair(&quot;zs&quot;,2))</code></li>
</ul>
</li>
<li>通过类似于数组的形式插入<ul>
<li><code>m[&quot;zs&quot;] = 2</code></li>
</ul>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;上述两种形式有一定的区别，因为集合中元素是唯一的，用insert函数插入的时候，如果已经有相应的关键字，那么就不会插入。而如果用类似于数组的方式进行插入，就会覆盖原关键字对应的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"zs"</span>,<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,m[<span class="string">"zs"</span>]);</span><br><span class="line">	m.insert(make_pair(<span class="string">"zs"</span>,<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,m[<span class="string">"zs"</span>]);</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,m[<span class="string">"zs"</span>]);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果  1 1 2 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-查找数据"><a href="#2-查找数据" class="headerlink" title="2. 查找数据"></a>2. 查找数据</h4><p>​    &nbsp;&nbsp;&nbsp;通过find函数来查找关键字在map中的位置，如果找到了的话就返回对应的迭代器，如果没有找到的话就返回尾部的迭代器（end函数返回的值）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">1</span>;</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果 zs 1 </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h4><ul>
<li>清空map，可以使用clear函数。</li>
<li>删除特定元素<ul>
<li>先用find函数找到特定元素的迭代器，通过erase函数清除。</li>
<li>直接通过相应关键字清除。</li>
</ul>
</li>
<li>删除一串序列，通过erase(起始迭代器，终点迭代器) 来实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">1</span>;</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	m.erase(it);</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	<span class="keyword">if</span>(it==m.<span class="built_in">end</span>())</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Not find zs\n"</span>);</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">2</span>;</span><br><span class="line">	m.erase(<span class="string">"zs"</span>);</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	<span class="keyword">if</span>(it==m.<span class="built_in">end</span>())</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Not find zs"</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果 Not find zs </span></span><br><span class="line"><span class="comment">		    Not find zs</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h4><blockquote>
<ol>
<li>count(“关键字”)  查询相应关键字在map中是否出现过，出现过返回1，没出现返回0</li>
<li>empty( )  判断是否为空，空返回true，不空返回false</li>
<li>begin( ) &amp; end( ) 分别为返回头和尾迭代器，配合迭代器可实行遍历</li>
<li>iterator-&gt;first &amp; iterator-&gt;second 分别对应相应迭代器指向的元素的关键字和值</li>
</ol>
</blockquote>
<hr>
</br>

<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;set为一个容器，用来存储同一数据类型的数据，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一（集合的唯一性），并且内部能根据元素的值自动进行排序。</p>
<h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;使用之前需要声明头文件 <code>#include&lt;set&gt;</code> ，通过 <code>set&lt;typename&gt; s</code> 来定义一个存储数据类型为typename的集合，名字叫做s。下述实例用此做基础。</p>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    &nbsp;&nbsp;&nbsp;通过<code>set&lt;typename&gt;::iterator it</code>，可以来定义一个相应的set的迭代器，用来遍历和指向其中元素。</p>
<h3 id="主要函数及用途-3"><a href="#主要函数及用途-3" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><h4 id="1-插入数据-1"><a href="#1-插入数据-1" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h4><ul>
<li>插入特定元素可以通过 <code>s.insert(3)</code> 插入对应键值，返回值为pair&lt;set<int>::iterator,bool&gt; ，后续bool变量标志是否成功，如果元素3已经存在，那么bool值为false，迭代器对应的是该元素在其中的位置，如果元素不存在其中，返回true，并且返回的迭代器对应的在集合中位置</li>
<li>插入一个区间的元素，例如有整数数组a ，可以用 <code>s.insert(a,a+3)</code> ，可以将a中的 a[0] a[1] a[2] 插入到set中。</li>
</ul>
<h4 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2. 删除数据"></a>2. 删除数据</h4><p>​    &nbsp;&nbsp;&nbsp;删除和map非常像，也是三种。具体可参考map讲解。</p>
<h4 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h4><p>​    &nbsp;&nbsp;&nbsp;也是可以通过find函数，也是和map非常的像~</p>
<h4 id="4-其他-1"><a href="#4-其他-1" class="headerlink" title="4. 其他"></a>4. 其他</h4><blockquote>
<ol>
<li>begin() &amp; end( ) 返回头尾迭代器，注意尾迭代器是尾元素的后一位。</li>
<li>clear( ) 清除set容器中所有元素</li>
<li>empty( ) 判断set容器是否为空，为空则返回true，不空返回false</li>
<li>size( ) 返回当前set容器中元素的个数</li>
<li>rebegin( ) &amp; rend( ) 返回尾和头迭代器，配合reverse_iterator可以反序遍历set</li>
</ol>
</blockquote>
<hr>
<h2 id="关于vector和string等"><a href="#关于vector和string等" class="headerlink" title="关于vector和string等"></a>关于vector和string等</h2><ul>
<li><p>vector好的学习文章 ： <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector容器浅析</a></p>
</li>
<li><p>string好的学习文章  ： <a href="https://www.cnblogs.com/fzxiaoyi/p/12083144.html">C++ STL(一)介绍及string</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题训练</title>
    <url>/2020/02/15/%E6%9D%82%E9%A2%98%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h2 id="A-配对"><a href="#A-配对" class="headerlink" title="A. 配对"></a>A. <a href="https://ac.nowcoder.com/acm/contest/3007/A">配对</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定含有 $n$ 个正整数的集合 $A$ 和 $B$ ，你需要建立他们之间的一一映射。将配对的两个数相加可以得到 $n$ 个和，问第 $k$ 大的和最大为多少。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们可以确定，组成前 $k$ 个最大的和一定用的是两个序列里面前 $k$ 大的数字。那么我们只需要知道如何配对能使第 $k$ 大的和最大。我们把问题简化一下如果 $A_1 &lt; A_2$ ，$B_1 &lt; B_2$  ，那么如果想要第二个和最大，肯定是需要 $A_1$ 和 $B_2$ 匹配，$A_2$ 和 $B_1$  匹配，然后两个选一个最小的。所以这个问题我们类推一下，就是将 $A$ 和 $B$ 序列进行排序，然后取两个里面前 $k$ 个数，$A$ 中大的依次匹配 $B$ 中小的。然后在这 $k$  个和中取一个最小值即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k,ans=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,a[i]+b[k-i+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="B-十字阵列"><a href="#B-十字阵列" class="headerlink" title="B. 十字阵列"></a>B. <a href="https://ac.nowcoder.com/acm/contest/3007/F">十字阵列</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个 $n\times m$ 的网格，每一个交点都一个敌人。你可以使用共 $h$ 次魔法，第 $i$ 次魔法能对第 $x_i$ 行和第 $y_i$  列的所有敌人造成 $w_i$ 点伤害，交界点的伤害只计算一次。。如果施放完所有所有魔法后，如果一个点 $(i,j)$ 共受到 $z_i$ 点伤害，问 $\sum{z_i(i+j)}$ 为多少。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;无脑的计数题QAQ..真的是水题啊，我们只需要给每次魔法施放的 $w_i$ 乘上一个 $(i,j)$ 即可，但是因为是一行一列都会变化，那么其实我们可以优化一下，先把一行一列的 $\sum(i+j)$ 给求出来，然后施法的时候直接乘上这个常数就可以了。（这个题还有个很神奇的地方就是，我明明算的不会爆int然后开的int，然后就错了，后来一直找问题没找出来，后来全改成long long就AC了，太奇怪了。。）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll row[maxn];</span><br><span class="line">ll col[maxn];</span><br><span class="line">ll x,y,z;</span><br><span class="line">ll n,m,h;</span><br><span class="line">ll ans,now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;h);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		row[i]=(m*i)%mod+(m)*(m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		row[i]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		col[j]=(n*j)%mod+(n)*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		col[j]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		now=((row[x]+col[y]-(x+y))%mod)*(z%mod);</span><br><span class="line">		now%=mod;</span><br><span class="line">		ans+=now;</span><br><span class="line">		ans%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-垃圾陷阱"><a href="#C-垃圾陷阱" class="headerlink" title="C. 垃圾陷阱"></a>C. <a href="https://www.luogu.com.cn/problem/P1156">垃圾陷阱</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;奶牛卡门想要从垃圾井底上到地面，对于一个垃圾它可以吃掉，或者是堆起来。初始卡门有10个小时的能量，吃掉一个垃圾会给他提供 $f_i$ 个小时的能量，叠起来一个垃圾会获得 $h_i$ 点高度，当垃圾总高度超过井的深度 $D$ 的时候，卡门就能上到地面。一个垃圾当 $t_i$ 小时时会到达井底。给出所有垃圾的状态，问奶牛能否到达地面。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    <del>&nbsp;&nbsp;&nbsp;这个题面被我翻译的屎一样，QAQ，如果看不懂还是去看原题叭。。</del><br>​    &nbsp;&nbsp;&nbsp;这是一个类似于背包的题，对于一个垃圾，我们有两种选择，一个是吃掉它，一个是把他堆起来。。这个状态其实我没找好，看了题解发现可以设 $f[i][j]$ 来表示当用了前 $i$ 个垃圾时，当高度为 $j$  的时候的最大的体力值（体力值就是还能继续活动多长时间）。我们用结构体数组 $a$ 来表示垃圾，写出如下转移方程。 </p>
<ul>
<li><p>如果选择把这个垃圾吃掉，那么 $f[i][j]=max(f[i-1][j]+a[i].f,f[i][j])$ </p>
</li>
<li><p>如果选择把这个垃圾搭起来，那么$f[i][j+a[i].h]=max(f[i-1][j+a[i].h],f[i-1][j])$ </p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;我们发现边界就是 $f[0][0]=10$ ，也就是用了0个垃圾，高度为0的时候体力值为10。</p>
<p>​    &nbsp;&nbsp;&nbsp;注意一个地方我们如果到达了地面，就直接输出时间，然后退出程序即可，如果没有的话，我们可以选择遍历每一个垃圾下的 $0$ 高度，也就是说所有垃圾都不叠是最长的寿命，所以输出一个其中的最大值即可。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t,f,h;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.t&lt;b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d,g;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn]; <span class="comment">//dp[i][j] 用i个垃圾，当高度为j时所具备的最高生命值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">"test.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;d,&amp;g);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i].t,&amp;a[i].f,&amp;a[i].h); </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+g,cmp);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=d;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]&gt;=a[i].t)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j+a[i].h&gt;=d)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i].t);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j]+a[i].f,dp[i][j]);</span><br><span class="line">				dp[i][j+a[i].h]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j+a[i].h],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++) ans=<span class="built_in">max</span>(ans,dp[i][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#619(Div.2)</title>
    <url>/2020/02/14/Codeforces/</url>
    <content><![CDATA[<h2 id="A-Three-Strings"><a href="#A-Three-Strings" class="headerlink" title="A. Three Strings"></a>A. <a href="https://codeforces.com/contest/1301/problem/A">Three Strings</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定三个长度为 $n$ 的字符串 $a$ , $b$ , $c$ ，遍历每个 $c$ 中每个字符 $c_i$，可以将其替换成 $a_i$ 或者 $b_i$ ，必须操作其中一个，问能否通过此操作使得字符串 $a$ , $b$ 相同。 </p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;仔细思考一下，如果要使得最终两个字符串相同的话，必须字符串 $c$ 中出现的字符，在 $a$ 或者 $b$ 字符串出现过，如果每个位置都出现过，那么就是可以的，否则不行。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(c);</span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="keyword">if</span>(c[i]!=a[i]&amp;&amp;c[i]!=b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="B-Motarack’s-Birthday"><a href="#B-Motarack’s-Birthday" class="headerlink" title="B. Motarack’s Birthday"></a>B. <a href="https://codeforces.com/contest/1301/problem/B">Motarack’s Birthday</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个含有 $n$ 个整数的序列 $a$ ，其中有一些数丢失，问将丢失的数赋值为多少才能使得相邻两数之差的绝对值的最大值的最小。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;我们想一下首先不缺失的数相邻两数之差是一定，无论赋值前后都不影响。而如果两个相邻的数都缺失的话，那么他们之间差的绝对值一定是0，也不用去看。这样的话我们就看一下，不缺失和缺失两数之间差的绝对值如何能够最小。因为最终所有的缺失的数都是赋值为同一个数，所以我们考虑一下发现需要考虑一下 缺失和不缺失的数相邻的时候，不缺失的那个数的最大值和最小值，我们只需要取他们的和的平均，那么绝对值就可以最小了。所以最终我们就把缺失的值赋为两数均值，然后求一遍相邻数之差绝对值的最大值就好了。（好像这道题难点不是思路，而是实现起来有很多边界等乱七八糟的要自习考虑一下。）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> minn,maxx,ans,anss;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		minn=inf,maxx=-inf,anss=-inf;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;a[i]==<span class="number">-1</span>&amp;&amp;a[i<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				minn=<span class="built_in">min</span>(minn,a[i<span class="number">-1</span>]);</span><br><span class="line">				maxx=<span class="built_in">max</span>(maxx,a[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;n&amp;&amp;a[i]==<span class="number">-1</span>&amp;&amp;a[i+<span class="number">1</span>]!=<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					minn=<span class="built_in">min</span>(minn,a[i+<span class="number">1</span>]);</span><br><span class="line">					maxx=<span class="built_in">max</span>(maxx,a[i+<span class="number">1</span>]);</span><br><span class="line">				&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		ans=(minn+maxx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==<span class="number">-1</span>) a[i]=ans;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>) anss=<span class="built_in">max</span>(anss,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,anss,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-Ayoub’s-function"><a href="#C-Ayoub’s-function" class="headerlink" title="C. Ayoub’s function"></a>C. <a href="https://codeforces.com/contest/1301/problem/C">Ayoub’s function</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个01字符串 $s$ ，其中含有 $m$ 个1，用 $f(s)$ 来表示字符串 $s$ 的有多少个字串其中含有1，求出符合条件的字符串 $s$ 中， $f(s)$ 的最大值是多少。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这题正着想不太好想，含有1的子串可以有很多种情况，但是正难则反，我们可以求出不含1的字串有多少情况，也就是全0的字串有多少种情况，然后用所有情况减去这个就行。<br>​    &nbsp;&nbsp;&nbsp;首先可以发现字符串 $s$ 一共有  $\binom{n}{2}+n$  种连续子串，那么如果一些0是连续的，那么好比有连续 $l$ 个0的话，我们可以发现他是有  $\binom{l}{2}+l$  种情况的。这个字符串一共是含有 $n-m$ 个0的，现在我们思考一下如何摆放这 $(n-m)$ 个0，才能使得  $f(s)$ 最大。那么如果 $f(s)$ 要尽量大，也就是说全0对应的情况就要尽可能的少，所以我们需要将这 $n-m$ 尽可能的均分成 $m+1$  份，类似于排列组合的插空法，将他们插到其中，但是我们发现有很大的可能是不能均分的，也就是说可能会有余数，那么我们就把余数均匀的分给前面余数个空，这样其实每个多贡献了 $(n-m)/(m+1) +1 $ 个。所以答案也就不难写出来了。不过不要忘了开long long。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n,m;</span><br><span class="line">ll t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">		ll sum=n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		ll p=n-m;</span><br><span class="line">		ll mod=p%(m+<span class="number">1</span>);</span><br><span class="line">		ll k=p/(m+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum-(m+<span class="number">1</span>)*k*(k+<span class="number">1</span>)/<span class="number">2</span>-(k+<span class="number">1</span>)*mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>日常水题</title>
    <url>/2020/02/13/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    &nbsp;&nbsp;&nbsp;今天又是颓废的一天，被大佬拉去跟他一起做牛客网的题，QAQ…那我会点啥嘛，就只能替大佬写两道水题了···</p>
<a id="more"></a> 

</br>

<h2 id="A-牛牛战队的比赛地"><a href="#A-牛牛战队的比赛地" class="headerlink" title="A. 牛牛战队的比赛地"></a>A. <a href="https://ac.nowcoder.com/acm/contest/3006">牛牛战队的比赛地</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标 $(x,y)$ 。<br>​    &nbsp;&nbsp;&nbsp;这周末，牛牛队又要出去比赛了，各个比赛的赛点都在 $x$ 轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。请你求出选择的比赛地距离各训练基地最大距离的最小值。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个题首先一看到这种什么最大的最小，第一直觉就是二分。首先我们想一下应该二分什么，肯定先想的是枚举 $x$ 轴上的点，但是这样就会有个问题，二分要用的话必须是单调的，那么我们不能够确定越往右或者越往左，他们的这个值是单调的。因此我们可以用三分，一直向单峰逼近，最终寻找到那个极值点。（说实话这是我第一次接触到三分法，我太菜了。）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;p[maxn]; <span class="comment">//point</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">double</span> lmid,rmid,lans,rans;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> dis=(p[i].x-x)*(p[i].x-x)+p[i].y*p[i].y;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,dis);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> l=<span class="number">-10000</span>,r=<span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">9999999999</span>;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;=eps)</span><br><span class="line">	&#123;</span><br><span class="line">		lmid=(r+l)/<span class="number">2</span>;</span><br><span class="line">		rmid=(r+lmid)/<span class="number">2</span>;</span><br><span class="line">		lans=check(lmid);</span><br><span class="line">		rans=check(rmid);</span><br><span class="line">		<span class="keyword">if</span>(lans&lt;rans)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,lans);</span><br><span class="line">			r=rmid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,rans);</span><br><span class="line">			l=lmid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf"</span>,<span class="built_in">sqrt</span>(ans));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="B-牛牛与牛妹的约会"><a href="#B-牛牛与牛妹的约会" class="headerlink" title="B. 牛牛与牛妹的约会"></a>B. <a href="https://ac.nowcoder.com/acm/contest/3006/D">牛牛与牛妹的约会</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;你想从 $(a,0)$ 点到 $(b,0)$ 点，你可以除了可以以 $1m/s$ 的速度奔跑，还可以用1秒的时间来引导闪现，这将使你从 $(x,0)$ 点闪现到 $(\sqrt[3]{x},0)$ 点，问最少需要多长时间到达 $(b,0)$ 点。$(Ps:a,b \in[-10^6,10^6])$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;一道贪心的题目，当闪现所能贡献的距离大于 $1m$ ，那么我就选择用闪现，不然就直接奔跑。那么我们可以用距离的变化来体现闪现贡献的距离，一直用闪现到不能用之后，就直接加上最后剩下的距离即可。注意pow这个函数有点坑？如果底数是负数并且指数不是整数的话好像会返回很奇怪的值···（跟大佬调了好长时间都卡在这了）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,x,y;</span><br><span class="line"><span class="keyword">double</span> ans,a,b;</span><br><span class="line"><span class="keyword">double</span> dis,cdis;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		a =(<span class="keyword">double</span>)x;</span><br><span class="line">		b=(<span class="keyword">double</span>)y;</span><br><span class="line">		dis = <span class="built_in">abs</span>(a-b);</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cdis=<span class="built_in">abs</span>(-<span class="built_in">pow</span>(-a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cdis = <span class="built_in">abs</span>(<span class="built_in">pow</span>(a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(dis-cdis&gt;<span class="number">1.0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a=-<span class="built_in">pow</span>(-a,<span class="number">1.0</span>/<span class="number">3.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> a=<span class="built_in">pow</span>(a,<span class="number">1.0</span>/<span class="number">3.0</span>);</span><br><span class="line">			ans+=<span class="number">1</span>;</span><br><span class="line">			dis = cdis;</span><br><span class="line">			<span class="keyword">if</span>(a&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cdis = <span class="built_in">abs</span>(-<span class="built_in">pow</span>(-a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> cdis = <span class="built_in">abs</span>(<span class="built_in">pow</span>(a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=dis;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-碎碎念"><a href="#C-碎碎念" class="headerlink" title="C. 碎碎念"></a>C. <a href="https://ac.nowcoder.com/acm/contest/3006/F">碎碎念</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;大佬豪和弱鸡战合作做题，如果大佬豪AC掉题目，那么弱鸡战会说 “宁好强啊！”，如果大佬豪WA掉了题目，那么弱鸡战会嘲讽大佬豪 $k$ 句 “宁好弱啊！” 。我们规定大佬豪提交只有AC和WA两种状态。因为大佬豪非常的强，如果一道题他WA掉了一发，那么他的下一发一定会AC。如果已知最终弱鸡战嘲讽了 $x$ 句，那么很明显可以对应很多的提交序列。现在想问你如果弱鸡战嘲讽数在 $[l,r]$ 这个区间，一共会有多少种提交序列。答案对 $1e9+7$ 取模。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先原始题面不是这样，我把名字改了一下，QAQ…<br>​    &nbsp;&nbsp;&nbsp;QAQ刷了这么多天的dp好像终于有点作用了，我终于看出来这是一道dp题了，还找对了他们的状态，不过转移方程却写错了。那么首先我们可以用 $f[i]$ 来表示，如果说了 $i$ 句话，那么一共有多少种可能的序列，但是这样的话我们发现没法确保上文上的如果WA掉了，下一发一定是AC。<br>​    &nbsp;&nbsp;&nbsp;所以我们可以考虑加一维状态来表示是通过哪种提交状态到达第 $i$ 句话的，也就是写成 $dp[0/1][i]$ 这个状态，$dp[0][i]$ 代表是从 $i-1$ 句话直接AC转移过来的，$dp[1][i]$ 是从 $i-k$ 句话通过WA转移过来的。所以这样的话转移方程就可以写出来了。</p>
<ul>
<li><p>$dp[0][i] = dp[0][i-1]+dp[1][i-1]$  （可以从WA和AC转移过来）</p>
</li>
<li><p>$dp[1][i]=dp[0][i-k]$ （只能从第 $i-k$ 状态是AC的时候转移，不能连续两次WA） </p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;因为最终是一个区间查询，那么我们可以用前缀和来优化。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> k,q;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;q);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+dp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">		dp[<span class="number">0</span>][i]%=mod;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">1</span>][i]=dp[<span class="number">0</span>][i-k];</span><br><span class="line">			dp[<span class="number">1</span>][i]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i]=dp[<span class="number">0</span>][i]+dp[<span class="number">1</span>][i];</span><br><span class="line">		ans[i]%=mod; </span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+ans[i];</span><br><span class="line">		sum[i]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(sum[r]-sum[l<span class="number">-1</span>]+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="D-牛牛战队的秀场"><a href="#D-牛牛战队的秀场" class="headerlink" title="D. 牛牛战队的秀场"></a>D. <a href="https://ac.nowcoder.com/acm/contest/3006/J">牛牛战队的秀场</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;在半径为 $r$ 的圆内有一个正接 $n$ 边形，随便选取一个顶点编号为 $1$ ，顺时针编号为 $2\sim n$ ，规定只能沿多边形边走，问从顶点 $i$ 到顶点 $j$ 最短路径为多少。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;很显然只有两条路可以走，我们只需要算出正多边形的每条边的边长，然后比较两条路径的大小，哪一个短就走哪一个就行，不过如果用了<code>cos()</code> 函数记得特判一下 $n=4$ 的情况，不然会发生错误。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ri;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.1415926535898</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;ri);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);</span><br><span class="line">	<span class="keyword">double</span> k=(<span class="keyword">double</span>)<span class="number">2</span>*pi/(<span class="keyword">double</span>)n;</span><br><span class="line">	<span class="keyword">double</span> s;</span><br><span class="line">	r=(<span class="keyword">double</span>)ri;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=<span class="built_in">sqrt</span>(<span class="number">2</span>*r*r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> s=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)<span class="number">2</span>*r*r<span class="number">-2.0</span>*r*r*<span class="built_in">cos</span>(k));</span><br><span class="line">	<span class="keyword">int</span> p=<span class="built_in">abs</span>(i-j);</span><br><span class="line">	<span class="keyword">if</span>(p&gt;n/<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lf"</span>,s*(n-p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lf"</span>,s*p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>dp习题练习</title>
    <url>/2020/02/12/dp%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="A-方格取数"><a href="#A-方格取数" class="headerlink" title="A. 方格取数"></a>A. <a href="https://www.luogu.com.cn/problem/P1004">方格取数</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有一个 $N*N$ 的整数方阵，每个点初始值为0，在一些点上放上数，一个人从左上角走到右下角，规定只能向下或向右走，当他经过的点上有数时会取走它，问走两遍最多能取的数的和最大为多少。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;也就是说我们要找两条路径使他取数最大，首先我一开始想法是先走一遍，找到最大的那个路径，将这条路径上所有点设为0，然后再回来找这个方阵中最大的那个路径，两个加起来就行。但是路径上所有的点设为0这个地方不是很好实现，因此我们可以考虑另一个思路，两次同时走。我们把这两次看成两个人走的，表述方便。<br>​    &nbsp;&nbsp;&nbsp;我们用 $dp[i][j][k][l]$ 来表示当第一个人走到 $(i,j)$  第二个人走到 $(k,l)$ 时做能取数最多为多少 ，那么我们就可以考虑一下转移怎么转移，因为到达一个点只能是从左边来，或者是从上边来，因此第一个人从 $(i-1,j)$ 或者 $(i,j-1)$ 转移来，那么第二个人就从 $(k-1,l)$ 或者 $(k,l-1)$ 转移来，那么这个转移方程就是四种转移方式。我们需要保证一个问题，就是他俩经过同一个点的判定情况。我们需要将第二个人的坐标通过第一个人来限制，也就是说要确保第二个人和第一个人步数是相同的，当他们步数相同的时候，那么就不存在他们经过同一个点但是时间却是不同的情况了，因为到达一个点的步数是一定的。<br>​    &nbsp;&nbsp;&nbsp;再就是这个状态数组其实还是可以压缩到三维和二维的，这个就先不谈了，可以看洛谷的题解区。<br>​    &nbsp;&nbsp;&nbsp;这个题是一个经典的多维dp的题目，感觉还是挺有意义的。而且这个题和 <a href="https://www.luogu.com.cn/problem/P1006">传纸条</a> 很像，可以双倍经验。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,x,y,z;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">map</span>[x][y]=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				m=i+j-k;</span><br><span class="line">				<span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(i==k&amp;&amp;j==m) dp[i][j][k][m]=<span class="built_in">max</span>(<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][m],dp[i<span class="number">-1</span>][j][k][m<span class="number">-1</span>]),<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][m],dp[i][j<span class="number">-1</span>][k][m<span class="number">-1</span>]))+<span class="built_in">map</span>[i][j];</span><br><span class="line">				<span class="keyword">else</span> dp[i][j][k][m]=<span class="built_in">max</span>(<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][m],dp[i<span class="number">-1</span>][j][k][m<span class="number">-1</span>]),<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][m],dp[i][j<span class="number">-1</span>][k][m<span class="number">-1</span>]))+<span class="built_in">map</span>[i][j]+<span class="built_in">map</span>[k][m];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[n][n][n][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br> 

<h2 id="B-创意吃鱼法"><a href="#B-创意吃鱼法" class="headerlink" title="B. 创意吃鱼法"></a>B. <a href="https://www.luogu.com.cn/problem/P1736">创意吃鱼法</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出一个 $N*M$ 的只包含0和1的数阵，求只有对角线为1，其余位置为0的子方阵的最大边长。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个题我们需要考虑两个方向，这个对角线既可以是斜向左上，也可以是斜向右上的。我们先考虑前者，后者同理即可。我们可以用两个数组 $col[i][j]$ 和 $row[i][j]$ 分别来表示，包含 $(i,j)$ 这个点往上一列有多少个0，以及包含这个点往左一行有多少个0，（这个在程序里好像我写反了，但是没啥区别说实话）。然后我们用 $f[i][j]$ 来表示，从这个点左上走满足条件的方阵的最大边长。那么很显然这个值和上方的0，左方的0，以及左上的状态有关，这个点是1的话，转移方程就是 $f[i][j]=min(f[i-1][j-1],min(col[i-1][j],row[i][j-1]))+1$ 。如果是0的话我们就更新 $col$ 和 $row$ 数组的值。然后求完斜向左上的再求一遍斜向右上的，取一个最大值即可。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2505</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> col[maxn][maxn],row[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">map</span>[i][j])</span><br><span class="line">		&#123;</span><br><span class="line">			row[i][j]=row[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">			col[i][j]=col[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">min</span>(row[i<span class="number">-1</span>][j],col[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">			ans=<span class="built_in">max</span>(dp[i][j],ans);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(row,<span class="number">0</span>,<span class="keyword">sizeof</span>(row));</span><br><span class="line">	<span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">map</span>[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">				row[i][j]=row[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				col[i][j]=col[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>],<span class="built_in">min</span>(row[i<span class="number">-1</span>][j],col[i][j+<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">				ans=<span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="C-乌龟棋"><a href="#C-乌龟棋" class="headerlink" title="C. 乌龟棋"></a>C. <a href="https://www.luogu.com.cn/problem/P1541">乌龟棋</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出标号分别为1，2，3，4的四种卡片若干张，分别可以移动1，2，3，4步，玩家初始处于坐标为1的位置。玩家出一张牌，可移动相应的步数。移动到不同的坐标会加不同的分数，很明显不同的出牌顺序会对应着不同的分数，求玩家能获得的最大分数为多少。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;很显然我们可以通过已经出的牌计算出现在已经到达到哪个位置。我们可以用一个四重循环，来循环每张牌用的数量，很明显我们到达一个目标位置所用的最后一张牌可以是1，2，3，4的任何一个，因此我们可以从这个四个状态转移过来，找其中最大那个就可以了，注意要判断一下要转移过来的状态是否合法。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">355</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">125</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,pos;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> x,num[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">42</span>][<span class="number">42</span>][<span class="number">42</span>][<span class="number">42</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		num[x]++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=w[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=num[<span class="number">1</span>];a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;=num[<span class="number">2</span>];b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=num[<span class="number">3</span>];c++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=num[<span class="number">4</span>];d++)</span><br><span class="line">				&#123;</span><br><span class="line">					pos=<span class="number">1</span>+a+(b&lt;&lt;<span class="number">1</span>)+c*<span class="number">3</span>+(d&lt;&lt;<span class="number">2</span>);</span><br><span class="line">					<span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;dp[a<span class="number">-1</span>][b][c][d]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a<span class="number">-1</span>][b][c][d]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(b&gt;<span class="number">0</span>&amp;&amp;dp[a][b<span class="number">-1</span>][c][d]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b<span class="number">-1</span>][c][d]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(c&gt;<span class="number">0</span>&amp;&amp;dp[a][b][c<span class="number">-1</span>][d]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c<span class="number">-1</span>][d]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(d&gt;<span class="number">0</span>&amp;&amp;dp[a][b][c][d<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c][d<span class="number">-1</span>]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[num[<span class="number">1</span>]][num[<span class="number">2</span>]][num[<span class="number">3</span>]][num[<span class="number">4</span>]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</br>

<h2 id="D-能量项链"><a href="#D-能量项链" class="headerlink" title="D. 能量项链"></a>D. <a href="https://www.luogu.com.cn/problem/P1063">能量项链</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出一段含有 $n$ 个珠子的环状项链，对于相邻的两个珠子，前一颗珠子的尾标记等于后方珠子的头标记。<br>​    &nbsp;&nbsp;&nbsp;例如项链为 $[2,4,6,8]$ ， 那么用加入标记表示就是 $[(2,4),(4,6),(6,8),(8,2)]$  。当两个珠子两两合并的时候会产生的能量大小为 前方珠子头标记 $\times$ 前方珠子尾标记 $\times$ 后方珠子尾标记。显然合并的顺序不同最终会产生不同的能量值，问能产生的最大能量值为多少。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这道题和合并石子很像，也是一个区间dp的例题，我们也是通过枚举区间长度，然后枚举区间断点来分割区间。这个题也是一个环状，我们也是断环为链，不过处理释放的能量值的问题，我是用了一个结构体，来表示每一颗珠子的标记，通过这个来计算释放能量。不过记得处理子区间也要从处理到 $1\sim 2n$， 这个地方卡了我巨长时间，因为你后面要用到这个状态，如果不计算子区间无法转移到后面。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll dp[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll w;</span><br><span class="line">	ll nxt;</span><br><span class="line">&#125;a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i].w);</span><br><span class="line">		a[i+n].w=a[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span><span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i].nxt=a[i+<span class="number">1</span>].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) dp[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-p+<span class="number">1</span>;i++) <span class="comment">//重要(卡我巨长时间)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+a[i].w*a[k].nxt*a[j].nxt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		printf("%d ",dp[i][i+1]);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列和单调栈总结</title>
    <url>/2020/02/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%92%8C%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​     &nbsp; &nbsp; &nbsp; 最近感觉遇到了好多单调队列和单调栈的问题，但是因为以前没学好，所以遇见了就一脸懵逼，然后绝对下决心来学一下。。感觉遇到啥都不会，这可咋办呐。。补不完的漏洞。</p>
<a id="more"></a>

<hr>
<h1 id="单调队列-Monotone-queue"><a href="#单调队列-Monotone-queue" class="headerlink" title="单调队列(Monotone queue)"></a>单调队列(Monotone queue)</h1><p>​    &nbsp; &nbsp; &nbsp; 单调队列，即单调递减或单调递增的队列。使用频率不高，但在有些程序中会有非同寻常的作用。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>​    &nbsp; &nbsp; &nbsp; 顾名思义，他就是一个单调的队列，那么我们可以规定他是单调递增的还是单调递减的，他和普通的队列有点区别，队列一般是尾进头出，而单调队列要实现的话要确保头和尾都可以出，尾可以进。如果要用STL库的话可以用里面的双端队列。<br>​    &nbsp; &nbsp; &nbsp; 跟普通队列相比他的进队需要确保一个条件就是要<strong>不破坏原有序列的单调性</strong>，好比我们有一个单调递增的单调队列，也就是从队首到队尾是单调递增的，那么有一段序列是 $[2,3,1,5,8,7,4,2]$ ，我们从左到右依次入队。</p>
<table>
<thead>
<tr>
<th>队列中元素</th>
<th>关于元素进出的备注</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>2入队</td>
</tr>
<tr>
<td>2，3</td>
<td>3比2大，可以满足递增性质，入队</td>
</tr>
<tr>
<td>1</td>
<td>因为1比2，3都小，要满足递增性质，先把2，3出队，再将1入队</td>
</tr>
<tr>
<td>1，5</td>
<td>5比1大，可以满足递增性质，入队</td>
</tr>
<tr>
<td>1，5，8</td>
<td>8比5大，可以满足递增性质，入队</td>
</tr>
<tr>
<td>1，5，7</td>
<td>7小于8，大于5，要满足递增性质，我们把8出队，然后将7入队</td>
</tr>
<tr>
<td>1，4</td>
<td>4小于5、7，但是大于1，因此7，5依次出队，4入队</td>
</tr>
<tr>
<td>1，2</td>
<td>2小于4，大于1，因此4出队，2入队</td>
</tr>
</tbody></table>
<p>​    &nbsp; &nbsp; &nbsp; 根据上述例子不难看出，我们要入队的时候首先要确保队尾元素要比想要入队的元素小，然后才能入队，否则的话就一直循环让尾部元素出队，直到能够满足单调性为止。</p>
<h2 id="单调队列的应用"><a href="#单调队列的应用" class="headerlink" title="单调队列的应用"></a>单调队列的应用</h2><ul>
<li>求区间的最值问题。下面写的两个例题都是这个用处。</li>
<li>优化dp，我现在能接触到的就是一个用单调队列优化多重背包的一个题，但是那个题我学了这个东西之后还是不理解为什么可以那么做。例题如下：<a href="https://www.luogu.com.cn/problem/P1776">宝物筛选</a></li>
</ul>
<h2 id="单调队列的一些例题"><a href="#单调队列的一些例题" class="headerlink" title="单调队列的一些例题"></a>单调队列的一些例题</h2><h3 id="A-Sliding-Window"><a href="#A-Sliding-Window" class="headerlink" title="A. Sliding Window"></a>A. <a href="http://poj.org/problem?id=2823">Sliding Window</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出一个含有 $n$ 个整数的序列 $a$ ，给出滑动窗口长度 $k$ ，窗口从序列最左端滑动到序列最右端，问滑动过程中每个时刻窗口中最大值和最小值是多少。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 一道很经典的单调队列的模板题，用于解决定长区间的最大最小值。我们可以维护两个单调队列，一个是单调递增的，一个是单调递减的。因为两种情况类似，我们考虑一下求窗口中最大值的方案。</p>
<p>​    &nbsp; &nbsp; &nbsp; 求最大值我们用的是单调递减的序列，这样就能够保证每次队首的就是答案，但是，这是为什么呢？我们来考虑一下，因为这是一个单调递减的序列，那么我们每次序列元素入队的时候，我们就去看当前队尾的元素是不是要比他大，如果比他还小，那么我们就直接将队尾元素出队，因为这时候要入队的元素（已经被窗口覆盖了）已经比他大了，那么在接下来的窗口中，肯定就没他什么事了，因为它一定不是最大的，那么如果一直将队尾元素出队到加入入队元素后还继续能保持队列的单调性了，但是这个元素还不是在队首，这就说明，队首的元素还是要比他大的（单调性易得）。</p>
<p>​    &nbsp; &nbsp; &nbsp; 所以这时候队首元素就是这个窗口中最大的了吗？也还不能确定，因为我们还不能确保这个队首元素就在窗口中，因此我们需要看看这个元素的位置和当前入队元素的位置之差是不是要比窗口长度大了，如果大于窗口长度，那么就说明队首元素已经不在窗口了，我们就将队首元素出队，最后输出队首元素就能确保它既在窗口中，又是窗口中所有元素的最大值了！</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> head,tail,a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos,value;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head=tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;i-q[head].pos&gt;=k) head++;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;a[i]&lt;=q[tail<span class="number">-1</span>].value) tail--;</span><br><span class="line">		q[tail].value=a[i],q[tail++].pos=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">printf</span>(<span class="string">"%d "</span>,q[head].value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q[i].value=q[i].pos=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head=tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;i-q[head].pos&gt;=k) head++;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;a[i]&gt;=q[tail<span class="number">-1</span>].value) tail--;</span><br><span class="line">		q[tail].value=a[i],q[tail++].pos=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">printf</span>(<span class="string">"%d "</span>,q[head].value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	getmax();</span><br><span class="line">	getmin();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B-Max-Sum-of-Max-K-sub-sequence"><a href="#B-Max-Sum-of-Max-K-sub-sequence" class="headerlink" title="B. Max Sum of Max-K-sub-sequence"></a>B. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3415">Max Sum of Max-K-sub-sequence</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给定长度为 $n$ 的整数循环序列 $a$ ，也就是$a[1],a[2],\cdots,a[n],a[1]\cdots$ 这样的序列，问最大连续长度为 $k$ 的连续子区间的序列和最大为多少，并且输出这个区间的左右坐标。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 我们把这道题转换一下，我们先处理好前缀和，好比我们要求 $a[1],a[2],a[3]$ 的序列和，那么也就是 $sum[3]-sum[0]$ ，因此我们在求这个题的时候就可以循环遍历 $1\sim{n-k+1}$ ，求长度为 $k$ 的定长区间中前缀和数组的最小值即可。但是我们要注意前缀和数组要处理到 $n-k+1$ 。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n,k,a[maxn],sum[maxn];</span><br><span class="line"><span class="keyword">int</span> head,tail;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos,value;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="keyword">int</span> ans,l,r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		l=r=<span class="number">0</span>;</span><br><span class="line">		head=tail=<span class="number">0</span>;</span><br><span class="line">		ans=-inf;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum[i]=sum[i<span class="number">-1</span>]+a[i-n];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(head!=tail&amp;&amp;i-q[head].pos&gt;k) head++;</span><br><span class="line">			<span class="keyword">while</span>(head!=tail&amp;&amp;sum[i<span class="number">-1</span>]&lt;=q[tail<span class="number">-1</span>].value) tail--;</span><br><span class="line">			q[tail].pos=i<span class="number">-1</span>,q[tail++].value=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//			if(i!=q[head].pos)</span></span><br><span class="line"><span class="comment">//			&#123; </span></span><br><span class="line">				<span class="keyword">int</span> p=sum[i]-q[head].value;</span><br><span class="line">				<span class="keyword">if</span>(p&gt;ans)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=p;</span><br><span class="line">					<span class="keyword">int</span> k=q[head].pos+<span class="number">1</span>;</span><br><span class="line">					k&gt;n?l=k%n:l=k;</span><br><span class="line">					i&gt;n?r=i%n:r=i;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,ans,l,r);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++) q[i].pos=q[i].value=-inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单调栈-Monotone-stack"><a href="#单调栈-Monotone-stack" class="headerlink" title="单调栈(Monotone stack)"></a>单调栈(Monotone stack)</h1><p>​    &nbsp; &nbsp; &nbsp; 单调增或单调减的栈，跟单调队列差不多，但是只用到它的一端。</p>
<h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>​    &nbsp; &nbsp; &nbsp; 单调栈也是在普通栈的基础上加了单调性，一般是用从栈底到栈顶的单调性来命名，好比从栈底到栈顶是单调递增的，那么他就是单调增的栈。跟单调队列一样，他的入栈规则也是<strong>要不破坏单调性</strong>，因此一个单调递增的栈如果有元素要入栈，如果他比栈顶的元素还要大，就可以直接入栈，如果他比栈顶的元素小，那么就要将栈顶的元素一直出栈到比要入栈元素小为止。如果序列为 $[2,3,1,5,4,7]$，要加入单调递增栈中，过程如下。<strong>PS：注意从左到右对应栈底到栈顶。</strong></p>
<table>
<thead>
<tr>
<th>栈中的元素</th>
<th>关于元素进出的备注</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>元素2压入栈中</td>
</tr>
<tr>
<td>2，3</td>
<td>3大于2，压入栈中</td>
</tr>
<tr>
<td>1</td>
<td>1小于3、2，因此全部弹出将1入栈</td>
</tr>
<tr>
<td>1，5</td>
<td>5大于1，压入栈中</td>
</tr>
<tr>
<td>1，4</td>
<td>4比5小，比1大，弹出5，压入4</td>
</tr>
<tr>
<td>1，4，7</td>
<td>7大于4，压入栈中</td>
</tr>
</tbody></table>
<p>​    &nbsp; &nbsp; &nbsp; 根据上述描述不难看出，其实单调栈就是单调队列的半部分，他能完成的任务理论上单调队列都能够完成，但是有些时候不需要麻烦的去维护单调队列只需要维护单调栈即可完成。</p>
<h2 id="单调栈的应用"><a href="#单调栈的应用" class="headerlink" title="单调栈的应用"></a>单调栈的应用</h2><ul>
<li>确定一个元素的左边区间第一个比它大的元素，第一个比它小的元素</li>
<li>确定右边区间第一个比他大or比他小的元素（根据单调性来看）</li>
<li>确定这个元素是否是一定区间内的最值，或者确定以他为最值的区间长度</li>
</ul>
<h2 id="单调栈的一些例题"><a href="#单调栈的一些例题" class="headerlink" title="单调栈的一些例题"></a>单调栈的一些例题</h2><h3 id="A-单调栈模板"><a href="#A-单调栈模板" class="headerlink" title="A. 单调栈模板"></a>A. <a href="https://www.luogu.com.cn/problem/P5788">单调栈模板</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出含有 $n$ 个整数的序列 $a$ ，定义 $f(i)$ 为第 $i$ 个元素后第一个大于 $a_i$ 的下标，求 $f(1)\cdots f(n)$ </p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 直接就是模板，对应了上述应用里的第二个。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> top,ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;a[i]&gt;a[<span class="built_in">stack</span>[top]])</span><br><span class="line">		&#123;</span><br><span class="line">			ans[<span class="built_in">stack</span>[top]] = i;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(top)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[<span class="built_in">stack</span>[top]]=<span class="number">0</span>;</span><br><span class="line">		top--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B-发射站"><a href="#B-发射站" class="headerlink" title="B. 发射站"></a>B. <a href="https://www.luogu.com.cn/problem/P1901">发射站</a></h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 某地有 $N$ 个能量发射站排成一行，每个发射站 $i$ 都有不相同的高度 $H_i$，并能向两边（两端的发射站只能向一边）同时发射能量值为 $V_i$ 的能量，发出的能量只被两边<strong>最近的且比它高</strong>的发射站接收。计算出接受能量最多的发射站接受的能量为多少。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 维护一个单调递减栈，一个元素新加进来如果是大于栈顶元素的话，那么栈顶元素出栈，并给入栈元素加上能量值。如果不大于栈顶元素的话，就将栈顶元素加上发射能量，然后将元素入栈。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,h[maxn],v[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn],top,ans;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;h[i],&amp;v[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;h[i]&gt;h[<span class="built_in">stack</span>[top]])</span><br><span class="line">		&#123;</span><br><span class="line">			f[i]+=v[<span class="built_in">stack</span>[top]];</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		f[<span class="built_in">stack</span>[top]]+=v[i];</span><br><span class="line">		<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-音乐会的等待"><a href="#C-音乐会的等待" class="headerlink" title="C. 音乐会的等待"></a>C. <a href="https://www.luogu.com.cn/problem/P1823">音乐会的等待</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出一段序列 $a$ 代表 $n$ 个人，在一个区间 $[l,r]$ 如果区间内没有大于 $min(a[i],a[r])$ 的那么两个人可以相互看到。问这个序列中有多少对人可以相互看到。</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 我们可以维护一个单调递减栈，然后分情况讨论一下。</p>
<ul>
<li>如果要入栈元素大于当前元素，那么当前元素和入栈元素是可以相互看见的，因为这是找了左边区间第一个比它小的元素了，然后因为这是一个单调递减栈，所以我们可以一直出栈比入栈元素小的元素，可以发现这些都是可以互相看见的。而且最终的栈顶元素和要入栈元素也是可以看见的。</li>
<li>如果入栈元素小于当前元素，他可以和栈顶元素看见，而不能和后面的人看见，因为栈顶元素挡住他了。</li>
<li>如果入栈元素和当前元素高度相同，那么他们俩其实是等效的，如果有人比他们高，其实是可以直接看见两个，所以我们只需要将他们看成一个结构体，记录他们的数量和高度即可，每次统计的时候加上数量就行。</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll cnt; <span class="comment">// num </span></span><br><span class="line">	ll p; <span class="comment">//height</span></span><br><span class="line">&#125;<span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		node temp;</span><br><span class="line">		temp.cnt=<span class="number">1</span>;</span><br><span class="line">		temp.p=h[i];</span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;h[i]&gt;<span class="built_in">stack</span>[top].p)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="built_in">stack</span>[top].cnt;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(h[i]==<span class="built_in">stack</span>[top].p)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="built_in">stack</span>[top].cnt;</span><br><span class="line">			temp.cnt+=<span class="built_in">stack</span>[top].cnt;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>[++top].cnt=temp.cnt;</span><br><span class="line">		<span class="built_in">stack</span>[top].p=temp.p;</span><br><span class="line">		<span class="keyword">if</span>(top!=<span class="number">0</span>) ans+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><a href="https://endlesslethe.com/monotone-queue-and-stack-tutorial.html">单调队列和单调栈详解</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u013686535/article/details/76725379">[SMOJ2116]诺诺的队列</a></p>
</li>
<li><p><a href="https://blog.csdn.net/dacc123/article/details/50545577">一些关于单调队列和单调栈优化dp的实例</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调队列&amp;单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces #618 (Div.2)</title>
    <url>/2020/02/10/Codeforces-618/</url>
    <content><![CDATA[<h2 id="A-Non-zero"><a href="#A-Non-zero" class="headerlink" title="A. Non-zero"></a>A. <a href="https://codeforces.com/contest/1300/problem/A">Non-zero</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 给出一段含有 $n$ 个数的序列 $a$ ，可以对其中任何数加一，问最少操作多少次让每一个数和序列和都不为0。</p>
<a id="more"></a>

<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp; &nbsp; &nbsp; 输入的时候如果输入的是 $0$ 就将答案加一，最后如果序列和为 $0$ 的话答案加一。</p>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,sum,p,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			<span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				sum+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> sum+=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sum==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="B-Assigning-to-Classes"><a href="#B-Assigning-to-Classes" class="headerlink" title="B. Assigning to Classes"></a>B. <a href="https://codeforces.com/contest/1300/problem/B">Assigning to Classes</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 将 $2n$ 个数分成个奇数序列，问两个奇数序列的中位数之差最小为多少。</p>
<hr>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp; &nbsp; &nbsp; 直接就将序列排序然后输出中间两个数之差即可。</p>
<hr>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> p=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+<span class="number">1</span>+p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">abs</span>(a[n]-a[n+<span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="C-Anu-Has-a-Function"><a href="#C-Anu-Has-a-Function" class="headerlink" title="C. Anu Has a Function"></a>C. <a href="https://codeforces.com/contest/1300/problem/C">Anu Has a Function</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 给出函数 $f: f(x,y)=(x|y)-y $ ，给出序列 $a$，序列 $a$ 中含有 $n$ 个数，可以表示为$[a_1,a_2\cdots,a_n ]$ ，定义 $x=f(f(…f(f(a_1,a_2),a_3),…a_{n-1}),a_n)$ ，你可以对序列 $a$ 中元素进行重排，求使得 $x$ 最大的序列 $a$ 。如果有多种情况，输出一种即可。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>第一种思路是因为 $f(x,y)=(x|y)-y$ ，我们可以发现对于经过这样的运算之后，如果 $x$ 的某一位是1，如果 $y$ 的相应位是0，那么运算出来的 $f(x,y)$ 对应位就是1，如果 $y$ 对应位是1，那么运算出来就是0。那么对于 $x$ 的计算过程中的每一位这个规律都是适应的。因此我们只需要将位数从高到低依次扫一遍，如果这个位数为1的情况在序列所有元素中只出现了一次，那么就将唯一出现1的那个数放到第一位即可。</p>
</li>
<li><p>第二种思路<br>$$<br>\because f(x,y)=(x|y) - y {\Longleftrightarrow} f(x,y) = x\&amp;({\sim} y)<br>\therefore x=(a_1)\&amp;({\sim}a_2)\&amp;({\sim} a_3){\cdots}({\sim}a_n)<br>$$<br>   我们发现后面其实都是可交换的，所以第一个只有第一个是起决定作用的，那么我们就可以处理一个前缀和后缀的 and 数组，这样我们就可以 $O(1)$ 的计算出后面那部分，然后遍历序列 $a$ 找到最合适的 $a_1$。</p>
</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],maxk;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		maxk=<span class="built_in">max</span>(maxk,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;=maxk)</span><br><span class="line">	&#123;</span><br><span class="line">		k++;</span><br><span class="line">		p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">			&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">if</span>(cnt==<span class="number">1</span>) swap(a[j],a[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		printf("%d %d\n",i,cnt);</span></span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> pre[maxn],suf[maxn]; <span class="comment">//pre is prefix,suf is suffix</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		a[i]=~a[i];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) pre[i]=a[i];</span><br><span class="line">		<span class="keyword">else</span> pre[i]=pre[i<span class="number">-1</span>]&amp;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	suf[n]=a[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		suf[i]=suf[i+<span class="number">1</span>]&amp;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p=a[i];</span><br><span class="line">		p=~a[i];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=suf[i+<span class="number">1</span>]&amp;p;</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,now);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=pre[i<span class="number">-1</span>]&amp;p;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;ans)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[i],a[<span class="number">1</span>]);</span><br><span class="line">				ans=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=pre[i<span class="number">-1</span>]&amp;suf[i+<span class="number">1</span>]&amp;p;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;ans)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[i],a[<span class="number">1</span>]);</span><br><span class="line">				ans=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,~a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="D-Aerodynamic"><a href="#D-Aerodynamic" class="headerlink" title="D. Aerodynamic"></a>D. <a href="https://codeforces.com/contest/1299/problem/B">Aerodynamic</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 给定一个凸多边形 $P$ 的所有顶点，可以将凸多边形沿向量 $(x,y)$ 平移，我们定义多边形 $T$ 是所有 $P$ 平移到与原点有交点后所构成的点集所形成的图形（我知道这句话有点绕，我实在是解释不明白，实在不行康康原题吧）。那么问这个 $T$ 是否是和 $P$ 相似的，如果是输出YES，不是输出NO。</p>
<hr>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp; &nbsp; &nbsp; 就是判断这个图形是不是中心对称图形就行了，证明还不会，暂且放一下，会了再写QAQ..</p>
<hr>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//	printf("%d",p);</span></span><br><span class="line">	<span class="keyword">int</span> x1=x[<span class="number">1</span>]+x[<span class="number">1</span>+p];</span><br><span class="line">	<span class="keyword">int</span> y1=y[<span class="number">1</span>]+y[<span class="number">1</span>+p];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=p;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x1!=x[i]+x[i+p]||y1!=y[i]+y[i+p])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>背包进阶</title>
    <url>/2020/02/09/%E8%83%8C%E5%8C%85%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="1-分组背包"><a href="#1-分组背包" class="headerlink" title="1. 分组背包"></a>1. <a href="https://www.luogu.com.cn/problem/P1757">分组背包</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 在01背包基础上，将其中的物体分成 $k$ 组，每组内的物品相互冲突，即只能取其中一个，问最大价值。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 同一组中各个物品是相互排斥的，那么我们对于处理可以外层循环组别，然后循环体积，最后循环组内的物品，然后套用01背包的转移方程 $dp[i]=max(dp[i],dp[i-v[k]]+w[k])$ 即可。我们来思考一下他的正确性，为什么只要这样循环就能确保每个组最多只取用一种呢？很明显组内的我们对于同一个体积 $V$ ，求体积 $V$ 对应的最大价值的时候，是从这个组内所有物品中取了能获得最大价值的策略，很明显当我们转移任何一个 $dp[i-v[k]]$ 的状态的时候，他们其中都不包含第 $i$ 组的物品，都是只包含了前 $i-1$ 组的物品，因为我们最终取得最大价值的路径是确定的，因此通过这个方式我们就可以确保每个组内只取一种，但是如果体积和组内物品的循环调换过来，就不行了，因为之前的状态就会包含当前组内的其他物品。</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">105</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">&#125;p[maxt][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxt];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> q,w,e,maxe;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;q,&amp;w,&amp;e);</span><br><span class="line">		cnt[e]++;</span><br><span class="line">		p[e][cnt[e]].a=q;</span><br><span class="line">		p[e][cnt[e]].b=w;</span><br><span class="line">		maxe=<span class="built_in">max</span>(maxe,e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxe;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=p[i][k].a)</span><br><span class="line">				dp[j]=<span class="built_in">max</span>(dp[j],dp[j-p[i][k].a]+p[i][k].b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-有依赖的背包"><a href="#2-有依赖的背包" class="headerlink" title="2. 有依赖的背包"></a>2. <a href="https://www.luogu.com.cn/problem/U65320">有依赖的背包</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 在01背包的基础上给物品加上依赖，某个物品可能为附件，必须买了主件之后才能买。规定一个物品最多有两个附件，并且附件不会再有附件，也不存在循环依赖（附件再依赖于主件）。问能获得的最大价值为多少。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 这道题有三种思路，难度依次递增。</p>
<ul>
<li>这道题的附件很少，可能为0，1，2。那么我们就在01背包的基础上，分五种情况来转移，分别是都不买，只买一个主件，只买主件和附件1，只买主件和附件2，买主件和两个附件。然后在这个基础上取一个最大的即可。但是这个思路对于附件可以很多的情况，就会特别麻烦。</li>
<li>第二种思路是转化成分组背包，我们注意到对于每一个主件和附件的搭配都是唯一的，也就是每种方案都是互斥的。好比最多那五种情况，我们就可以分成一组。然后进行分组背包即可。那么我们分组的时候，可以考虑到一个优化，也就是如果他们的体积相同，我们只需要选价值大的那个就可以啦。所以我们先对主件和附件这个集合，进行01背包，然后背出来相同体积下最大价值的方案，分到对应组里。这个思路对于附件也有附件的情况，就不好写了，不能直接01背包。</li>
<li>第三种思路可以应对附件也有附件的情况，可以用森林来表示所有物品之间的关系，然后树上dp做。然而，我不会。QAQ…</li>
</ul>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">32005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">65</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> num[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,p,q;</span><br><span class="line">&#125;item[maxm],minor[maxm][maxm];</span><br><span class="line"><span class="keyword">int</span> dp[maxn],cnt[maxm];</span><br><span class="line"><span class="keyword">int</span> vi[maxm][maxm],pi[maxm][maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;item[i].v,&amp;item[i].p,&amp;item[i].q);</span><br><span class="line">		<span class="keyword">if</span>(item[i].q)</span><br><span class="line">		&#123;</span><br><span class="line">			num[item[i].q]++;</span><br><span class="line">			minor[item[i].q][num[item[i].q]].v=item[i].v;</span><br><span class="line">			minor[item[i].q][num[item[i].q]].p=item[i].v*item[i].p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(num[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">			dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=n-item[i].v;k&gt;=minor[i][j].v;k--)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[k-minor[i][j].v]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[k]=<span class="built_in">max</span>(dp[k],dp[k-minor[i][j].v]+minor[i][j].p);	</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n-item[i].v;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[k]!=<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					cnt[i]++;</span><br><span class="line">					vi[i][cnt[i]]=k+item[i].v;</span><br><span class="line">					pi[i][cnt[i]]=dp[k]+item[i].v*item[i].p;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!item[i].q)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt[i]++;</span><br><span class="line">			vi[i][cnt[i]]=item[i].v;</span><br><span class="line">			pi[i][cnt[i]]=item[i].v*item[i].p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!cnt[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=vi[i][k])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[j]=<span class="built_in">max</span>(dp[j],dp[j-vi[i][k]]+pi[i][k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	int ans;</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-多米诺骨牌-隐式背包"><a href="#3-多米诺骨牌-隐式背包" class="headerlink" title="3. 多米诺骨牌(隐式背包)"></a>3. <a href="https://www.luogu.com.cn/problem/P1282">多米诺骨牌(隐式背包)</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 多米诺骨牌有上下两个部分，分别具有一定点数。所有多米诺骨牌上部分点数之和与下部分点数之和差的绝对值为 $x$ ，多米诺骨牌可以进行上下翻转，问当 $x$ 最小的时候最少翻转几次。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 害，本来好像没有隐式背包这个说法，我自己瞎起的名字。。其实就是没那么裸的背包，实际上转化一下还是道背包的题。这道题本来其实看起来和背包没有什么关系，但是实际想一想，假如我们把所有多米诺骨牌一开始都调成上面大下面小的情况，然后调整过的把他的消耗值设为-1，没有调整过的把消耗值设为1。达成上大下小目的需要消耗的次数为n。调整后的上下点数差为V。我们每次调整之后 $V$ 会减少牌的上下点数之差，这就是我们需要的体积。然后一开始把 $dp[V]$ 设为n。然后转移方程为 $dp[i]=min(dp[i],dp[i+v[i]]+w[i]) $ 最后只需要求从 $0\sim V$ 最小的那个点数差对应的翻转次数值就可以了。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> ini;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> up[maxn],down[maxn];</span><br><span class="line"><span class="keyword">int</span> v[maxn],w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;up[i],&amp;down[i]);</span><br><span class="line">		<span class="keyword">if</span>(up[i]&gt;=down[i])</span><br><span class="line">		&#123;</span><br><span class="line">			V+=up[i]-down[i];</span><br><span class="line">			v[i]=(up[i]-down[i])*<span class="number">2</span>;</span><br><span class="line">			w[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			V+=down[i]-up[i];</span><br><span class="line">			ini++;</span><br><span class="line">			v[i]=(down[i]-up[i])*<span class="number">2</span>;</span><br><span class="line">			w[i]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=V;i++) dp[i]=<span class="number">233333</span>;</span><br><span class="line"><span class="comment">//	dp[V]=ini;</span></span><br><span class="line">	dp[V]=ini;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V-v[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[j+v[i]]!=<span class="number">233333</span>)</span><br><span class="line">			dp[j]=<span class="built_in">min</span>(dp[j],dp[j+v[i]]+w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=V;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i]!=<span class="number">233333</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[i]); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关于背包的题</title>
    <url>/2020/02/08/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8C%85%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    &nbsp; &nbsp; &nbsp; 今天跟着背包九讲把背包再学习一下，dd_engi大佬的背包九讲Github链接: <a href="https://github.com/tianyicui/pack">背包九讲</a></p>
<hr>
<h3 id="1-采药-01背包"><a href="#1-采药-01背包" class="headerlink" title="1. 采药(01背包)"></a>1. <a href="https://www.luogu.com.cn/problem/P1048">采药(01背包)</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $n$ 个价值为 $w_i$ ，体积为 $v_i$ 的物品，装入体积为 $V$ 的背包中，问能获得的最大为多少。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先我们可以用 $f[i][j]$ 来定义前 $i$ 个物品放入体积为 $j$ 的背包中能获得最大体积，对于每一个物品，我们可以分两种情况来讨论，分别是装和不装，然后取他们两个的最大值。已经正确的定义了状态，转移方程就不难写出来了，是 $f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])$ ，然后推的话就直接外层循环物品，内层循环体积递推即可。最后 $f[n][V]$ 就是我们需要的答案。</p>
<p>​    &nbsp; &nbsp; &nbsp; 但是看了大佬们的题解，他们说，空间复杂度还可以再优化，那么我们可以看看如果优化的话，肯定是不能去掉体积那一维的，所以就是去掉第几个物品那一维。所以从 $f[i][j]$ 变成了 $f[j]$  。那么我们想想，当我们推第 $i$ 个物体的状态的时候，我们需要已知第 $i-1$ 个的状态，我们物体循环是 $1\sim n$ 那么肯定 $f[i][j]$ 一开始对应的是 $f[i-1][j]$ ，那么如果顺推体积 $0\sim V$ 的话我们可以发现，当我们推 $f[i][j]$ 需要状态 $f[i-1][j-v[i]]$  的时候，这时候如果直接调用 $f[j-v[i]]$ 对应的是 $f[i][j-v[i]]$ 也就是说，这不是我们需要的结果，这时候的状态可能已经取过一次i了，那么我们就可以逆推体积 $V\sim c[i]$ ，这样我们调用 $f[j-v[i]]$ 就刚好对应的是没取过 $i$ 的情况了！最后推出来 $f[V]$ 就是对应的答案了！</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> t,m;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=a[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-疯狂的采药-完全背包"><a href="#2-疯狂的采药-完全背包" class="headerlink" title="2. 疯狂的采药(完全背包)"></a>2. <a href="https://www.luogu.com.cn/problem/P1616">疯狂的采药(完全背包)</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $n$ 种价值为 $w_i$ ，体积为 $v_i$ 的物品，每一种物品有无数个，装入体积为 $V$ 的背包中，问能获得的最大为多少。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 那么很显然我们可以把一个它转化成  $\sum_{i=1}^n \lfloor{\frac{V}{v_i}}\rfloor$ 个物品的01背包，也可以在取每个物体的时候循环 $\lfloor{\frac{V}{v_i}}\rfloor$ 次，但是我们可以思考对上述01背包的优化，我们发现如果顺着取，刚好对应的就是我们需要的状态，也就是说我们只需要将 $V$ 的循环正过来就可以了！</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> t,m;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;=t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-宝物筛选-多重背包"><a href="#3-宝物筛选-多重背包" class="headerlink" title="3. 宝物筛选(多重背包)"></a>3. <a href="https://www.luogu.com.cn/problem/P1776">宝物筛选(多重背包)</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $N$ 种物品和一个容量为 $V$ 的背包。第 $i$ 种物品最多有 $m_i$ 件可用，每件耗费的空间是 $v_i$，价值是 $w_i$ 。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 那么这道题裸的做法就是对于转移 $f[v]$ 这个方程的时候，考虑取多少个物品，可以取一个，可以取两个，在不超过体积情况下最多取 $m[i]$ 个，转移方程 $f[v]=max(f[v],f[v-k*v[i]])\quad k\in[1,m_i]$ 。那么这样其实时间复杂度还是很高的，所以大佬们给出了优化方案</p>
<ul>
<li>第一种就是把 $m_i$ 个物品进行二进制拆分，把他们拆成 $1$，$2^1$，$2^2$ ····等等，一直拆到不能再拆，这样我们就能够将 $m_i$ 个物品拆成 $log(m_i)$ 个物品，但是他们还是能够表示出所有的情况。然后就继续01背包背一下就可以了。</li>
<li>单调队列优化，我不会，我太菜了。。</li>
</ul>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,cnt;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn],v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j*=<span class="number">2</span>) <span class="comment">//二进制拆分</span></span><br><span class="line">        &#123;</span><br><span class="line">            v[++cnt]=j*a;</span><br><span class="line">			w[cnt]=j*b;</span><br><span class="line">            c-=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c) </span><br><span class="line">		&#123;</span><br><span class="line">			v[++cnt]=a*c;</span><br><span class="line">			w[cnt]=b*c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">   		&#123;</span><br><span class="line">   			f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>基础线性dp例题 #2</title>
    <url>/2020/02/07/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7dp%E4%BE%8B%E9%A2%98-2/</url>
    <content><![CDATA[<h3 id="1-石子归并"><a href="#1-石子归并" class="headerlink" title="1. 石子归并"></a>1. <a href="https://www.51nod.com/Challenge/Problem.html#problemId=1021">石子归并</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​     &nbsp; &nbsp; &nbsp; $N$ 堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将 $N$ 堆石子合并成一堆的最小代价。</p>
<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 很经典的区间dp例题，我们可以用 $dp[i][j]$ 来表示合并 $i\sim j$ 所需的最小代价，通过枚举中间的断点，来通过方程 $dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+cost[i][j])$  ，其中 $cost[i][j]$ 表示从 $i\sim j$ 的石子总数，通过前缀和很容易计算。在进行状态转移时需要前面状态已知，因为是枚举中间断点，所以断开区间的长度一定要小于原区间，因此在转移之前需要确保比他短的区间都已经达到了最小代价，因此我们可以通过枚举区间长度从 $2\sim N$ 来实现。</p>
<a id="more"></a>

<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum[maxn],a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-p+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">			dp[i][j]=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1880-NOI1995-石子合并"><a href="#2-P1880-NOI1995-石子合并" class="headerlink" title="2. P1880 [NOI1995]石子合并"></a>2. <a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; $N$ 堆石子摆成一个环。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将 $N$ 堆石子合并成一堆的最小代价和最大代价。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 这个题和上个题只有两个地方不同，一个是从线到环，一个是同时求最大和最小代价。害，其实这样也没变什么东西，也是跟上面一样，枚举区间长度和切割点。我们可以把一个环想象成一个链，如果这个环是由 N 个元素构成，那么这个链就由 N+N 个元素构成，这么这样就能确保你每次枚举区间的时候能取到合法的值，好比你要可以合并最后一个和第一个，那么就是对应的  $dp[n][n]+dp[n+1][n+1]+cost[n][n+1]$  。不过这样最后寻找答案的时候肯定不只是 $dp[i][n]$ 了，你要从 $dp[1][n]\sim dp[n][n*2]$ 中寻找最优的答案。同时求最大和最小代价就直接开两个数组记录就可以了。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">1</span>],a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ansmax,ansmin=<span class="number">12345678</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>],f[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>]; <span class="comment">//later is max , fromer is min </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		a[i+n]=a[i];</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	 &#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) dp[i][i]=f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-p+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">			dp[i][j]=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ansmax=<span class="built_in">max</span>(ansmax,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ansmin=<span class="built_in">min</span>(ansmin,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,ansmin,ansmax);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-P1140-相似基因"><a href="#3-P1140-相似基因" class="headerlink" title="3. P1140 相似基因"></a>3. <a href="https://www.luogu.com.cn/problemnew/solution/P1140">P1140 相似基因</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $A : T :C : G $ 四种碱基，他们之间可以两两配对，特殊的，一个碱基也可以和空碱基配对，但是空碱基和空碱基配对是不被允许的，当不同的碱基间两两配对时，会具有一定的相似度，问给定两段序列 $s$，$t$ 能获得的最大相似度是多少。</p>
<ul>
<li>碱基配对时相似度的定义如下</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">C</th>
<th align="center">G</th>
<th align="center">T</th>
<th align="center">空</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">5</td>
<td align="center">-1</td>
<td align="center">-2</td>
<td align="center">-1</td>
<td align="center">-3</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">-1</td>
<td align="center">5</td>
<td align="center">-3</td>
<td align="center">-2</td>
<td align="center">-4</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">-2</td>
<td align="center">-3</td>
<td align="center">5</td>
<td align="center">-2</td>
<td align="center">-2</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">-1</td>
<td align="center">-2</td>
<td align="center">-2</td>
<td align="center">5</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">空</td>
<td align="center">-3</td>
<td align="center">-4</td>
<td align="center">-2</td>
<td align="center">-1</td>
<td align="center">非法</td>
</tr>
</tbody></table>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先用一个二维数组来存储对应的相似值表。因为对应的两段序列，我感觉这种题一般都是用 $dp[i][j]$ 来表示第一段序列从 $1\sim i$ 对应第二段序列 $1\sim j$ 所能获得的最大相似度，那么思考一下状态转移。</p>
<ul>
<li><p>首先可以是碱基对空碱基，这时候 $s$ 要匹配碱基，$t$ 中匹配空碱基，这样的话就从应该从 $dp[i-1][j] $转移过来，对应的转移方程为  $dp[i][j]=max(dp[i][j],dp[i-1][j]+map[s[i]][blank])$</p>
</li>
<li><p>也可以是空碱基对碱基，对应的转移方程为$dp[i][j]=max(dp[i][j],dp[i][j-1]+map[blank][t[j]])$</p>
</li>
<li><p>也可以是碱基对碱基，对应的转移方程为$dp[i][j]=max(dp[i][j],dp[i-1][j-1]+map[s[i]][t[j]])$</p>
</li>
</ul>
<p>​    &nbsp; &nbsp; &nbsp;  害，想到这里我又突然懵逼了，我在想是否能确保两个序列所有的碱基都被用到，仔细想想确实是可以的，因为状态定义的就是用了前 $i$ 个碱基和前 $j$ 个碱基所获得的最大相似度。最后我们就处理一下边界就可以了，边界我们可以发现是 $dp[i][0]$ 和 $dp[0][i]$ ，这就是可以对应着空碱基和相应 $s[i]$ 和 $t[i]$ 的碱基，因此只需要用循环依次转移一遍就可以了。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">5</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-4</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-3</span>,<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//A 0 C 1 G 2 T 3 blank 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%s%d%s"</span>,&amp;n,s+<span class="number">1</span>,&amp;m,c+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'A'</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'C'</span>) a[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'G'</span>) a[i]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'T'</span>) a[i]=<span class="number">3</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'A'</span>) b[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'C'</span>) b[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'G'</span>) b[i]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'T'</span>) b[i]=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">map</span>[a[i]][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="built_in">map</span>[<span class="number">4</span>][b[i]];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=-inf;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][j<span class="number">-1</span>]+<span class="built_in">map</span>[<span class="number">4</span>][b[j]]);</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]+<span class="built_in">map</span>[a[i]][<span class="number">4</span>]);</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="built_in">map</span>[a[i]][b[j]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[n][m]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>基础线性dp例题</title>
    <url>/2020/02/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7dp%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>​    &nbsp; &nbsp; &nbsp; 某位大佬曾经说过，dp不会没问题，想不到状态转移方程没问题，多做题就会了。所以，我打算多刷点dp题。那么，先从基础刷起吧。</p>
<h3 id="1-P1091-合唱队形"><a href="#1-P1091-合唱队形" class="headerlink" title="1. P1091 合唱队形"></a>1. <a href="https://www.luogu.com.cn/problem/P1091">P1091 合唱队形</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 已知序列 $a$ 有 $n$ 个数，通过取出其中一些数可以使他满足严格的先增再减序列，问最少取出几个。</p>
<hr>
<a id="more"></a> 

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 很显然想要求最少取出几个，我们就看严格先增再减的序列的最长长度即可。我们可以用 $g[i]$ 来存储到 $a[i]$ 为止的最长递增子序列的长度，然后用 $l[i]$ 来存储从 $a[i]$ 到序列末尾最长的递减子序列的长度。处理 $g[i]$ 从前往后扫，处理 $l[i]$ 需要从后往前扫。处理完 $f$ 和 $g$ 数组那么就从左到右扫一遍，$ans=max(ans,g[i]+l[i]-1)$ 。答案即是 $n-ans$ 。 </p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn],g[maxn],l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]) g[i]=<span class="built_in">max</span>(g[i],g[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n+<span class="number">1</span>;j&gt;i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]) l[i]=<span class="built_in">max</span>(l[i],l[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxout=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maxout=<span class="built_in">max</span>(maxout,g[i]+l[i]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,n-maxout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1280-尼克的任务"><a href="#2-P1280-尼克的任务" class="headerlink" title="2. P1280 尼克的任务"></a>2. <a href="https://www.luogu.com.cn/problem/P1280">P1280 尼克的任务</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 尼克的一个工作日为 $n$ 分钟，从第一分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $p+t-1$ 分钟结束。（实在不会总结题意，就直接复制过来了）</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 我们可以设 $f[i]$ 为时间从 $i\sim n$ 所能获得最长空闲时间，最终 $f[1]$ 对应的就是答案。假设在这个 $i$ 分钟有 $k[i]$ 个任务可以，那么我们可以分以下情况转移</p>
<ul>
<li>$k[i]=0$  ， 那么  $f[i]=f[i+1]+1$ </li>
<li>$k[i]\not=0$  ，那么可以循环 $1 \sim k[i]$ 遍历这个时间点开始的任务，$f[i]=max(f[i],f[i+k[i].t])$ </li>
</ul>
<p>​    &nbsp; &nbsp; &nbsp; 思路是这样的，但是我们记录 $k[i].t$ 并不好记录，因此我们可以先将任务开始时间按降序排序，用一个一个变量 $cnt$ 来代表已经取到第几个任务了，那么这样一直取下去，最终就能够遍历所有的任务。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(struct task a,struct task b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.l&gt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,n,k; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t[i].l,&amp;t[i].r);</span><br><span class="line">		p[t[i].l]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(t+<span class="number">1</span>,t+<span class="number">1</span>+k,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!p[i])</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i]=dp[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i]=<span class="built_in">max</span>(dp[i],dp[i+t[cnt].r]);</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>​    </p>
<p>​    &nbsp; &nbsp; &nbsp; 我太懒了····就写了两道，明天继续加油吧。。</p>
]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#617(Div.3)</title>
    <url>/2020/02/05/Codeforces-617/</url>
    <content><![CDATA[<h3 id="A-Array-with-Odd-Sum"><a href="#A-Array-with-Odd-Sum" class="headerlink" title="A. Array with Odd Sum"></a>A. <a href="https://codeforces.com/contest/1296/problem/A">Array with Odd Sum</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出包含 <strong>n</strong> 个正整数的序列 <strong>a</strong> ，你可以把任何一个元素 $a_i$ ，赋值给另一个元素 $a_j$ ($i\neq j$) ，问通过任意此操作能否将序列 <strong>a</strong> 的和变为奇数。可以输出 <strong>YES</strong> ,不可以输入 <strong>NO</strong>.</p>
<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先当起始和为奇数的时候，就直接可输出 <strong>YES</strong> 了，如果是偶数的话，我们可以发现，如果序列元素中同时包含奇数和偶数，那么就是可以的，否则不可以。</p>
<a id="more"></a>

<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,flag,sum,p,flag1,flag2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		flag2=flag1=<span class="literal">false</span>;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			sum+=p;</span><br><span class="line">			<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">1</span>) flag1=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) flag2=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag1&amp;&amp;flag2) flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="B-Food-Buying"><a href="#B-Food-Buying" class="headerlink" title="B. Food Buying"></a>B. <a href="https://codeforces.com/contest/1296/problem/B">Food Buying</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 初始有 <strong>s</strong> 个货币，每次花费 <strong>x</strong> 个货币会返还 $\lfloor{\frac{x}{10}}\rfloor$ 个货币，问最多共能花费多少货币。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 贪心即可。剩余的货币一直除10累加，注意最终剩余不足10的处理。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p=s;</span><br><span class="line">			<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(p)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(p&lt;<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">				now=p/<span class="number">10</span>;</span><br><span class="line">				s+=now;</span><br><span class="line">				p%=<span class="number">10</span>;</span><br><span class="line">				p+=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-Yet-Another-Walking-Robot"><a href="#C-Yet-Another-Walking-Robot" class="headerlink" title="C. Yet Another Walking Robot"></a>C. <a href="https://codeforces.com/contest/1296/problem/C">Yet Another Walking Robot</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 一个机器人初始在 $(0,0)$ 点，规定 <strong>‘L’</strong>  ，<strong>‘R’</strong> ，<strong>‘U’</strong> ，<strong>‘D’</strong>  分别对应向左，向右，向上和向下。给定一段包含上述字母的序列 <strong>s</strong> ，机器人遵循指引序列移动。如果删除一段连续序列可使得机器人最终到达终点不变，问删除的最短序列的起始和终点为多少。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 想了半天想了错误的解法。。一直在考虑 <strong>L</strong> 和 <strong>R</strong> 数相等，<strong>U</strong> 和 <strong>D</strong> 相等，通过这个方法来找序列。看了题解才发现是通过坐标来看。我们可以开一个map记录坐标和步数的关系，从左到右扫序列，如果没有到达过这个坐标，就记录当前是第几次移动到达这个坐标的，如果到达过的话，就看上一次到达这个坐标时的步数，计算他们的序列长度，如果小于计算的就更新答案。因为是需要找最小的，因此只需要记录上一次到达的步数即可。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">-1</span>,r=n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pos; <span class="comment">//first为x second为y</span></span><br><span class="line">		<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; last;  </span><br><span class="line">		pos.first=pos.second=<span class="number">0</span>;</span><br><span class="line">		last[pos]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'L'</span>) pos.first--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) pos.first++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'U'</span>) pos.second++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'D'</span>) pos.second--;</span><br><span class="line"><span class="comment">/*			</span></span><br><span class="line"><span class="comment">			if(i==2)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				printf("%d %d\n",pos.first,pos.second);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">*/</span>			</span><br><span class="line">			<span class="keyword">if</span>(last.count(pos)!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> p=i-last[pos];</span><br><span class="line"><span class="comment">//				if(i==2) printf("%d %d\n",i,last[pos]);</span></span><br><span class="line">				<span class="keyword">if</span>(p&lt;r-l)</span><br><span class="line">				&#123;</span><br><span class="line">					l=last[pos];</span><br><span class="line">					r=i;	</span><br><span class="line">				&#125;	</span><br><span class="line"><span class="comment">//				if(i==2 )printf("%d %d\n",l,r);</span></span><br><span class="line">			&#125;</span><br><span class="line">			last[pos]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,l+<span class="number">1</span>,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="D-Fight-with-Monsters"><a href="#D-Fight-with-Monsters" class="headerlink" title="D. Fight with Monsters"></a>D. <a href="https://codeforces.com/contest/1296/problem/D">Fight with Monsters</a></h3><hr>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 由你先手和对手轮流击打 $n$ 个血量为 $h_i$ 的小怪兽，你可以对怪物造成 $a$ 点伤害，对手可以造成 $b$ 点伤害。你有 $k$ 次机会使对手跳过他的回合。当小怪兽血量 $h\le0$ 时视为被击杀，当你击杀怪兽，你获得一分，当对手击杀，你不得分。求你最多能获得多少分数。</p>
<hr>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 先看一下对于每个怪兽我们要击杀需要花费多少机会，你和对手一个回合会击杀怪兽 $a+b$ 点血量，因此你可以一直将回合进行到怪兽血量小于$a+b$，接下来我们可以分两种情况讨论。</p>
<ul>
<li><p>怪兽血量为0，那么我们就需要回溯对手最后一个回合，然后需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil$ 次</p>
</li>
<li><p>怪兽血量不为0，我们需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil-1$ 次，注意这里不能直接写 $\lfloor\frac{h_i}{a}\rfloor$ 次，因为如果 $h_i$ 刚好能被 $a$ 整除，后面这个写法就错了。</p>
</li>
</ul>
<p>​    &nbsp; &nbsp; &nbsp; 计算出了每个怪兽需要花费的机会那么就好做了，就变成了一个贪心问题，我们去尽可能得击杀需要的机会少的，当机会消耗完毕，得到的就是答案了。</p>
<hr>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,k;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;a,&amp;b,&amp;k);</span><br><span class="line">	<span class="keyword">int</span> p=a+b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">		h[i]%=p;</span><br><span class="line">		<span class="keyword">if</span>(h[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			h[i]+=b;</span><br><span class="line">			f[i]=<span class="built_in">ceil</span>((<span class="keyword">double</span>)h[i]/a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> f[i]=<span class="built_in">ceil</span>((<span class="keyword">double</span>)h[i]/a)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(f+<span class="number">1</span>,f+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k-f[i]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		ans++;</span><br><span class="line">		k-=f[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷的一些搜索题</title>
    <url>/2020/02/04/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="1-P1378-油滴扩展"><a href="#1-P1378-油滴扩展" class="headerlink" title="1. P1378 油滴扩展"></a>1. <a href="https://www.luogu.com.cn/problem/P1378">P1378 油滴扩展</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 在长方形框中，最多有 n ($0\le{n}\le6$)个相异点，在框中点上依次放置可扩展的油滴，当碰到其他油滴边界或者长方形边框时会停止，扩展呈圆形展开。放置下一个时会确保上一个已经扩展完成。问通过变换放置顺序可使得最终框中剩下的面积最小为多少。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 这是个裸的dfs，情况最多也就 $6! = 720$ 种，所以我们可以只需要设置一个vis数组来记录是否已经放置过这个油滴，计算已扩展油滴和将要放的油滴之间的距离可以用 <strong>两点距离-扩展油滴的半径</strong>来实现 ，但是有个坑需要注意，就是当一个油滴已经放在已经有扩展油滴覆盖的区域，那么他俩的距离是0，而不是负数，因此在计算半径的时候需要优化一下。</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,y,xx,yy;</span><br><span class="line"><span class="keyword">double</span> rx[maxn];</span><br><span class="line"><span class="keyword">double</span> maxans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dx[maxn],dy[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">diss</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span> <span class="comment">//计算两点距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">radius</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//计算半径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="built_in">min</span>(<span class="built_in">abs</span>(dx[p]-x),<span class="built_in">min</span>(<span class="built_in">abs</span>(dy[p]-y),<span class="built_in">min</span>(<span class="built_in">abs</span>(dx[p]-xx),<span class="built_in">abs</span>(dy[p]-yy))));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i]&amp;&amp;i!=p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> dis=diss(dx[i],dy[i],dx[p],dy[p]);</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dis-rx[i],<span class="number">0.0</span>)); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowcnt,<span class="keyword">double</span> area)</span> <span class="comment">//area为拓展总面积 nowcnt为现在已经放置了几个 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nowcnt==n)</span><br><span class="line">	&#123;</span><br><span class="line">		maxans=<span class="built_in">max</span>(maxans,area);</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i]=<span class="literal">true</span>;</span><br><span class="line">			rx[i]=radius(i);</span><br><span class="line">			dfs(nowcnt+<span class="number">1</span>,area+pi*rx[i]*rx[i]);</span><br><span class="line">			rx[i]=<span class="number">0</span>;</span><br><span class="line">			vis[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;xx,&amp;yy);</span><br><span class="line">	<span class="keyword">double</span> sum=<span class="built_in">abs</span>(x-xx)*<span class="built_in">abs</span>(y-yy); <span class="comment">//矩形总面积 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;dx[i],&amp;dy[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%0.0lf"</span>,sum-maxans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1120-小木棍"><a href="#2-P1120-小木棍" class="headerlink" title="2. P1120 小木棍"></a>2. <a href="https://www.luogu.com.cn/problem/P1120">P1120 小木棍</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 将一些长度为 <strong>x</strong> 的等长木棍全部切成 <strong>n</strong> 段不超过50的小木棍，求长木棍长度 <strong>x</strong> 的最小长度。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先这个题是有个坑的，题目给出来了，输入的小木棍长度可能会有大于50的，因此我们需要筛掉它。</p>
<p>​    &nbsp; &nbsp; &nbsp; 那么很显然这个题是一道搜索题，我们可以写搜索函数<code>dfs(int nowcnt,int nxt,int lenlast,int len)</code>.上述参数分别表示: 现在在寻找第几根小木棍，我们寻找下一个拼接段应该从哪里开始找，当前这根拼接还需要多长，以及我们要拼成多长的木棍。搜索的复杂度这么高，对于 $n\le65$ 的数据肯定不能直接无脑搜，因此需要想想怎么优化。</p>
<ul>
<li><p>首先要从大到小排序这个很关键的，因为你从大的先凑就能够保证后面选择的时候容错率更高一些。</p>
</li>
<li><p>很显然我们可以剪掉当 lenlast&lt;0 的情况，这个地方我们可以在拼接的时候就判断，也可以在拼接后判断。</p>
</li>
<li><p>在寻找下一个拼接片段的时候，我们可以通过二分搜索来查找下一个不超过lenlast的片段，我选择了直接用STL的库中的lower_bound函数。<del>(其实因为是我的二分总是写炸)</del></p>
</li>
<li><p>再就是我们对于相等片段的处理，很显然当前片段不符合情况那么与他等长的也都不会符合，因此我们可以直接循环筛掉。当然更优的方法可以提前处理一个跳表，直接跳到下一个与他不同的位置。</p>
</li>
<li><p>最后这个优化还是挺难想的，就是如果当前片段搜下去已经不符合情况，但是当前的lenlast是等于当前片段长度的，也就是说你正好用了尽可能满足条件的一个方案，也还是没达到目的，你们你继续往下搜，用比他还要劣的方案肯定也是不可能的，因此直接就break跳出循环不需要往下搜了。</p>
<p><del>不过就算加了这么多优化我还是T了三个点，直接 O<sub>2</sub>一开跑路了嘿嘿</del></p>
</li>
</ul>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],temp,icnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> totlen,maxlen,cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],finish;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowcnt,<span class="keyword">int</span> nxt,<span class="keyword">int</span> lenlast,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//nowcnt:现在正在拼接第几根 </span></span></span><br><span class="line"><span class="function"><span class="comment">//nxt:我们应该从哪里开始检索 </span></span></span><br><span class="line"><span class="function"><span class="comment">//lenlast:现在拼接还需要多少才能拼接完成 </span></span></span><br><span class="line"><span class="function"><span class="comment">//len:每根木棍的理想长度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lenlast&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(lenlast==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		printf("test\n");</span></span><br><span class="line">		<span class="keyword">if</span>(nowcnt==cnt) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">			finish=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(p=<span class="number">1</span>;p&lt;=n;p++) <span class="keyword">if</span>(!vis[p]) <span class="keyword">break</span>;</span><br><span class="line">		vis[p]=<span class="literal">true</span>;</span><br><span class="line">		dfs(nowcnt+<span class="number">1</span>,p+<span class="number">1</span>,len-a[p],len);</span><br><span class="line">		<span class="keyword">if</span>(finish) <span class="keyword">return</span> ;</span><br><span class="line">		vis[p]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=lower_bound(a+nxt,a+<span class="number">1</span>+n,lenlast,greater&lt;<span class="keyword">int</span>&gt;())-a;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			printf("what\n");</span></span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;lenlast-a[i]&gt;=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i]=<span class="literal">true</span>;</span><br><span class="line">				dfs(nowcnt,i+<span class="number">1</span>,lenlast-a[i],len);</span><br><span class="line">				<span class="keyword">if</span>(finish) <span class="keyword">return</span>;</span><br><span class="line">				vis[i]=<span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">while</span>(a[i+<span class="number">1</span>]==a[i]) i++;</span><br><span class="line">				<span class="keyword">if</span>(i==n) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span>(lenlast-a[i]==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;<span class="number">50</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> a[i]=temp;</span><br><span class="line">		maxlen=<span class="built_in">max</span>(maxlen,a[i]);</span><br><span class="line">		totlen+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">while</span>(!a[n]) n--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=maxlen;l&lt;=totlen;l++)</span><br><span class="line">	&#123;</span><br><span class="line">		finish=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(totlen%l!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		cnt=totlen/l;</span><br><span class="line">		vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">2</span>,l-a[<span class="number">1</span>],l);</span><br><span class="line">		vis[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(finish) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-YOKOF-Power-Calculus"><a href="#3-YOKOF-Power-Calculus" class="headerlink" title="3. YOKOF - Power Calculus"></a>3. <a href="https://www.spoj.com/problems/YOKOF/">YOKOF - Power Calculus</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出一个正整数 <strong>n</strong> ，只能使用乘法或者除法，可以乘除 $x$ 或者过程中产生的中间值 $x^i$ ，输出使得 $x$ 变为 $x^n$ 所需的最少步数。$(n\le100)$</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 很显然我们一直是对指数进行操作，看似是乘除，直接转化为指数的加减。因此我们需要记录一个状态数组来记录乘除中间所产生的 $x^i$ ，以便后续过程中使用。但是这道题直接搜索的话，又会超时，因为他把大量的时间浪费在高深度上，但是这个却不一定是最优解。因此需要用到迭代加深搜索(IDDFS).</p>
<blockquote>
<p>迭代加深搜索(IDDFS)主要用于处理一些题目可能会搜到很深但是答案却不是最优的问题。有的时候dfs搜索的深度是无穷的，而且他的复杂度是呈指数级增长的，因此这其中某些情况就可以用IDDFS，在每次搜索的时候，我们给深度一个限制，当达到这个最大深度却没有得到答案的时候，就返回，然后逐步提升深度，这样我们就可以避免将时间浪费在那些无谓的高深度搜索上了。</p>
</blockquote>
<p>$$<br>\sum_{i=0}^n2^i=2^{n+1}-1（指数级别增长实例）<br>$$</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1005</span>]; <span class="comment">//用来记录每次生成的中间状态 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> dep,<span class="keyword">int</span> maxdep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">0</span>||dep&gt;maxdep||k&lt;&lt;(maxdep-dep)&lt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==n||k&lt;&lt;(maxdep-dep)==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	x[dep]=k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=dep;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dfs(k+x[i],dep+<span class="number">1</span>,maxdep)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//对应乘法 </span></span><br><span class="line">		<span class="keyword">if</span>(dfs(k-x[i],dep+<span class="number">1</span>,maxdep)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//对应除法 </span></span><br><span class="line">	&#125;</span><br><span class="line">	x[dep]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dfs(<span class="number">1</span>,<span class="number">0</span>,i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>洛谷提高历练地</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX的一些总结</title>
    <url>/2020/02/03/LaTeX%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h3><!-- 空一行 -->

<p><img src="/images/xila.png" alt="xila"></p>
<a id="more"></a>

<hr>
<h3 id="一些技巧和特殊符号"><a href="#一些技巧和特殊符号" class="headerlink" title="一些技巧和特殊符号"></a>一些技巧和特殊符号</h3><ul>
<li><p>上标：num_i  -&gt;  $num_i$</p>
</li>
<li><p>下标：e^x -&gt;  $e^x$  （如果下标或上标不明显，可嵌套多层来达到目的）</p>
<ul>
<li>上下标是一串字符的话可用{}括起来表示</li>
</ul>
</li>
<li><p>根号：\sqrt[3]{x} -&gt; $\sqrt[3]{x}$</p>
</li>
<li><p>省略号： 在下面\dots -&gt; $\dots$     在中间\cdots -&gt;  $\cdots$</p>
</li>
<li><p>方框:  \boxed{example}  -&gt;  $\boxed{example}$   (还有一个\fbox与此类似  \fobx{example} -&gt; $\fbox{example}$) </p>
</li>
<li><p>字体加粗:  \mathbf{example} -&gt; $\mathbf{example}$ </p>
</li>
<li><p>字体斜体且加粗:  \boldsymbol{example}  -&gt;  $\boldsymbol{example}$</p>
</li>
<li><p>插入普通文本（自适应大小）:  \text{测试}  -&gt; $\text{测试}$  </p>
<p><img src="/images/specialsign.png" alt="specialsign"></p>
<p><img src="/images/specialsign2.png" alt="specialsign"></p>
</li>
</ul>
<hr>
<h3 id="一些基本符号"><a href="#一些基本符号" class="headerlink" title="一些基本符号"></a>一些基本符号</h3><ul>
<li><p>求和:  \sum_1^n  -&gt;  $\sum_1^n$ </p>
</li>
<li><p>积分:  \int_1^n -&gt; $\int_1^n$   \iint -&gt; $\iint$  以此类推$\cdots$</p>
</li>
<li><p>极限:  \lim_{x \to +\infty}  -&gt; $\lim_{x \to +\infty}$</p>
</li>
<li><p>分数:  \frac{1}{2} -&gt; $\frac{1}{2}$   如果要写多层分数可以用\cfrac （可以避免字母逐层缩小的限制）</p>
</li>
<li><p>组合数: \binom{5}{2} -&gt; $\binom{5}{2}$</p>
</li>
<li><p>下取整: \lfloor{x}\rfloor -&gt;  $\lfloor{x}\rfloor$</p>
</li>
<li><p>下取整: \lceil{x}\rceil -&gt; $\lceil{x}\rceil$</p>
<p><img src="/images/qita.png" alt="qita"></p>
<p><img src="/images/qita2.png" alt="qita2"></p>
</li>
</ul>
<hr>
<h3 id="关于矩阵和行列式"><a href="#关于矩阵和行列式" class="headerlink" title="关于矩阵和行列式"></a>关于矩阵和行列式</h3><ul>
<li>矩阵：用法如下，元素中间使用&amp;来分割同行元素，用\\来换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">	1 &amp; 2 &amp; 3\\</span><br><span class="line">	4 &amp; 5 &amp; 6\\</span><br><span class="line">	7 &amp; 8 &amp; 9\\</span><br><span class="line">\end&#123;matrix&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>\begin{matrix}<br>    1 &amp; 2 &amp; 3\\<br>    4 &amp; 5 &amp; 6\\<br>    7 &amp; 8 &amp; 9\\<br>\end{matrix}<br>$$</p>
<ul>
<li>行列式: 与矩阵相似，加上行列式的名字以及左右分割线即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;  \left|</span><br><span class="line">	\begin&#123;matrix&#125;</span><br><span class="line">	1 &amp; 2 &amp; 3 \\</span><br><span class="line">	4 &amp; 5 &amp; 6 \\</span><br><span class="line">	7 &amp; 8 &amp; 9 \\</span><br><span class="line">	\end&#123;matrix&#125;</span><br><span class="line">	\right|</span><br></pre></td></tr></table></figure>


<p>$$<br>A=  \left|<br>    \begin{matrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9 \\<br>    \end{matrix}<br>    \right|<br>$$</p>
<hr>
<h3 id="分段函数和方程组"><a href="#分段函数和方程组" class="headerlink" title="分段函数和方程组"></a>分段函数和方程组</h3><ul>
<li>分段函数：写法如下，每一个条件用 表达式和条件之间用 <strong>&amp;</strong> 连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x)&#x3D;</span><br><span class="line">	\begin&#123;cases&#125;</span><br><span class="line">		x&#x2F;2, &amp; &#123;n&gt;2&#125;\\</span><br><span class="line">		2x , &amp; &#123;n&#x3D;2&#125;\\</span><br><span class="line">		3x , &amp; &#123;n&lt;2&#125;\\</span><br><span class="line">	\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>f(x)=<br>    \begin{cases}<br>        x/2, &amp; {n&gt;2}\\<br>        2x , &amp; {n=2}\\<br>        3x , &amp; {n&lt;2}\\<br>    \end{cases}<br>$$</p>
<ul>
<li>方程组: 写法如下，不是一个对称的，注意left后面为{ ，right后面为. 用\\换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\left\&#123;</span><br><span class="line">	\begin&#123;array&#125;&#123;&#125;</span><br><span class="line">		a_1x+b_1y+c_1z&#x3D;d_1\\</span><br><span class="line">		a_2x+b_2y+c_2z&#x3D;d_2\\</span><br><span class="line">		a_3x+b_3y+c_3z&#x3D;d_3</span><br><span class="line">	\end&#123;array&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure>


<p>$$<br>\left\{<br>    \begin{array}{}<br>        a_1x+b_1y+c_1z=d_1\\<br>        a_2x+b_2y+c_2z=d_2\\<br>        a_3x+b_3y+c_3z=d_3<br>    \end{array}<br>\right.<br>$$</p>
<hr>
<p><strong>Ps: 上面的矩阵，行列式，分段函数和方程组有一个问题需要我们注意，因为反斜杠 \ 需要转义，那么对于每次换行需要两个\\ ，也就是说你打的时候总需要打四个，对于前面声明begin和end，或者left和right前面的反斜杠，你打的时候就要打两个，对于markdown编辑器里面编辑LaTeX可能会自适应，不会自动转义，但是我们推博客的时候，一定要注意这个地方，不然会显示错误。也就是对于上述描述中的反斜杠，都要按两倍来写</strong></p>
<hr>
<p>先总结这么多，后面那些进阶的用到了再总结。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://blog.csdn.net/happyday_d/article/details/83715440">Typora中利用LaTeX 插入数学公式</a></li>
<li><a href="https://www.jianshu.com/p/22117d964baf">LATEX 公式总结</a></li>
</ul>
]]></content>
      <categories>
        <category>不务正业</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesER</title>
    <url>/2020/02/02/CodeforcesER81/</url>
    <content><![CDATA[<h3 id="A-Display-The-Number"><a href="#A-Display-The-Number" class="headerlink" title="A : Display The Number"></a>A : <a href="https://codeforces.com/contest/1295/problem/A">Display The Number</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 用一定数目的灯管，显示尽可能大的数</p>
<p><img src="https://s2.ax1x.com/2020/02/02/1te6Re.md.png" alt="A"></p>
<a id="more"></a>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 因为位数多的肯定更大，所以肯定用尽量少的灯管搭建单个数字更好，最少的两个分别是两个灯管显示的1，以及三个灯管显示的7，所以就是尽可能的用1，如果最后剩余正好三个就显示7。这就转化成了判断奇数还是偶数的题，奇数就显示7111····，偶数就是1111···。注意要把7放在前面（我就踩坑了）。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"7"</span>);</span><br><span class="line">			n-=<span class="number">3</span>;</span><br><span class="line">			<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="B-Infinite-Prefixes"><a href="#B-Infinite-Prefixes" class="headerlink" title="B : Infinite Prefixes"></a>B : <a href="https://codeforces.com/contest/1295/problem/B">Infinite Prefixes</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给定一段01字符串 <strong>s</strong> 为循环节，得到无限循环的01字符串 <strong>t</strong>，求 <strong>t</strong> 中有多少前缀满足0个数-1个数等于期望值<strong>x</strong> （空前缀也算是一个前缀）</p>
<blockquote>
<p>前缀：例如”abcd”的前缀包括 “ “,”a”,”ab”,”abc”,”abcd”.</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>首先我们先记录循环节 <strong>s</strong> 中每个位置对应的01个数差，记为$num_i，i\in[1,n]$ （ <strong>s</strong> 长度记为n） </p>
<ul>
<li>首先我们可以发现当 <strong>x=0</strong> 的时候，空前缀也会有贡献，因此不能忽略空前缀。</li>
<li>如果循环节 <strong>s</strong> 的01数相等，那么我们可以发现最后循环节一位$num_n$总为0，那么可以分两种情况来讨论<ul>
<li>如果循环节中存在大于等于1个前缀满足期望值x，那么就有无限个满足，因此输出-1</li>
<li>如果循环节 <strong>s</strong> 中不存在满足期望值的前缀，那么 <strong>t</strong> 中也一定不存在</li>
</ul>
</li>
</ul>
<ul>
<li>再来看一般情况，如果一个前缀中包含多个循环节 <strong>s</strong> ,那么前面每个循环节对于最终01个数差的贡献总为$num_n$，因此我们可以用所期望的值 <strong>x</strong>，利用1~n 循环减去每一位的 $num_i$，如果所得是$num_n$的非负倍数，那么就是符合期望的，否则不是。(本来一直这里不太明白，后来发现对于循环节中的每一个位置，在后续循环的过程中，如果$num_n$不为0，那么这个位置每次对应的值总是唯一的)</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> t,cnt,n,x;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				num[i]=num[i<span class="number">-1</span>]+<span class="number">1</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> num[i]=num[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(num[i]==x) flag=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p=num[n];</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="literal">true</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> m=x-num[i];</span><br><span class="line">				<span class="keyword">if</span>(m%p==<span class="number">0</span>&amp;&amp;m/p&gt;=<span class="number">0</span>) </span><br><span class="line">				&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>) cnt++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="C-Obtain-The-String"><a href="#C-Obtain-The-String" class="headerlink" title="C : Obtain The String"></a>C : <a href="https://codeforces.com/contest/1295/problem/C">Obtain The String</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给定字符串 <strong>s</strong> 和 <strong>t</strong> ，每次从 <strong>s</strong> 中选取子序列放入起始为空串的 <strong>z</strong> 后，问最少需要多少次操作使得 <strong>z=t</strong></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 看了小姜老师的博客解法说是贪心，想了好一会，好像确实是可以贪心的···? 设置两个指针从 <strong>s</strong> 和 <strong>t</strong> 串的头部开始扫，对于 <strong>t</strong> 串中的每个字母，循环扫 <strong>s</strong> 串在其中找与它相同的，最终的答案就是扫 <strong>s</strong> 串的次数。(小姜老师说这个实质上就是每次尽可能找尽可能多的后缀，仔细想想确实是这样。)不过这么一直暴力扫下去肯定不是最优的方法，想办法去优化。还是借鉴大佬的想法用一个lens*26的跳表，然后O(lent)扫一遍 <strong>t</strong> 即可.</p>
<blockquote>
<p>跳表nxt的作用，用于寻找下一个所寻找字符在s中的位置。</p>
<p>nxt[x][y]用于指向从x位置开始下一个y的位置+1 （next在C++属于保留字，注意不要踩坑）</p>
</blockquote>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn],t[maxn];</span><br><span class="line"><span class="keyword">int</span> nxt[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> p,lens,lent;</span><br><span class="line"><span class="keyword">int</span> pos,ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">	<span class="keyword">while</span>(p--)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">		lent=<span class="built_in">strlen</span>(t),lens=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//		printf("%d",lens);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++)</span><br><span class="line">		&#123;</span><br><span class="line">			nxt[lens+<span class="number">1</span>][c]=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=lens;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]-<span class="string">'a'</span>==c)</span><br><span class="line">				&#123;</span><br><span class="line">					nxt[i][c]=i+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> nxt[i][c]=nxt[i+<span class="number">1</span>][c];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pos=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lent;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			pos=nxt[pos][(<span class="keyword">int</span>)t[i]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				pos=<span class="number">1</span>;</span><br><span class="line">				pos=nxt[pos][(<span class="keyword">int</span>)t[i]-<span class="string">'a'</span>];</span><br><span class="line">				<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
