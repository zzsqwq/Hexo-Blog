<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>专题四:MATLAB绘图</title>
    <url>/2020/03/23/%E4%B8%93%E9%A2%98%E5%9B%9B-MATLAB%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="4-1-二维曲线"><a href="#4-1-二维曲线" class="headerlink" title="4.1 二维曲线"></a>4.1 二维曲线</h2><h3 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h3><ul>
<li><strong>基本用法</strong>：<code>plot(x,y)</code> ，x和y分别代表横纵坐标，plot函数会将各个点连接起来，形成线，x和y一般为长度相等的向量。</li>
<li><strong>最简单的调用格式</strong>：<code>plot(x)</code><ul>
<li><strong>当x为实向量时</strong>，则以该元素下表为横坐标，元素的值为纵坐标绘制曲线。</li>
<li><strong>当x为复向量时</strong>，则以<strong>实部</strong>和<strong>虚部</strong>分别为横纵坐标绘制曲线。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><strong>plot(x,y)函数参数的变化形式</strong><ul>
<li><strong>当x为向量，y为矩阵</strong>：这时x的长度和y的列数（或行数）必须相等。这时候绘制多条曲线，分别是x为横坐标，取与x长度相等的那一个参数作为纵坐标，另一个参数为曲线的条数。<strong>如果y的行、列两个参数相等，那么用y的每一列作为纵坐标，曲线条数等于矩阵列数。</strong></li>
<li><strong>当x和y为同型矩阵</strong>：这时以x，y对应列元素为横、纵坐标绘制曲线，曲线条数等于矩阵列数。</li>
<li><strong>含多个输入参数</strong>：形如 <code>plot(x1,y1,x2,y2,···,xn,yn)</code> ，那么就是以每一个向量对组成一个点，绘制曲线。</li>
</ul>
</li>
<li><strong>含选项的plot函数，plot(x,y,选项)</strong><ul>
<li><strong>线型</strong> ：通过<code>&quot;-&quot;,&quot;:&quot;,&quot;-.&quot;,&quot;--&quot;</code> 等参数来实现实线，虚线，点画线，双画线。</li>
<li><strong>颜色</strong> ：通过 <code>&quot;r&quot;,&quot;g&quot;</code> 等实现曲线颜色的切换。当颜色选项省略，绘图自动循环使用。</li>
<li><strong>数据点标记</strong> ：通过 <code>&quot;*&quot;,&quot;o&quot;,&quot;s&quot;</code> 等来实现将数据点用星号，圆圈，方块标记。</li>
</ul>
</li>
</ul>
<h3 id="fplot函数"><a href="#fplot函数" class="headerlink" title="fplot函数"></a>fplot函数</h3><p>​    可根据参数函数的变化特性自适应地设置采样间隔，当函数值变化缓慢，采样间隔大，当变化快的时候，采样间隔小。</p>
<ul>
<li><p><strong>基本用法</strong>：<code>fplot(f,lims,选项)</code> ，参数分别函数（一般采用函数句柄表示），lims为x轴的取值范围，采用二元向量  <code>[xmin,xmax]</code> 来表示，默认值为 <code>[-5,5]</code> 。选项参数与plot函数相同。</p>
</li>
<li><p><strong>双输入参数函数的用法</strong>：<code>fplot(funx,funy,tlims,选项)</code> ，前两个分别为x，y的参数表示，通常以函数句柄的形式给出。tlims为前方函数参数 <strong>t</strong> 的取值范围，用二元向量 <code>[tmin,tmax]</code> 表示，默认的值为 <code>[-5,5]</code> ，选项参数与上述相同。</p>
</li>
</ul>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><ul>
<li>利用不同的线型和颜色在同一坐标内绘制曲线 $y=2e^{-0.5x}sin(2\pi x)$ 以及其包络线。（包络线：在<a href="https://baike.baidu.com/item/几何学/342546">几何学</a>，某个曲线族的<strong>包络线</strong>（<a href="https://baike.baidu.com/item/Envelope/7364077">Envelope</a>），是跟该曲线族的每条线都有至少一点相切的一条曲线。）</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>)';</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>]; <span class="comment">%这里绘制的是上下两条包络线，是有两行的矩阵。</span></span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x); <span class="comment">%这里绘制的是曲线本身</span></span><br><span class="line">x1=<span class="number">0</span>:<span class="number">0.5</span>:<span class="number">6</span>;</span><br><span class="line">y3=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x1).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x1); <span class="comment">%这里标记的是正弦函数和x轴的交点。</span></span><br><span class="line"><span class="built_in">plot</span>(x, y1, <span class="string">'k:'</span>, x, y2, <span class="string">'b--'</span>, x1, y3, <span class="string">'rp'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/plot1.png" alt="plot"></p>
<ul>
<li>利用fplot函数绘制  $y=sin{\frac{1}{x}}$  在区间 $[0,0.2]$ 的图像。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fplot(@x <span class="built_in">sin</span>(<span class="number">1.</span>/x),[<span class="number">0</span>,<span class="number">0.2</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/images/plot2.png" alt="plot2"></p>
<hr>
<h2 id="4-2-绘制图形的辅助操作"><a href="#4-2-绘制图形的辅助操作" class="headerlink" title="4.2 绘制图形的辅助操作"></a>4.2 绘制图形的辅助操作</h2><h3 id="添加图形标注"><a href="#添加图形标注" class="headerlink" title="添加图形标注"></a>添加图形标注</h3><ul>
<li><p><strong>title函数</strong>：用于给图形添加标题说明</p>
<ul>
<li><strong>基本用法</strong>：<code>title(&#39;图形标题&#39;)</code> ，如果是有多行，就用逗号分隔，大括号<code>{}</code>括起来。</li>
<li><strong>LaTeX排版</strong>：可在在图形标题中使用LaTeX格式控制符，要用LaTeX时将其控制字符用大括号<code>{}</code>括起来。</li>
<li><strong>控制字体</strong>：用 <code>&quot;\bf&quot;</code> ,<code>&quot;\it&quot;</code>，<code>&quot;\rm&quot;</code> 分别控制字体加粗，斜体以及正体。</li>
<li><strong>设置title函数属性</strong> ： <code>title(图形标题，属性名，属性值)</code> 其中属性名和属性值对应成对出现。<ul>
<li><strong>Color属性</strong>：用于设置图形标题文本的颜色，缺省时为黑色。</li>
<li><strong>FontSize属性</strong> ：用于设置标题文字字号，缺省时为11。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>xlable和ylable函数</strong>：给x轴和y轴添加说明</p>
<ul>
<li><strong>基本用法</strong>： <code>xlable(x轴说明)</code> ，<code>ylable(y轴说明)</code> ，同样还有 zlable等。</li>
</ul>
</li>
<li><p><strong>text函数和gtext函数</strong>：给特定位置说明</p>
<ul>
<li><strong>基本用法</strong>：<ul>
<li><code>text(x,y,说明)</code>，x、y参数用来指明说明的位置，<strong>后面的说明和title函数类似</strong>。</li>
<li><code>gtext(说明)</code>  这里没有坐标指定位置，通过鼠标的点击来指定位置。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>legend函数</strong>：用于给图形添加图例</p>
<ul>
<li><strong>基本用法</strong>：<code>legend(图例1，图例2,···)</code> 其中图例顺序要与plot函数中参数顺序相对应，<strong>图例的说明方式与tiele函数标题说明类似</strong>。</li>
</ul>
</li>
</ul>
<h3 id="坐标控制"><a href="#坐标控制" class="headerlink" title="坐标控制"></a>坐标控制</h3><ul>
<li><p><strong>axis函数</strong>：用于设置坐标轴的范围</p>
<ul>
<li><p><strong>基本用法</strong>：<code>axis([xmin,xmax,ymin,ymax,zmin,zmax])</code> ，分别代表了x，y，z轴范围。</p>
</li>
<li><p><strong>其他用法</strong>：通过在axis函数下面加语句来实现控制其他格式。</p>
<ul>
<li><strong>axis equal</strong>：横纵坐标刻度等长。</li>
<li><strong>axis square</strong>：采用正方形坐标系（默认为矩形）。</li>
<li><strong>axis auto</strong>：使用默认设置。</li>
<li><strong>axis off/on</strong>：不显示/显示坐标轴。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>给坐标系加网格和边框</strong></p>
<ul>
<li><strong>添加网格</strong>：通过 <code>grid on/off</code> 控制显示和不显示网格线，而直接用 <code>grid</code> 用于切换两种形式，如果是带网格则切换为不带，反之亦然。如果不添加语句，则默认不带。</li>
<li><strong>添加边框</strong>：通过 <code>box on/off</code> 控制显示不显示边框，用法与 <strong>grid</strong> 类似，如果不添加语句，则默认带网格。</li>
</ul>
</li>
</ul>
<h3 id="图形保持"><a href="#图形保持" class="headerlink" title="图形保持"></a>图形保持</h3><p>​    一般情况下绘图命令每执行一次，图形界面就刷新一次，去掉原有图形，绘制新图形，如果要保留原有图形，可使用图形保持命令。通过<code>hold on\off</code> 来控制是否保留，通过 <code>hold</code> 切换保留和不保留两种选择。</p>
<h3 id="图形窗口分割"><a href="#图形窗口分割" class="headerlink" title="图形窗口分割"></a>图形窗口分割</h3><ul>
<li><strong>子图</strong>：同一图形窗口中的不同坐标系下的图形称为子图。</li>
<li><strong>subplot函数</strong> ：<code>subplot(m,n,p)</code>  意思是将图形窗口分成 $m\times n$ 个子图区域，当前绘制的是第p个子图，区号按行编号。我们在一个图形窗口内，绘制不同的图可以采用不同的分割。</li>
</ul>
<h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><ul>
<li><p>绘制 $sinx$ 、$sin2x$ 、$sin(\frac{x}{2})$  的图像，并添加相应的图形标注。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">6</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">y=[<span class="built_in">sin</span>(x);<span class="built_in">sin</span>(<span class="number">2</span>*x);<span class="built_in">sin</span>(x./<span class="number">2</span>)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">6</span>*<span class="built_in">pi</span>,<span class="number">-1.1</span>,<span class="number">1.1</span>]);</span><br><span class="line">title(<span class="string">'不同频率正弦函数曲线'</span>);</span><br><span class="line">xlabel(<span class="string">'X-axis'</span>);</span><br><span class="line">ylabel(<span class="string">'Y-axis'</span>);</span><br><span class="line">text(<span class="number">2.5</span>,<span class="built_in">sin</span>(<span class="number">2.5</span>),<span class="string">'sin(x)'</span>);</span><br><span class="line">text(<span class="number">1.5</span>,<span class="built_in">sin</span>(<span class="number">3</span>),<span class="string">'sin(2*x)'</span>);</span><br><span class="line">text(<span class="number">5.5</span>,<span class="built_in">sin</span>(<span class="number">0.5</span>*<span class="number">5.5</span>),<span class="string">'sin(x/2)'</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'sin(x)'</span>,<span class="string">'sin(2x)'</span>,<span class="string">'sin(x/2)'</span>);</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/plot3.png" alt="plot3"></p>
<ul>
<li>利用子图函数在不同区域绘出不同图形。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">sin</span>(x));</span><br><span class="line">title(<span class="string">'sin(x)'</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">cos</span>(x));</span><br><span class="line">title(<span class="string">'cos(x)'</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">tan</span>(x));</span><br><span class="line">title(<span class="string">'tan(x)'</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">cot</span>(x));</span><br><span class="line">title(<span class="string">'cot(x)'</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-35</span>,<span class="number">35</span>]);</span><br></pre></td></tr></table></figure>

<p><img src="/images/plot4.png" alt="plot4"></p>
<hr>
<h2 id="4-3-其他形式的二维曲线"><a href="#4-3-其他形式的二维曲线" class="headerlink" title="4.3 其他形式的二维曲线"></a>4.3 其他形式的二维曲线</h2><h3 id="其他坐标系下的二维曲线图"><a href="#其他坐标系下的二维曲线图" class="headerlink" title="其他坐标系下的二维曲线图"></a>其他坐标系下的二维曲线图</h3><ul>
<li><p><strong>对数坐标图</strong></p>
<ul>
<li><strong>semilogx</strong> 函数：调用形式与plot函数类似，<code>semilogx(x,y,选项)</code>为其中一种调用格式，其他的可参考plot函数，此函数绘图采用半对数坐标，x轴采用常用对数刻度，y轴为线性刻度。</li>
<li><strong>semilogy</strong> 函数：调用形式与plot函数类似，<code>semilogy(x,y,选项)</code>为其中一种调用格式，其他的可参考plot函数，此函数绘图采用半对数坐标，y轴采用常用对数刻度，x轴为线性刻度。</li>
<li><strong>loglog</strong> 函数：调用函数与上述类似，x和y都为常用对数刻度。</li>
</ul>
</li>
<li><p><strong>极坐标图</strong></p>
<ul>
<li>基本调用格式：<code>polar(theta,rho,选项)</code> <strong>theta</strong>为极角，<strong>rho</strong> 为极径，选项与plot函数类似。</li>
</ul>
</li>
</ul>
<h3 id="统计图"><a href="#统计图" class="headerlink" title="统计图"></a>统计图</h3><ul>
<li><p><strong>条形类图形</strong></p>
<ul>
<li><p><strong>条形图</strong></p>
<ul>
<li><p><strong>bar</strong> 函数：绘制二维垂直条形图</p>
<ul>
<li>调用格式为<code>bar(y,style)</code> ：y如果为向量，则以每个元素值作为每一个柱的高度，元素下标代表横坐标。如果y为矩阵，则以每一行作为一组，以行号作为组号绘图。后方的 <strong>style</strong> 有 <code>&quot;grouped&quot;</code> 和<code>&quot;stacked&quot;</code> 两种模式，分别为簇状分组和堆积分组。默认为簇状分组。</li>
<li>调用格式为<code>bar(x,y,style)</code> ：其中x存储横坐标，y为矩阵，存储每一个横坐标对应的数据，y的行数必须与x的长度相对应。</li>
</ul>
</li>
<li><p><strong>barh</strong> 函数：绘制二维水平条形图。调用格式与<strong>bar</strong>函数相同。</p>
</li>
</ul>
</li>
<li><p><strong>直方图</strong></p>
<ul>
<li><p><strong>hist</strong> 函数：绘制直角坐标系下的直方图。</p>
<ul>
<li>调用格式为 <code>hist(y)</code> ，y为向量，绘图时将 $[miny,maxy]$ 区间等分成十组，并求出每个区间内对应元素的个数，然后绘出直方图。</li>
<li>调用格式为<code>hist(y,x)</code>，如果x为标量，则将y区间分成x个区间，如果x为向量，则向量中的每一个数指定分组的中心值，元素的个数为指定分成的组数，x缺省默认均分十组。</li>
</ul>
</li>
<li><p><strong>rose</strong> 函数：用于绘制极坐标系下的直方图。</p>
<ul>
<li>调用格式为 <code>rose(theta,x)</code> 其中参数 <strong>theta</strong> 用于确定每一数据与圆点的角度，如果x为标量，则x代表均分组数，缺省默认为20。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>面积类图形</strong></p>
<ul>
<li><strong>扇形图/饼图</strong><ul>
<li><strong>pie</strong> 函数：调用格式为 <code>pie(x,explode)</code> 其中参数x为待统计的数据，通常为向量，其中每一个数据在整体中占用的比例在扇形图中表示出来，后续的 <strong>explode</strong> 为每个x对应的分离参数，如果非0，则将其分离出来。<strong>explode</strong> 缺省则饼图为一个整体。</li>
</ul>
</li>
<li><strong>面积图</strong><ul>
<li><strong>area</strong> 函数：与plot函数类似，下方与坐标轴围成的区域进行填充。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>散点类图形</strong></p>
<ul>
<li><strong>散点图</strong><ul>
<li><strong>scatter</strong> 函数：<code>scatter(x,y,选项,&#39;filled&#39;)</code> ，其中x和y通常为同等大小向量，代表了一定数量的点。选项与plot函数类似，用于限制颜色，线型，以及数据点标记，如果采用数据点标记，则可以用 <strong>‘filled’</strong> 参数来填充数据点，如果缺省，则标记数据点为空心。</li>
</ul>
</li>
<li><strong>阶梯图</strong><ul>
<li><strong>stairs</strong> 函数：使用方法与上述 <strong>scatter</strong> 函数类似。</li>
</ul>
</li>
<li><strong>杆图</strong><ul>
<li><strong>stem</strong> 函数： 使用方法与上述 <strong>scatter</strong> 函数类似。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>矢量类图形</strong></p>
<ul>
<li><p><strong>箭头图</strong></p>
<ul>
<li><p><strong>quiver</strong> 函数：常用此绘制磁力线，矢量。调用格式为<code>quiver(x,y,u,v)</code> 其中 <strong>(x,y)</strong> 为矢量起</p>
<p>点，<strong>(u,v)</strong> 为矢量终点，如果x，y省略，则均匀取若干个点作为起点。</p>
</li>
</ul>
</li>
<li><p><strong>罗盘图</strong></p>
<ul>
<li><strong>compasser *<em>函数：与 *</em>plot</strong> 函数类似。</li>
</ul>
</li>
<li><p><strong>羽毛图</strong></p>
<ul>
<li><strong>feather</strong> 函数：与 <strong>plot</strong> 函数类似。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>专题三:MATLAB程序流程控制</title>
    <url>/2020/03/18/%E4%B8%93%E9%A2%98%E4%B8%89-MATLAB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="3-1-顺序结构程序"><a href="#3-1-顺序结构程序" class="headerlink" title="3.1 顺序结构程序"></a>3.1 顺序结构程序</h2><h3 id="程序设计的基本步骤"><a href="#程序设计的基本步骤" class="headerlink" title="程序设计的基本步骤"></a>程序设计的基本步骤</h3><p><img src="/images/step.png" alt="step"></p>
<a id="more"></a>

<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul>
<li>在matlab中程序文件扩展名为<strong>.m</strong> ，因此程序文件又叫 <strong>M文件</strong>。</li>
<li>程序文件分<strong>两种</strong><ul>
<li><strong>脚本文件</strong>：是可以在命令行窗口直接执行的文件，也叫命令文件。</li>
<li><strong>函数文件</strong>：定义一个函数，以函数调用方式来调用，不能单独执行。</li>
</ul>
</li>
</ul>
<h3 id="文件的建立"><a href="#文件的建立" class="headerlink" title="文件的建立"></a>文件的建立</h3><ul>
<li>可以在主页点击新建脚本，即可创建脚本文件，并且打开MATLAB编辑器。</li>
<li>在命令行窗口写 <code>edit test</code> 即可在当前文件下创建 <strong>test</strong> 脚本文件。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%利用脚本文件求两矩阵乘积</span></span><br><span class="line"><span class="comment">%脚本文件f1.m</span></span><br><span class="line">A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>];</span><br><span class="line">B=[<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">C=A*B;</span><br><span class="line"><span class="comment">%在命令行窗口运行脚本文件</span></span><br><span class="line">&gt;&gt; f1</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">22</span>    <span class="number">28</span></span><br><span class="line">    <span class="number">49</span>    <span class="number">64</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%利用函数文件求两矩阵乘积</span></span><br><span class="line"><span class="comment">%函数文件f1.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>=<span class="title">f2</span><span class="params">(A,B)</span></span></span><br><span class="line">C=A*B;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&gt;&gt; C=f1(A,B)</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">22</span>    <span class="number">28</span></span><br><span class="line">    <span class="number">49</span>    <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ul>
<li>数据的输入 ： <code>A=input(提示信息，参数选项)</code> ，输入时会将提示信息打印出来，后面的参数选项用于限定输入数据的类型等。</li>
<li>数据的输出： <code>disp(输出项)</code> </li>
<li>程序的暂停： <code>pause(延迟秒数)</code> ，<strong>如果延迟秒数省略，那么就会一直暂停直到用户下次动作</strong>。如果程序运行中要强行暂停可以通过 <strong>Ctrl+C</strong> 实现。</li>
</ul>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><ol>
<li><strong>通过脚本文件和函数文件求一个向量的四舍五入向量。</strong></li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">脚本</span><br><span class="line">A=[<span class="number">1.2</span>,<span class="number">3.4</span>,<span class="number">4.7</span>,<span class="number">0.5</span>];</span><br><span class="line">B=<span class="built_in">round</span>(A);</span><br><span class="line"><span class="built_in">disp</span>(B)</span><br><span class="line">函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>=<span class="title">f2</span><span class="params">(A)</span></span></span><br><span class="line">B=<span class="built_in">round</span>(A);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>求两点之间距离以及黄金分割点坐标（其中点坐标通过复数形式输入）。</strong></li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=input(<span class="string">'a='</span>);</span><br><span class="line">b=input(<span class="string">'b='</span>);</span><br><span class="line">c=a+<span class="number">0.618</span>*(b-a);</span><br><span class="line">s=<span class="built_in">abs</span>(b-a);</span><br><span class="line"><span class="built_in">disp</span>(s)</span><br><span class="line"><span class="built_in">disp</span>(c)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-2-用if语句实现选择结构"><a href="#3-2-用if语句实现选择结构" class="headerlink" title="3.2 用if语句实现选择结构"></a>3.2 用if语句实现选择结构</h2><h3 id="单分支if语句"><a href="#单分支if语句" class="headerlink" title="单分支if语句"></a>单分支if语句</h3><p>​    &nbsp;&nbsp;&nbsp;<strong>如果成立执行语句组，如果不成立则跳出if，语句格式如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件(关系运算或逻辑运算)</span><br><span class="line">   语句组</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="双分支if语句"><a href="#双分支if语句" class="headerlink" title="双分支if语句"></a>双分支if语句</h3><p>​    &nbsp;&nbsp;&nbsp;<strong>如果成立执行语句组1，不成立执行语句组2，然后跳出if，语句格式如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件(关系运算或逻辑运算)</span><br><span class="line">   语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="多分支if语句"><a href="#多分支if语句" class="headerlink" title="多分支if语句"></a>多分支if语句</h3><p>​    &nbsp;&nbsp;&nbsp;<strong>根据上述双分支的类推，依次判断条件1~n，成立则执行对应语句组，然后跳出if，不成立则往下寻找，语句格式如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span></span><br><span class="line">   语句组<span class="number">1</span></span><br><span class="line"><span class="keyword">elseif</span> 条件<span class="number">2</span></span><br><span class="line">   语句组<span class="number">2</span></span><br><span class="line"><span class="keyword">elseif</span> 条件<span class="number">3</span></span><br><span class="line">   语句组<span class="number">3</span></span><br><span class="line">···</span><br><span class="line"><span class="keyword">elseif</span> 条件n<span class="number">-1</span></span><br><span class="line">   语句组n<span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span> 语句组n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="条件成立的判断"><a href="#条件成立的判断" class="headerlink" title="条件成立的判断"></a>条件成立的判断</h3><ul>
<li>当条件结果为标量，非零表示真，零表示假。</li>
<li>当条件为矩阵，如果<strong>矩阵非空且不包含零元素</strong>，则条件成立，否则不成立。</li>
</ul>
<hr>
<h2 id="3-3-用switch语句实现选择结构"><a href="#3-3-用switch语句实现选择结构" class="headerlink" title="3.3 用switch语句实现选择结构"></a>3.3 用switch语句实现选择结构</h2><h3 id="switch语句的基本格式"><a href="#switch语句的基本格式" class="headerlink" title="switch语句的基本格式"></a>switch语句的基本格式</h3><p>​    &nbsp;&nbsp;&nbsp;表示在C++里面就不喜欢用switch，感觉太麻烦了。这个和多分支if有点像吧，只是他的区别在于首先给出一个表达式，在下方每一个语句组对应着一个结果表，如果结果表对应着表达式的值，就执行当前语句组，<strong>执行完之后跳出switch语句，这个和C++的有所区别。</strong>此外，如果都不满足的话，我们还可以加入一个条件<strong>otherwise</strong>，顾名思义，如果上述结果都不满足，就执行这个otherwise下对应的语句，switch的语句格式如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式</span><br><span class="line">  <span class="keyword">case</span> 结果表<span class="number">1</span></span><br><span class="line">     语句组<span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> 结果表<span class="number">2</span></span><br><span class="line">     语句组<span class="number">2</span></span><br><span class="line">···</span><br><span class="line">  <span class="keyword">case</span> 结果表n</span><br><span class="line">     语句组n</span><br><span class="line">  <span class="keyword">otherwise</span></span><br><span class="line">     语句组k</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="switch的使用规则"><a href="#switch的使用规则" class="headerlink" title="switch的使用规则"></a>switch的使用规则</h3><ul>
<li>case结果表为switch表达式的取值，<strong>当取值有多个时，我们可以用单元数据表示</strong>。将这多个结果用大括号<code>{}</code>括起来，如果表达式值满足其中一个，就执行相应语句组。</li>
</ul>
<hr>
<h2 id="用for语句实现循环结构"><a href="#用for语句实现循环结构" class="headerlink" title="用for语句实现循环结构"></a>用for语句实现循环结构</h2><h3 id="常用的for语句"><a href="#常用的for语句" class="headerlink" title="常用的for语句"></a>常用的for语句</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% for语句格式：</span></span><br><span class="line"><span class="keyword">for</span> 循环变量=表达式<span class="number">1</span>:表达式<span class="number">2</span>:表达式<span class="number">3</span></span><br><span class="line">    循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以发现循环变量后面对应的是一个冒号表达式，分别是起始，步长，终止。</li>
<li>循环执行时，先求出冒号表达式对应的行向量，然后依次遍历行向量中的每一个元素，执行循环体语句。</li>
<li>for语句针对向量每一个元素执行一次循环体，有几个元素执行几次，当冒号表达式对应的向量为空向量，则一次也不执行。</li>
<li>当退出循环后，循环变量值为行向量组中的最后一个元素。</li>
</ul>
<h3 id="更一般的for语句"><a href="#更一般的for语句" class="headerlink" title="更一般的for语句"></a>更一般的for语句</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=矩阵表达式</span><br><span class="line">	循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更一般的for语句循环遍历后对应的是矩阵表达式，执行过程中将矩阵的各列元素，赋值给循环变量，这时候，循环变量为一个列向量，而不是上述常用for语句中的标量，可以发现，常用的for语句是一般格式下的特例。<strong>循环的次数为矩阵的列数。</strong></li>
</ul>
<h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><p>计算圆周率 $\pi$</p>
<ul>
<li>利用循环求无穷级数展开求 $\pi$</li>
</ul>
<p>$$<br>1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}+\cdots+(-1)^{n+1}\frac{1}{2n-1} =\frac{\pi}{4}<br>$$</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">y=<span class="number">0</span>;</span><br><span class="line">g=<span class="number">-1</span>;</span><br><span class="line">n=input(<span class="string">'n='</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">	g=-g;</span><br><span class="line">	y=y+g*<span class="number">1</span>/(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="number">4</span>*y)</span><br></pre></td></tr></table></figure>

<ul>
<li>利用矩阵求和求无穷级数展开求 $\pi$ </li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">n=input(<span class="string">'n='</span>);</span><br><span class="line">x=<span class="number">1</span>:<span class="number">2</span>:(<span class="number">2</span>*n<span class="number">-1</span>);</span><br><span class="line">y=(<span class="number">-1</span>).^(<span class="number">2</span>:n+<span class="number">1</span>)./x;</span><br><span class="line"><span class="built_in">disp</span>(sum(y)*<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-5-用while语句实现循环结构"><a href="#3-5-用while语句实现循环结构" class="headerlink" title="3.5 用while语句实现循环结构"></a>3.5 用while语句实现循环结构</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>​    &nbsp;&nbsp;&nbsp;通过一个条件来判定是否执行循环体语句，当条件成立时，成立。不像是for循环先去设定循环多少次，循环变量依次取什么值，这个是根据条件限定，又叫<strong>条件循环语句</strong>。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件</span><br><span class="line">     循环体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h3><ul>
<li><strong>break语句</strong>：当循环执行到break语句会跳出当前循环，进行循环外的语句。</li>
<li><strong>continue语句</strong>：当循环执行到continue语句，会结束本次循环，进行下一次判断是否继续循环体。</li>
</ul>
<h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>​    &nbsp;&nbsp;&nbsp;如果一个循环结构循环体又包括循环结构，那么就称为<strong>循环嵌套</strong>or<strong>多重循环结构</strong>。通过嵌套的层数不同来不同的命名，例如二重循环，三重循环等等。</p>
<h3 id="例程-2"><a href="#例程-2" class="headerlink" title="例程"></a>例程</h3><ol>
<li><p>从键盘输入若干数，<strong>当输入0时结束输入</strong>，求这些数的和和他们的平均值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">msum=<span class="number">0</span>;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">x=input(<span class="string">'Enter your numbers: '</span>);</span><br><span class="line"><span class="keyword">while</span> x~=<span class="number">0</span></span><br><span class="line">    msum=msum+x;</span><br><span class="line">    cnt=cnt+<span class="number">1</span>;</span><br><span class="line">    x=input(<span class="string">'Enter your numbers: '</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> cnt&gt;<span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(msum);</span><br><span class="line">    <span class="built_in">disp</span>(msum/cnt);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用筛法求 <strong>1~m</strong> 范围内的素数。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">m=input(<span class="string">'m='</span>);</span><br><span class="line">p=<span class="number">1</span>:m;</span><br><span class="line">p(<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:<span class="built_in">sqrt</span>(m)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>*<span class="built_in">i</span>:<span class="built_in">i</span>:m</span><br><span class="line">		p(<span class="built_in">j</span>)=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">n=<span class="built_in">find</span>(p~=<span class="number">0</span>);</span><br><span class="line">p(n)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="3-6-函数文件的定义与调用"><a href="#3-6-函数文件的定义与调用" class="headerlink" title="3.6 函数文件的定义与调用"></a>3.6 函数文件的定义与调用</h2><h3 id="函数文件的基本结构"><a href="#函数文件的基本结构" class="headerlink" title="函数文件的基本结构"></a>函数文件的基本结构</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 输出参数表=函数名<span class="params">(输入形参表)</span></span></span><br><span class="line">注释说明部分</span><br><span class="line">函数体语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当有多个形参时，形参之间用 <code>,</code> 逗号分隔，组成形参表。当输出形参多于一个，用方括号 <code>[]</code> 括起来，形成输出矩阵。</li>
</ul>
<h3 id="函数使用中的一些规定"><a href="#函数使用中的一些规定" class="headerlink" title="函数使用中的一些规定"></a>函数使用中的一些规定</h3><ul>
<li><p>函数文件名通常由 <strong>函数名再加上拓展名.m</strong> 组成，函数文件名与函数名也可以不同，当两者不同时，MATLAB默认忽视函数名，调用时使用函数文件名。<strong>但一般我们将函数名和函数文件名进行统一</strong></p>
</li>
<li><p>如果函数文件中有 <strong>return</strong> 语句，就结束函数的执行，返回栈底。</p>
</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[输出实参表]=函数名(输入实参表)</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    &nbsp;&nbsp;&nbsp;MATLAB提供了一种特殊的函数，函数句柄变量相当于这个函数的别名，通过函数句柄可以间接的调用函数，多个参数之间用逗号分隔。</p>
<ul>
<li><p><strong>函数定义的基本格式如下</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">函数句柄变量 = @(匿名函数输入参数) 匿名函数表达式</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数调用的基本格式如下</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">函数句柄变量(匿名函数输入实参)</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊的，我们可以将一个已知的内部函数或者自定义函数，赋值给一个函数句柄变量，这样我们就可以通过函数句柄变量变量来简洁的调用函数。<strong>(类似于改个名字)</strong></p>
</li>
</ul>
<h3 id="例程-3"><a href="#例程-3" class="headerlink" title="例程"></a>例程</h3><ul>
<li><p>通过函数文件和匿名函数两个形式，求出 $x^2+y^2$ 的值。</p>
<ul>
<li>函数文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function z&#x3D;f2(x,y)</span><br><span class="line">    z&#x3D;x^2+y^2;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名函数</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f=@(x,y) x^<span class="number">2</span>+y^<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="3-7-函数的递归调用"><a href="#3-7-函数的递归调用" class="headerlink" title="3.7 函数的递归调用"></a>3.7 函数的递归调用</h2><h3 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h3><p>​    &nbsp;&nbsp;&nbsp;如果一个函数在函数体内部调用自己本身称为递归调用（如果是其他函数称为嵌套调用）。<strong>递归是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</strong></p>
<ul>
<li><strong>直接递归调用</strong>：在一个函数体内部直接调用自己本身。</li>
<li><strong>简介递归调用</strong>：在一个函数体内不嵌套调用其他函数，其他函数又调用自己。</li>
</ul>
<h3 id="例程-4"><a href="#例程-4" class="headerlink" title="例程"></a>例程</h3><ul>
<li>求 $n!=1\times2\times3\cdots \times n$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">fact</span><span class="params">(n)</span></span></span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">1</span></span><br><span class="line">   f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   f=fact(n<span class="number">-1</span>)*n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-8-函数参数与变量的作用域"><a href="#3-8-函数参数与变量的作用域" class="headerlink" title="3.8 函数参数与变量的作用域"></a>3.8 函数参数与变量的作用域</h2><h3 id="函数参数的可调性"><a href="#函数参数的可调性" class="headerlink" title="函数参数的可调性"></a>函数参数的可调性</h3><p>​    &nbsp;&nbsp;&nbsp;可调性顾名思义，就是可以调节的。MATLAB函数在调用过程中函数传递参数的数目是可以调节的。在调用时，函数有两个预定义变量，<strong>nargin</strong> 和 <strong>nargout</strong>  ，前者记录调用函数时输入实参的个数，后者记录调用函数时输出实参的个数。通过这两个变量，可以针对不同的变量个数进行不同的处理。</p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul>
<li>函数中定义的变量是局部变量，不能被其他函数引用</li>
<li>我们可以通过 <code>global 变量名</code> 来定义一个全局变量，如果不加 <strong>global</strong> ，默认是局部变量。</li>
<li>全局变量的作用域是整个MATLAB工作空间，全程有效，所有函数都可以对他进行存取和修改。</li>
<li>但是要注意的是，这里的全局变量使用方式和C++的有所区别，如果你要在函数中调用工作区中的全局变量，那么你需要在函数体内部定义相同的全局变量，这样才可以对其进行引用，函数体内部和工作区中的变量值是共享的。</li>
</ul>
<h3 id="例程-5"><a href="#例程-5" class="headerlink" title="例程"></a>例程</h3><ul>
<li>求 $x1\times x+y1\times y$ ，其中<strong>x1</strong> 和 <strong>y1</strong> 是全局工作区中全局变量的值。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%函数文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">solve</span><span class="params">(x,y)</span></span></span><br><span class="line"><span class="keyword">global</span> x1 y1</span><br><span class="line">f=x1*x+y1*y</span><br><span class="line"><span class="comment">%工作区</span></span><br><span class="line"><span class="keyword">global</span> x1 y1;</span><br><span class="line">x1=<span class="number">1</span>;</span><br><span class="line">y1=<span class="number">2</span>;</span><br><span class="line">s=solve(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>专题二:MATLAB矩阵处理</title>
    <url>/2020/03/15/%E4%B8%93%E9%A2%98%E4%BA%8C-MATLAB%E7%9F%A9%E9%98%B5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="2-1-特殊矩阵"><a href="#2-1-特殊矩阵" class="headerlink" title="2.1 特殊矩阵"></a>2.1 特殊矩阵</h2><h3 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h3><ul>
<li><p><strong>zeros函数</strong>： 产生全0矩阵，即零矩阵。</p>
</li>
<li><p><strong>ones函数</strong>：  产生全1函数，即幺矩阵。</p>
</li>
<li><p><strong>eye函数</strong>： 产生对角线为1的矩阵，当矩阵为方针时，为单位矩阵。</p>
</li>
<li><p><strong>rand函数</strong>： 产生 <strong>(0,1)</strong> 区间均匀分布的随机矩阵。</p>
</li>
<li><p>通过 <code>fix(a+(b-a+1)*rand(x))</code> 可产生[a,b]区间上均匀分布的随机整数。</p>
</li>
<li><p><strong>randn函数</strong>： n为normal的意思，产生均值为0，方差为1的标准正态分布随机矩阵。</p>
<ul>
<li>通过 $\mu+\sigma x$  来得到均值为 $\mu$ ，方差为 $\sigma{^2}$ 的随机数据。<strong>(高中数学知识，证明可百度)</strong></li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>对于上述函数的调用格式，我们都有如下规定，<code>zeros(m)</code>为产生 $m\times m$ 的零矩阵，<code>zeros(m,n)</code>为产生类型为 $m\times n$ 的零矩阵， <code>zeros(size(A))</code> 为产生和 <strong>A</strong> 同类型的零矩阵，其余函数和此类似。</li>
</ul>
<h3 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h3><ol>
<li><p><strong>魔方/幻方矩阵 (Magic Square)</strong></p>
<ul>
<li>n阶幻方矩阵每行，每列，主副对角线的和相等。</li>
<li>n阶幻方矩阵每行每列的元素之和为 $(1+2+3+\cdots+n^2)/n=(n+n^3)/2$</li>
</ul>
</li>
<li><p><strong>范德蒙矩阵 (Vandermonde)</strong></p>
<ul>
<li><p>利用 <strong>Vander(V)</strong> 生成以向量 V 为基础的<strong>范德蒙(Vandermonde)</strong>矩阵。</p>
<p><img src="/images/Vander.png" alt="Vander"></p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="built_in">vander</span>(<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">    <span class="number">16</span>     <span class="number">8</span>     <span class="number">4</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">    <span class="number">81</span>    <span class="number">27</span>     <span class="number">9</span>     <span class="number">3</span>     <span class="number">1</span></span><br><span class="line">   <span class="number">256</span>    <span class="number">64</span>    <span class="number">16</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">   <span class="number">625</span>   <span class="number">125</span>    <span class="number">25</span>     <span class="number">5</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>希尔伯特矩阵 (Hilbert)</strong> </p>
<ul>
<li>利用 <strong>hilb(n)</strong> 可以生成n阶希尔伯特矩阵。</li>
</ul>
<p><img src="/images/Hilbert.png" alt="Hilbert"></p>
</li>
<li><p><strong>伴随矩阵</strong>  </p>
<ul>
<li><p>通过 <strong>compan(p)</strong> 可以生成向量p对应的多项式的伴随矩阵。<strong>p向量中高次系数在前，低次系数在后。</strong>(我感觉我学过伴随矩阵，但看了之后又感觉没学过QAQ)</p>
<p><img src="/images/Company.png" alt="Company"></p>
</li>
</ul>
</li>
<li><p><strong>帕斯卡矩阵</strong></p>
<ul>
<li>通过 <strong>pascal(n)</strong> 生成一个n阶帕斯卡矩阵。</li>
</ul>
<p><img src="/images/Pascal1.png" alt="Pascal"></p>
<p><img src="/images/Pascal2.png" alt="Pascal"></p>
</li>
</ol>
<hr>
<h2 id="2-2-矩阵变换"><a href="#2-2-矩阵变换" class="headerlink" title="2.2 矩阵变换"></a>2.2 矩阵变换</h2><h3 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h3><ul>
<li>对角矩阵：只有对角线上有非0元素的矩阵是对角矩阵。如果对角线上元素相等，则称为数量矩阵。当对角线上元素相等且为1，称为单位矩阵。</li>
<li>提取矩阵的对角线元素<ul>
<li><strong>diag(A):</strong> 提取矩阵A主对角线元素，产生一个列向量。</li>
<li><strong>diag(A,k):</strong> 提取矩阵A第k条对角线元素，产生一个列向量。主对角线为第0条，往上依次为1，2···n，往下依次为-1，-2 ··· -n。</li>
</ul>
</li>
<li>构造对角矩阵<ul>
<li><strong>diag(V):</strong> 以向量V为主对角线元素，产生对角矩阵。</li>
<li><strong>diag(V,k):</strong> 以向量V为第k条对角线元素，产生对角矩阵。</li>
</ul>
</li>
</ul>
<h3 id="三角阵"><a href="#三角阵" class="headerlink" title="三角阵"></a>三角阵</h3><ul>
<li>矩阵对角线以上元素全为0为上三角矩阵，以下全为0为下三角矩阵。</li>
<li>上，下三角矩阵 <strong>(上 up，下 low)</strong>，关于下三角的只需要把 <strong>triu</strong> 换为 <strong>tril</strong><ul>
<li><strong>triu(A):</strong> 提取矩阵A的主对角线及以上的元素。</li>
<li><strong>triu(A,k):</strong> 提取矩阵A的第k条对角线及以上的元素。</li>
</ul>
</li>
</ul>
<h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><ul>
<li>普通转置运算符为 <code>.&#39;</code> ，共轭转置为 <code>&#39;</code> ，它在转置的基础上还会求每个数的复共轭。</li>
</ul>
<h3 id="矩阵的旋转"><a href="#矩阵的旋转" class="headerlink" title="矩阵的旋转"></a>矩阵的旋转</h3><ul>
<li><strong>rot90(A,k):</strong> 将矩阵A逆时针方向旋转 $90^{\circ}$ 的k倍，当k为1时可以省略。</li>
</ul>
<h3 id="矩阵的翻转"><a href="#矩阵的翻转" class="headerlink" title="矩阵的翻转"></a>矩阵的翻转</h3><ul>
<li><strong>fliplr(A):</strong>  对矩阵A实施左右翻转。</li>
<li><strong>flipud(A):</strong>  对矩阵A进行上下反转。</li>
</ul>
<h3 id="矩阵的求逆"><a href="#矩阵的求逆" class="headerlink" title="矩阵的求逆"></a>矩阵的求逆</h3><ul>
<li><strong>inv(A):</strong> 求A的逆阵。 </li>
</ul>
<h3 id="矩阵的阶梯状"><a href="#矩阵的阶梯状" class="headerlink" title="矩阵的阶梯状"></a>矩阵的阶梯状</h3><ul>
<li><strong>rref(A):</strong>  将矩阵A化为阶梯状（具体不再解释，不懂可百度）</li>
</ul>
<hr>
<h2 id="2-3-矩阵求值"><a href="#2-3-矩阵求值" class="headerlink" title="2.3 矩阵求值"></a>2.3 矩阵求值</h2><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><ul>
<li>通过 <strong>det(A)</strong> 可以求A矩阵的行列式值。</li>
</ul>
<h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><ul>
<li>通过 <strong>rank(A)</strong> 可以求A矩阵的秩。</li>
</ul>
<h3 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h3><ul>
<li>矩阵的迹等于对角线元素之和，也等于特征值之和。通过 <strong>trace(A)</strong> 可以求A矩阵的迹。</li>
</ul>
<h3 id="向量和矩阵的范数"><a href="#向量和矩阵的范数" class="headerlink" title="向量和矩阵的范数"></a>向量和矩阵的范数</h3><ul>
<li><p>范数用来度量矩阵或向量在某种意义下的长度。</p>
</li>
<li><p>向量的范数</p>
<ul>
<li>向量 1-范数 : 为向量元素的绝对值之和。通过 <strong>norm(V,1)计算V的1-范数</strong>  </li>
</ul>
<p>$$<br>||V||{_1}=\sum\limits^n_{i=1}|v_i|<br>$$</p>
</li>
</ul>
<ul>
<li><p>向量 2-范数 : 为向量元素绝对值的平方和的平方根。通过<strong>norm(V)或者norm(V,2)计算向量V的2-范数</strong></p>
<p>$$<br>||V||_2=\sqrt{\sum\limits^n_{i=1}|v_i|^2}<br>$$</p>
</li>
</ul>
<ul>
<li><p>向量 ∞-范数 : 所有向量元素绝对值中的最大值。通过<strong>norm(V,inf)计算向量V的∞-范数</strong></p>
<p>$$<br>||V||_{\infty}=\mathop{max}\limits_{0&lt;=i&lt;=n}{|v_i|}<br>$$</p>
</li>
</ul>
<ul>
<li><p>矩阵的范数<strong>（对不起我实在不想写latex了，直接截图了）</strong></p>
<ul>
<li>矩阵的范数求法和向量的一样一样滴</li>
</ul>
<p><img src="/images/fanshu.png" alt="fanshu"></p>
</li>
</ul>
<h3 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h3><ul>
<li>用于描述矩阵性能的数，等于矩阵的范数乘逆阵的范数，条件数约接近一，矩阵性能越好。</li>
<li>通过 <strong>cond(A,1)</strong> ，<strong>cond(A)或cond(A,2) ，cond(A,inf)</strong> 分别求矩阵A三种范数下的条件数。</li>
</ul>
<hr>
<h2 id="2-4-矩阵的特征值与特征向量"><a href="#2-4-矩阵的特征值与特征向量" class="headerlink" title="2.4 矩阵的特征值与特征向量"></a>2.4 矩阵的特征值与特征向量</h2><h3 id="求矩阵的特征值"><a href="#求矩阵的特征值" class="headerlink" title="求矩阵的特征值"></a>求矩阵的特征值</h3><ul>
<li><strong>E=eig(A)</strong> ：求矩阵A的全部特征值，构成向量E。</li>
<li><strong>[X,D]=eig(A)</strong> ：求矩阵A的全部特征值，构成对角阵D，并产生矩阵X，X各列为相应特征值对应的特征向量。</li>
</ul>
<h3 id="特征值的几何意义"><a href="#特征值的几何意义" class="headerlink" title="特征值的几何意义"></a>特征值的几何意义</h3><p>​    这里没太听懂，回头来补，咕咕咕QAQ。 </p>
<hr>
<h2 id="2-5-稀疏矩阵"><a href="#2-5-稀疏矩阵" class="headerlink" title="2.5 稀疏矩阵"></a>2.5 稀疏矩阵</h2><p>​    <strong>稀疏矩阵就是零元素个数远远大于非0元素个数的矩阵</strong>。</p>
<h3 id="矩阵的存储方式"><a href="#矩阵的存储方式" class="headerlink" title="矩阵的存储方式"></a>矩阵的存储方式</h3><ul>
<li><strong>完全存储方式</strong>：把所以元素按列依次存储</li>
<li><strong>稀疏存储方式</strong>：只存储非0元素的行列下标和数值，不改变存储顺序，依次按列存储。</li>
</ul>
<h3 id="稀疏存储方式的产生"><a href="#稀疏存储方式的产生" class="headerlink" title="稀疏存储方式的产生"></a>稀疏存储方式的产生</h3><ul>
<li><p>完全存储方式与稀疏存储方式的转化</p>
<ul>
<li>通过 <strong>A=sparse(S)</strong> 可以将矩阵S转化为稀疏存储方式的矩阵A</li>
<li>通过 <strong>S=full(A)</strong> 可以将矩阵A转化为完全存储方式的矩阵S。 </li>
</ul>
</li>
<li><p>直接建立稀疏存储矩阵</p>
<ul>
<li><p><strong>sparse(m,n)</strong> 可以建立一个 $m\times n$ 的所有元素都为0的稀疏矩阵。</p>
</li>
<li><p><strong>sparse(u,v,S)</strong>  其中u，v，S为3个等长向量，分别表示行下标，列下标，非零元素。</p>
</li>
<li><p><strong>B=spconvert(A)</strong> ，A是一个 $m\times 3$ 或 $m\times4$ 的矩阵，每一行元素依次表示一个稀疏矩阵的非零元素，从1~4列分别为，行下标，列下标，元素实部，元素虚部，若元素为实数，则第四列省略。</p>
</li>
</ul>
</li>
<li><p>单位矩阵的稀疏存储</p>
<ul>
<li><strong>speye(m,n)</strong> 可返回一个 $m\times n$ 的稀疏存储单位矩阵。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>专题一:MATLAB基础知识</title>
    <url>/2020/03/14/%E4%B8%93%E9%A2%98%E4%B8%80-MATLAB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1-1-MATLAB系统环境"><a href="#1-1-MATLAB系统环境" class="headerlink" title="1.1 MATLAB系统环境"></a>1.1 MATLAB系统环境</h2><h3 id="MATLAB操作界面的组成"><a href="#MATLAB操作界面的组成" class="headerlink" title="MATLAB操作界面的组成"></a>MATLAB操作界面的组成</h3><ol>
<li><strong>MATLAB主窗口</strong></li>
<li><strong>命令行窗口</strong><ul>
<li>命令行窗口含有 <code>&gt;&gt;</code> 命令提示符，表示MATLAB处于准备状态，可以接受并执行命令，按下回车键后MATLAB会执行输入命令，并在后面显示执行结果</li>
<li>如果指令过长可以分行输入，在一行末尾写 <code>...</code> 并按下回车键，在下个命令行继续输入，<code>...</code>称为续行符。</li>
</ul>
</li>
<li><strong>当前文件夹窗口</strong><ul>
<li>在MATLAB编程过程中生成的文件自动存放在当前文件夹，我们可以通过cd命令(例如我们要进入E盘下的work文件夹，可以<code>cd e:\work</code>)或者选择文件工具栏中的文件夹来设置当前文件夹。</li>
</ul>
</li>
<li><strong>工作区窗口</strong><ul>
<li>可用于变量的显示和操作，可显示你当前创建的变量。并且可对其保存，修改，删除。</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h3 id="MATLAB的搜索路径"><a href="#MATLAB的搜索路径" class="headerlink" title="MATLAB的搜索路径"></a>MATLAB的搜索路径</h3><ul>
<li><strong>检索命令对象的顺序如下</strong></li>
</ul>
<p><img src="/images/search.png" alt="search"></p>
<ul>
<li><strong>设置文件搜索路径</strong><ul>
<li>用path命令设置文件搜索路径。例如： path{path,`e:\work`}</li>
<li>用对话框设置文件搜索路径。在MATLAB主窗口的主页中设置。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-2-MATLAB数值数据"><a href="#1-2-MATLAB数值数据" class="headerlink" title="1.2 MATLAB数值数据"></a>1.2 MATLAB数值数据</h2><h3 id="数值数据类型的分类"><a href="#数值数据类型的分类" class="headerlink" title="数值数据类型的分类"></a>数值数据类型的分类</h3><ul>
<li><p><strong>整型</strong></p>
<ul>
<li>无符号整数：含有8，16，32，64四种</li>
<li>带符号整数：含有8，16，32，64四种</li>
</ul>
<p>范围和C语言一样,通过<code>类型(数据)</code> 来进行强转。</p>
</li>
<li><p><strong>浮点型</strong></p>
<ul>
<li>单精度：占四字节</li>
<li>双精度：占八字节，数值数据默认为双精度</li>
</ul>
<p>通过single和double函数进行强转。</p>
</li>
<li><p><strong>复型</strong></p>
<ul>
<li><p>复型数据包括实部和虚部两部分，都默认为浮点型，虚数单位用<strong>i</strong>或<strong>j</strong>来表示。</p>
</li>
<li><p>通过read和imag函数来求复型数据的实部和虚部。</p>
</li>
</ul>
</li>
<li><p><strong>字符型</strong></p>
<ul>
<li><strong>字符在内部作为数字存储，而不会采用浮点格式存储。</strong></li>
</ul>
</li>
</ul>
<h3 id="数值数据的输出格式"><a href="#数值数据的输出格式" class="headerlink" title="数值数据的输出格式"></a>数值数据的输出格式</h3><ul>
<li>format命令的格式，使用方法 <code>format 格式符</code>，不带格式符的format会恢复默认格式。<strong>ps：format只影响数据的输出，不影响数据的存储和计算。</strong></li>
</ul>
<h3 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h3><ol>
<li><p><strong>函数的调用格式为</strong>： <strong>函数名(函数自变量的值)</strong></p>
<ul>
<li>函数自变量规定为矩阵变量，也可以为标量（为矩阵的特例）。</li>
<li>函数在运算时将函数逐项作用在每个元素上，最后运算出来是一个与自变量同类型矩阵。</li>
</ul>
</li>
<li><p><strong>常用函数的应用</strong></p>
<ul>
<li>三角函数有两类，例如sin和sind两种，前面是弧度制，后面是角度制，其余cos等类似。</li>
<li>abs函数可以求实数的绝对值、复数的模、字符串的ASCII码值。</li>
<li>用于取整的函数有fix，floor，ceil，round。分别为靠0取整，向下取整，向上取整，四舍五入取整。</li>
<li>判断是否为素数的函数isprime，是素数返回1，不是返回0。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x=[<span class="number">1</span>:<span class="number">100</span>];</span><br><span class="line">&gt;&gt; k=<span class="built_in">isprime</span>(x);</span><br><span class="line">&gt;&gt; k1=<span class="built_in">find</span>(k);</span><br><span class="line">&gt;&gt; p=x(k1)</span><br><span class="line"></span><br><span class="line">p =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> 至 <span class="number">16</span> 列</span><br><span class="line"></span><br><span class="line">     <span class="number">2</span>     <span class="number">3</span>     <span class="number">5</span>     <span class="number">7</span>    <span class="number">11</span>    <span class="number">13</span>    <span class="number">17</span>    <span class="number">19</span>    <span class="number">23</span>    <span class="number">29</span>    <span class="number">31</span>    <span class="number">37</span>    <span class="number">41</span>    <span class="number">43</span>    <span class="number">47</span>    <span class="number">53</span></span><br><span class="line"></span><br><span class="line">  <span class="number">17</span> 至 <span class="number">25</span> 列</span><br><span class="line"></span><br><span class="line">    <span class="number">59</span>    <span class="number">61</span>    <span class="number">67</span>    <span class="number">71</span>    <span class="number">73</span>    <span class="number">79</span>    <span class="number">83</span>    <span class="number">89</span>    <span class="number">97</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<h2 id="1-3-变量及其操作"><a href="#1-3-变量及其操作" class="headerlink" title="1.3 变量及其操作"></a>1.3 变量及其操作</h2><h3 id="变量与赋值语句"><a href="#变量与赋值语句" class="headerlink" title="变量与赋值语句"></a>变量与赋值语句</h3><ul>
<li>变量本质是一个内存单元的抽象，变量名以字母开头，后接数字、字母或下划线，最多63个字符。</li>
<li>变量名区分字母大小写(case sensitive)，<strong>标准函数名以及命令名必须用小写字母</strong>。</li>
<li>赋值语句有两种格式<ul>
<li>变量 = 表达式</li>
<li>表达式的值赋值MATLAB预定义变量ans</li>
</ul>
</li>
<li>如果赋值后不加分号，会显示变量的结果，如果加了分号，则不显示。</li>
</ul>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>预定义变量是系统自身定义的变量</p>
<ul>
<li><strong>ans</strong> 是默认赋值变量，命令行表达式值默认赋值给 <strong>ans</strong></li>
<li><strong>i</strong> 和 <strong>j</strong> 代表虚数单位</li>
<li><strong>pi</strong> 表示圆周率</li>
<li><strong>NaN</strong> 代表非数</li>
</ul>
<h3 id="变量的管理"><a href="#变量的管理" class="headerlink" title="变量的管理"></a>变量的管理</h3><ol>
<li><strong>变量的删除和修改</strong></li>
</ol>
<ul>
<li>在工作区进行变量的删除和修改<ul>
<li>通过 <strong>who</strong> 和 <strong>whose</strong> 命令来查看变量清单，前者只显示名称，后者显示各种信息</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>内存变量文件</strong></li>
</ol>
<ul>
<li>用于保存MATLAB工作区变量的文件交内存变量文件，扩展名为.mat，也叫MAT文件，是一种二进制文件。<ul>
<li>save命令：创建内存变量文件，load命令：载入内存变量文件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-4-MATLAB矩阵的表示"><a href="#1-4-MATLAB矩阵的表示" class="headerlink" title="1.4 MATLAB矩阵的表示"></a>1.4 MATLAB矩阵的表示</h2><h3 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h3><ul>
<li><p><strong>直接输入法建立矩阵</strong></p>
<p>将矩阵的元素用中括号<code>[]</code> 括起来，按行输入元素，同一行元素用逗号或者空格分隔，用分号换行。</p>
</li>
<li><p><strong>利用已有矩阵建立更大矩阵</strong></p>
<p>个人感觉类似于分块矩阵，例子如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">&gt;&gt; B=[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>;<span class="number">-4</span>,<span class="number">-5</span>,<span class="number">-6</span>;<span class="number">-7</span>,<span class="number">-8</span>,<span class="number">-9</span>];</span><br><span class="line">&gt;&gt; C=[A,B;B,A]</span><br><span class="line"></span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>    <span class="number">-1</span>    <span class="number">-2</span>    <span class="number">-3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span>    <span class="number">-4</span>    <span class="number">-5</span>    <span class="number">-6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>    <span class="number">-7</span>    <span class="number">-8</span>    <span class="number">-9</span></span><br><span class="line">    <span class="number">-1</span>    <span class="number">-2</span>    <span class="number">-3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">    <span class="number">-4</span>    <span class="number">-5</span>    <span class="number">-6</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">    <span class="number">-7</span>    <span class="number">-8</span>    <span class="number">-9</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用两个实矩阵矩阵通过矩阵的运算可以建立复数矩阵</strong>，<strong>要确保两个矩阵同类型</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; B=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;&gt; C=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&gt;&gt; D=B+<span class="built_in">i</span>*C</span><br><span class="line"></span><br><span class="line">D =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.0000</span> + <span class="number">7.0000</span><span class="built_in">i</span>   <span class="number">2.0000</span> + <span class="number">8.0000</span><span class="built_in">i</span>   <span class="number">3.0000</span> + <span class="number">9.0000</span><span class="built_in">i</span></span><br><span class="line">   <span class="number">4.0000</span> + <span class="number">1.0000</span><span class="built_in">i</span>   <span class="number">5.0000</span> + <span class="number">2.0000</span><span class="built_in">i</span>   <span class="number">6.0000</span> + <span class="number">3.0000</span><span class="built_in">i</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="冒号表达式"><a href="#冒号表达式" class="headerlink" title="冒号表达式"></a>冒号表达式</h3><ul>
<li><p><strong>通过冒号表达式可以产生行向量</strong></p>
<p>一般格式为<code>e1:e2:e3</code> 分别是初始值，步长，终止值。可以省略e2，省略时步长为默认为1。</p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; t=<span class="number">0</span>:<span class="number">1</span>:<span class="number">5</span></span><br><span class="line">t=</span><br><span class="line">	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span></span><br><span class="line">&gt;&gt; s=<span class="number">0</span>:<span class="number">5</span></span><br><span class="line">s</span><br><span class="line">	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>通过linspace函数产生行向量</strong></p>
<p>linspace(a,b,n) 代表首元素为a，末尾元素为b，产生n个元素，相应的，步长为(b-a)/(n-1)。当n可以省略，省略时默认n为100。</p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="built_in">pi</span>,<span class="number">5</span>)</span><br><span class="line">x=</span><br><span class="line">	<span class="number">0</span>    <span class="number">0.7854</span>    <span class="number">1.5708</span>    <span class="number">2.3562</span>    <span class="number">3.1416</span></span><br></pre></td></tr></table></figure>

<h3 id="结构矩阵和单元矩阵"><a href="#结构矩阵和单元矩阵" class="headerlink" title="结构矩阵和单元矩阵"></a>结构矩阵和单元矩阵</h3><ul>
<li><p><strong>结构矩阵</strong></p>
<ul>
<li><p>类似于C语言的结构体，把很多个数据写成一个结构体，矩阵里的每个元素个元素都是结构体变量。给对应元素赋值格式为 <strong>结构体元素.成员名=表达式</strong> 。我们应该注意到，当一个结构体内没有我们赋值的成员，那么他会自动扩充矩阵来满足你的要求。</p>
</li>
<li><p>我们可以通过 <code>s=struct(&#39;name&#39;,{&#39;next&#39;,&#39;what&#39;},&#39;sex&#39;,{&#39;male&#39;,&#39;unknow&#39;})</code> 来创建一个包含 <strong>name</strong> 和 <strong>sex</strong> 两个成员的结构体。</p>
</li>
</ul>
</li>
<li><p><strong>单元矩阵</strong></p>
<p>矩阵里的每个元素的类型可以不同，通过直接输入法建立，所有元素用大括号<code>{}</code>而不是中括号<code>[]</code></p>
</li>
</ul>
<hr>
<h2 id="1-5-矩阵元素的引用"><a href="#1-5-矩阵元素的引用" class="headerlink" title="1.5 矩阵元素的引用"></a>1.5 矩阵元素的引用</h2><h3 id="矩阵元素的引用方式"><a href="#矩阵元素的引用方式" class="headerlink" title="矩阵元素的引用方式"></a>矩阵元素的引用方式</h3><ol>
<li>通过下标来引用矩阵，例如A(3,2)表示A矩阵第三列第二个元素。如果我们引用的元素超出矩阵范围，那么会默认扩充矩阵至满足要求，拓展元素默认为0。</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;&gt; A(<span class="number">4</span>,<span class="number">5</span>)=<span class="number">10</span></span><br><span class="line">A=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line">	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line">	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>通过序号来引用，<strong>注意矩阵元素按列存储</strong>，依次存放第一列，第二列···最后一列。</p>
</li>
<li><p>矩阵元素的序号和下标可以通过 <code>sub2ind</code> 和 <code>ind2sub</code> 两个函数完成相互转化</p>
<ul>
<li><strong>sub2ind</strong> 函数：将矩阵中指定元素的行列下标转换成存储的序号，格式为<code>D=sub2ind(S,I,J)</code>，三个参数依次为<strong>行数和列数组成的二维向量(可以通过size函数获取)</strong>，<strong>转换矩阵元素的行下标</strong>，<strong>转换矩阵元素的列下标</strong>。如果I，J为矩阵的话，那么就说明要将对应的一个下标矩阵求对应序号。注意结合下例来进行理解，我们注意到A(1,1)的序号为1，A(2,1)的序号为2，那么就是给定下标矩阵的顺序来生产的这个序号矩阵，类型相同。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">A=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></span><br><span class="line">	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></span><br><span class="line">&gt;&gt; D=<span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">D=</span><br><span class="line">	<span class="number">1</span>	<span class="number">2</span></span><br><span class="line">	<span class="number">6</span>	<span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ind2sub</strong> 函数：将矩阵元素的序号转换成下标，格式为 <code>[I,J]=ind2sub(S,D)</code> ，S,D分别为<strong>行数和列数组成的二维向量(可以通过size函数获取)</strong>，<strong>要获取下标的元素的序号(可以是一个向量，标志要获取多个元素的下标)</strong> ，那么前方的 I和J就是对应的行下标和列下标，类似于一个 <strong>sub2ind</strong> 函数的逆用。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; [I,J]=<span class="built_in">ind2sub</span>([<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">I=</span><br><span class="line">	<span class="number">1</span>	<span class="number">3</span>	<span class="number">2</span></span><br><span class="line">J=</span><br><span class="line">	<span class="number">1</span>	<span class="number">1</span>	<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="利用冒号表达式获得子矩阵"><a href="#利用冒号表达式获得子矩阵" class="headerlink" title="利用冒号表达式获得子矩阵"></a>利用冒号表达式获得子矩阵</h3><ul>
<li>我们可以用冒号表达式作为矩阵的行或列下标，也可以用单个<code>:</code>来当行或列下标，这代表取遍全部行或列。<strong>end运算符：</strong> 表示某一维的末尾元素下标。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A(<span class="built_in">i</span>,:)	表示第<span class="built_in">i</span>行的全部元素</span><br><span class="line">A(:,<span class="built_in">j</span>)	表示第<span class="built_in">j</span>行的全部元素</span><br><span class="line">A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,<span class="built_in">j</span>:<span class="built_in">j</span>+m)	表示第<span class="built_in">i</span>~<span class="built_in">i</span>+m行和<span class="built_in">j</span>~<span class="built_in">j</span>+m列全部元素</span><br><span class="line">A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,:)	表示第<span class="built_in">i</span>~<span class="built_in">i</span>+m行全部元素</span><br><span class="line">A(<span class="number">1</span>:<span class="number">3</span>;<span class="number">1</span>:<span class="keyword">end</span>) 这代表取<span class="number">1</span>~<span class="number">3</span>行和<span class="number">1</span>~最后一列元素</span><br></pre></td></tr></table></figure>

<h3 id="利用空矩阵删除矩阵元素"><a href="#利用空矩阵删除矩阵元素" class="headerlink" title="利用空矩阵删除矩阵元素"></a>利用空矩阵删除矩阵元素</h3><ul>
<li>空矩阵就是不含任何元素的矩阵，例如<code>x=[]</code> 就建立了一个空矩阵x。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; C=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">&gt;&gt; C(:,<span class="number">1</span>:<span class="number">2</span>)=[]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">     <span class="number">6</span></span><br><span class="line">     <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h3><ul>
<li>通过reshape函数可以在矩阵元素个数不变的情况下改变矩阵形状，例如 <code>reshape(A,m,n)</code> 就是将A矩阵变成m行n列的矩阵，<strong>不改变矩阵元素的存储顺序，也就是依次按列存储，对应序号相同。</strong></li>
</ul>
<h3 id="特殊的约定"><a href="#特殊的约定" class="headerlink" title="特殊的约定"></a>特殊的约定</h3><ul>
<li>通过指令<code>A(:)</code> 可以将所有元素堆叠成一个列向量，不改变存储顺序。</li>
</ul>
<hr>
<h2 id="1-6-MATLAB基本运算"><a href="#1-6-MATLAB基本运算" class="headerlink" title="1.6  MATLAB基本运算"></a>1.6  MATLAB基本运算</h2><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><ol>
<li><p>基本算术运算：<strong>+(加)，-(减)，*(乘)，/(右除)，\(左除)，^(乘方)</strong></p>
<ul>
<li><strong>MATLAB的算数运算在矩阵意义下进行</strong>，单个数据运算是矩阵的特例。</li>
<li><strong>加减运算</strong><ul>
<li>两矩阵同型，对应元素相加减。<strong>不同型，发生错误。</strong></li>
<li><strong>一个标量可以和矩阵进行运算，这时把标量对全体矩阵元素进行操作。</strong></li>
</ul>
</li>
<li><strong>乘法运算</strong><ul>
<li>很明显必须满足矩阵乘的条件，也就是当<code>A*B</code>时必须满足A的行数等于B的列数，此时称A，B矩阵是可乘的，或称两矩阵维数和大小相容。<strong>不相容就会发生错误</strong> </li>
</ul>
</li>
<li><strong>除法运算</strong><ul>
<li>如果A是<strong>非奇异矩阵(A的行列式不为0) *<em>,则B/A等效于B\</em>inv(A)，A\B等效为inv(A)*B。</strong>inv(A)是指A的逆阵** 。</li>
</ul>
</li>
<li><strong>乘法运算</strong><ul>
<li>A矩阵的x次方可以表示成<strong>A^x</strong> ，要求A为<strong>方阵</strong>，x为<strong>标量</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>点运算</strong></p>
<ul>
<li><strong>点运算符</strong>：在相应算术运算符前面加.，有点乘，点右除，点左除，点乘方。</li>
<li><strong>点运算</strong>：两个同型矩阵对应元素进行相关运算。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A=[<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&gt;&gt; A^<span class="number">2</span>  </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">     <span class="number">7</span>    <span class="number">10</span></span><br><span class="line">    <span class="number">15</span>    <span class="number">22</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A.^<span class="number">2</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">9</span>    <span class="number">16</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul>
<li><strong>关系运算符： &lt; ，&lt;=，&gt;，&gt;=，==(等于)，~=(不等于)</strong> </li>
<li>两个比较量为<strong>标量</strong>，直接比较两个数大小，如果成立表达式值为1，否则为0。</li>
<li>如果两个矩阵是<strong>同型矩阵</strong>，对每两个对应元素进行比较，形成一个由0，1构成的同型矩阵。</li>
<li>如果一个是<strong>标量</strong>一个是<strong>矩阵</strong>，则用标量和每个矩阵元素比较，形成一个同型矩阵。</li>
</ul>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li>逻辑运算符： &amp;(与)，|(或)，~(非)。各自对应的运算法则和C语言类似，不再赘述。</li>
<li>标量，矩阵之间进行运算，对应规则和关系运算类似，不再赘述。</li>
</ul>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>​    算术运算优先级最高，逻辑运算优先级最低，但是逻辑非运算是单目运算符，优先级比双目运算符高。</p>
<hr>
<h2 id="1-7-字符串处理"><a href="#1-7-字符串处理" class="headerlink" title="1.7 字符串处理"></a>1.7 字符串处理</h2><h3 id="字符串的表达"><a href="#字符串的表达" class="headerlink" title="字符串的表达"></a>字符串的表达</h3><ul>
<li>用单引号括起来的字符序列就是字符串，MATLAB把他当成一个行向量。若字符串中含有单引号，则单引号字符要用两个单引号表示。</li>
<li>可以建立多行字符串，建立字符矩阵<strong>（注意每一行的字符串长度要相等）</strong>。和数值矩阵无异。</li>
</ul>
<h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><ul>
<li><p><strong>字符串的执行</strong></p>
<ul>
<li>通过<code>eval(s)</code> 函数可以执行字符串 <strong>s</strong> 对应的命令行命令。</li>
</ul>
</li>
<li><p><strong>字串与数值之间的转换</strong></p>
<ul>
<li><strong>abs</strong> 和 <strong>double</strong> 函数都可以获取字符串矩阵对应的<strong>ASCII码</strong>矩阵。</li>
<li><strong>char</strong> 函数可以把<strong>ASCII码</strong>矩阵转换成字符串矩阵。</li>
</ul>
</li>
<li><p><strong>字符串的比较</strong></p>
<ul>
<li><strong>关系运算符比较</strong>：两个等长字符串比较，两两对应字符比较，成立为1，不成立为0，得到是一个含0，1的行向量。</li>
<li><strong>字符串比较函数比较</strong><ul>
<li>strcmp(s1,s2)：比较s1和s2是否相等，返回值为一个标量，相等为0，不等为1。后缀加i表示比较时忽略大小写。</li>
<li>strncmp(s1,s2,n)：比较s1和s2前n个字符是否相等，返回值为一个标量。相等为0，不等为1。后缀加i表示比较时忽略大小写。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字符串的查找和替换</strong></p>
<ul>
<li>findstr(s1,s2)：返回短字符串在长字符串中的开始位置。如果出现多次，则返回一个行向量。</li>
<li>strrep(s1,s2,s3)：将s1中所有子字符串s2替换为s3。</li>
</ul>
</li>
<li><p><strong>数值转换为字符</strong></p>
<ul>
<li>通过 <strong>num2str</strong> 或 <strong>int2str</strong> 等函数可以将数字转换为字符</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MATLAB学习</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>树形dp例题</title>
    <url>/2020/02/20/%E6%A0%91%E5%BD%A2dp%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    &nbsp;&nbsp;&nbsp;学OI的时候就做过树形dp的题，不过那时候全在划水。看了看题解还不太懂就直接照着题解写了，现在再回来看还是不会QAQ，所以就再看看然后自己写了一遍。</p>
<a id="more"></a>

<br>

<h2 id="A-没有上司的舞会"><a href="#A-没有上司的舞会" class="headerlink" title="A. 没有上司的舞会"></a>A. <a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有 $N$ 个职员被邀请去参加公司的舞会，他们每个人对应着一个快乐指数 $h_i$ ，如果该职员来了就会为舞会增加$h_i$ 点快乐指数。这 $N$ 个职员之间有从属关系，也就是说他们的关系就像一棵以顶级上司为根的树，父结点就是子结点的直接上司。如果一个职员的<strong>直接</strong>上司来到了舞会，那么他本人就不会再来。问邀请哪些职员可获得最大的快乐指数，最大为多少。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;职员之间的关系是以树的形式给出的，所以先用链式前向星来存储数。存的时候我们用vis数组记录一下如何那个人有上司，就将他标记一下，最终没有标记的就是没有上司的，也就是顶级上司，也就是我们的根节点root。<br>​    &nbsp;&nbsp;&nbsp;树形dp，顾名思义，在树上进行dp，通过递归dfs，先算出子树的状态，再通过递归的回溯来合并。那么我们考虑一下设计状态，很明显一个人的状态有来和不来，两个情况。所以我们设计状态 $dp[i][0/1]$  来表示职员 <strong>i</strong> 来或者不来，我们用u来表示当前节点，用v来表示当前节点的子节点，那么状态转移如下：</p>
<ul>
<li><p>$dp[u][0]=max(dp[v][0],dp[v][1]) $ （上司u没有来，那么下属v可以来，也可以不来，选一个大的策略）</p>
</li>
<li><p>$dp[u][1]=dp[v][0]+h[u]$  （上司u来了，下属v肯定不来）</p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;最终的答案就是 $max(dp[root][0],dp[root][1])$ ，上司来和不来两种策略中的最大一种。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6005</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt,n,l,k,vis[maxn],root;</span><br><span class="line"><span class="keyword">int</span> r[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].next=head[l];</span><br><span class="line">	e[cnt].to=k;</span><br><span class="line">	head[l]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	dp[u][<span class="number">1</span>]=r[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">		dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">		dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;k);</span><br><span class="line">		add(k,l);</span><br><span class="line">		vis[l]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) root=i;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="B-战略游戏"><a href="#B-战略游戏" class="headerlink" title="B. 战略游戏"></a>B. <a href="https://www.luogu.com.cn/problem/P2016">战略游戏</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;小姜老师要建立一个树，树节点两两之间通过道路连接，他要在这些节点上放一些小人，每个小人可监管与该节点相连的道路，问最少放置多少小人可以监管所有道路。（数据保证0为根节点）</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个题跟上个题有点像，首先我们也是用链式前向星把树给存下来，不过这个题的输入跟上道题有点不一样，本质都是一样的。因为我们只需要dfs下去，然后向上回溯的时候合并，所以只需要存单向边即可。<br>​    &nbsp;&nbsp;&nbsp;对于一个节点我们也是有两种策略，选或者不选，那么我们也可以把状态写成  $dp[i][1/0]$ ，对应着 <strong>i</strong> 这个节点选或者不选，我们把当前节点看作u，子节点看作v，状态转移如下：</p>
<ul>
<li><p>$dp[u][1]+=\Sigma (dp[v][0],dp[v][1]) +1$ （u选了，v选不选都可以，加上自身的1）</p>
</li>
<li><p>$dp[u][0]+=\Sigma dp[v][1]$    （如果u没有选，那么v一定要选，才能监管到u的道路）</p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;很显然这个答案是  $min(dp[0][0],dp[0][1])$  </p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1505</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].next=head[u];</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">		dp[u][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">		dp[u][<span class="number">0</span>]+=dp[v][<span class="number">1</span>];</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;num);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">			add(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">min</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-二叉苹果树"><a href="#C-二叉苹果树" class="headerlink" title="C. 二叉苹果树"></a>C. <a href="https://www.luogu.com.cn/problem/P2015">二叉苹果树</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有一颗二叉苹果树，也就是说树枝如果分叉，一定是分二叉。苹果树有 $n$ 个节点，树根编号为 1 。每个树枝上都有一定数量的苹果，如果最终保留 $q$ 根树枝，问最多能够保留多少苹果。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个树形dp要比上面的还要难一些，因为我们的状态不能够只考虑是否保留当前的树枝了，因为保留当前树枝也会有很多种关于保留子树枝选择。看了题解大佬的说法是，可以定义成 $f[u][j]$ 来表示 u 的子树上保留 j 条边时所能获得最大的苹果数。所以我们考虑一下转移方程，首先我们能保留的最大边数是当前子树所具有的所有树枝，对于一个节点下的两个树枝，我们可以选择取，或者不取，那么这就类似于一个背包问题，对于一定的容量（一定量的树枝），我们取几个树枝才能获得最大的价值。但是我们注意，对于一个节点u，我们如果要取他的节点v，那么我们u-v之间这个树枝一定要保留，不然会不能取得v，这是一个隐藏的条件。<br>​    &nbsp;&nbsp;&nbsp;因此转移方程： $dp[u][i]=max(dp[u][i],dp[u][i-j-1]+dp[v][j]+w[u][v] $ ，$w[u][v]$为当前u-v树枝的苹果数。代码里面因为我懒得计算子树的树枝数了，所以就直接从最大的q来枚举了，就没考虑那么多，可能复杂度稍微高一点，但是高不到哪去其实QAQ…</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt,q;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++cnt].next=head[u];</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	e[cnt].w=w;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=q;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[u][j]=<span class="built_in">max</span>(dp[u][j],dp[u][j<span class="number">-1</span>-k]+dp[v][k]+e[i].w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		add(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="number">1</span>][q]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#620 (Div.2)</title>
    <url>/2020/02/19/Codeforces620/</url>
    <content><![CDATA[<h2 id="A-Two-Rabbits"><a href="#A-Two-Rabbits" class="headerlink" title="A. Two Rabbits"></a>A. <a href="https://codeforces.com/contest/1304/problem/A">Two Rabbits</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;两个兔子分别位于 $(x,0)$ 和 $(y,0)$  ，两个人对头蹦，前者往前蹦 $a$ ，后者往前蹦 $b$ ，问两人是否能恰好相遇。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;算一下两个人直接得距离 $s$ ，每次两者距离减少 $a+b$ ，看 $s$ 是否能被 $a+b$ 整除，如果可以就能够相遇。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> x,y,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">int</span> p=a+b;</span><br><span class="line">		<span class="keyword">int</span> f=y-x;</span><br><span class="line">		<span class="keyword">if</span>(f%p==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f/p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="B-Longest-Palindrome"><a href="#B-Longest-Palindrome" class="headerlink" title="B. Longest Palindrome"></a>B. <a href="https://codeforces.com/contest/1304/problem/B">Longest Palindrome</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出 $n$ 段长度为 $m$ 的字符串，从中挑选出一些组成最长的回文字串，输出这个回文子串的长度和内容，如果有多种情况输出一种即可。如果没有符合的，就输出0 。$(1\le n\le 100,1\le m\le 50)$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;因为这个数据规模非常小，所以 $O(n^2m)$ 也是可以接受的（说实话我不是很会算，大概是个差不多的式子），那么我们可以选择暴力匹配，用每个字符串去匹配后面的，如果是两个互为回文串，那么就把其中任何一个计入到sub字符串中，然后用一个 vis 数组来标记他们两个已经被使用过了，最终一个字符串匹配完后面所有的发现没有合适的，那么就考虑他自己是不是一个回文串，如果是一个回文串，单独标记它是放在中间。最后我们的sub是存放了一半回文串。<br>​    &nbsp;&nbsp;&nbsp;统计答案的时候，先将sub加到答案ans中，检查一下是否中间有合适的回文串，如果有的话也加到ans里面，最后讲sub逆序一下，加到ans里面。最终输出答案的时候，看一下ans是不是空串，如果是空串，就输出0，否则输出长度和ans。（string是真的好用！！！）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> ans,sub,mid;</span><br><span class="line"><span class="keyword">bool</span> ifmid;</span><br><span class="line"><span class="built_in">string</span> str[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(str[i][k]==str[j][m-k<span class="number">-1</span>]) </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i]=vis[j]=<span class="literal">true</span>;</span><br><span class="line">				sub+=str[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(str[i][j]!=str[i][m<span class="number">-1</span>-j])</span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				mid=str[i];</span><br><span class="line">				ifmid=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=sub;</span><br><span class="line">	reverse(sub.<span class="built_in">begin</span>(),sub.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span>(ifmid) ans+=mid;</span><br><span class="line">	ans+=sub;</span><br><span class="line">	<span class="keyword">if</span>(!ans.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans.length()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-Air-Conditioner"><a href="#C-Air-Conditioner" class="headerlink" title="C. Air Conditioner"></a>C. <a href="https://codeforces.com/contest/1304/problem/C">Air Conditioner</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;餐厅老板有一个空调，餐厅初始温度为 $m$ ，会陆续来 $n$ 个顾客。餐厅老板每分钟可以控制空调的温度+1，-1，或者是不变。这 $n$ 个顾客会按来的时间顺序给出，每个人有一个感到舒适的温度范围，如果空调的温度在这个范围里面，那么顾客就会满意。问餐厅老板是否可以达到让每个人都满意。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们先思考从餐厅开始到第一个客人来临的时候，假设第一个人来临的时间是 $t$ ，舒适区间为 $[l,r]$，那么我们可以很容易发现只要 $[l,r]$ 与 $[m-t,m+t]$  有交集，那么就是可以满足第一个客人条件。如果第二个和第一人的时间差为 $\Delta t$  ，那么这个时候要计算可达到的舒适区间就是在上次交集的区间上左右变化 $\Delta t$ ，为什么是交集呢。我一开始想错了。。一直写成并集，然后一直调不出来。但实际上不是这样的，我们可以理解为只有交集那部分才是符合上个顾客要求的，如果超出那个范围，就不能够满足上个顾客要求。所以挨个顾客扫一遍就行了。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q,n,m;</span><br><span class="line"><span class="keyword">int</span> last,l,h,t;</span><br><span class="line"><span class="keyword">int</span> nowl,nowr,delt;</span><br><span class="line"><span class="keyword">int</span> lef,righ;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		lef=righ=m;</span><br><span class="line">		last=<span class="number">0</span>;</span><br><span class="line">		flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;l,&amp;h);</span><br><span class="line">			delt=t-last;</span><br><span class="line">			nowl=lef-delt;</span><br><span class="line">			nowr=righ+delt;</span><br><span class="line">			last=t;</span><br><span class="line">			<span class="keyword">if</span>(nowl&gt;h||nowr&lt;l) flag=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				lef=<span class="built_in">max</span>(nowl,l);</span><br><span class="line">				righ=<span class="built_in">min</span>(nowr,h);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>dp练习</title>
    <url>/2020/02/18/dp%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="A-矩阵取数游戏"><a href="#A-矩阵取数游戏" class="headerlink" title="A. 矩阵取数游戏"></a>A. <a href="https://www.luogu.com.cn/problem/P1005">矩阵取数游戏</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个 $n\times m$ 的矩阵，其中每个元素为非负整数。每次你可以从每行的行首或行末取一个元素，得到的分数为当前元素的值 $a_{ij}\times 2^k$  ，$k$ 为当前是第几次取该行上的元素。 问最大得分为多少。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们发现，虽然答案问的是 $n$ 行，但是我们发现，不同行之间是不会相互影响的，我们只需要讨论一行的情况，然后对每行都处理一遍就可以了。<br>​    &nbsp;&nbsp;&nbsp;那么对于一行上的 $m$ 个元素，我们每一次取都有两种选择，一个是取行首，一个是取行尾。我们发现这是一个区间问题，对于区间 $[i,j]$ 的最优情况，我们可以从 $[i+1,j]$  和 $[i,j-1]$ 这两个的最优情况转移过来，因此我们可以定义 $f[i][j]$ 是从第 $i$ 个元素到第 $j$ 的元素得分的最大值，然后从上述两个状态转移过来。<br>​    &nbsp;&nbsp;&nbsp;还有一个问题就是我们的 $2^k$ 问题，我们考虑到大区间的最优值是从小区间转移来，也就是说小区间乘的指数高，大区间乘的指数低，我们又是从小区间推到大区间，转移一次就乘一次，最后肯定是大区间的少，小区间的多了。qwq因为这个题的次数可能很高，会爆long long，实在是不想写高精度，就用了__int128，第一次用，感觉还不错QAQ..</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">85</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">__int128 <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line">__int128 dp[maxn][maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(__int128 &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&lt;<span class="string">'0'</span>) ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">		ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">10</span>) out(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">read</span>(<span class="built_in">map</span>[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">1</span>;f&lt;=m;f++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[f][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=m;len++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+len<span class="number">-1</span>&lt;=m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> k=j+len<span class="number">-1</span>;</span><br><span class="line">				dp[j][k]=<span class="built_in">max</span>(dp[j+<span class="number">1</span>][k]*<span class="number">2</span>+<span class="built_in">map</span>[i][j]*<span class="number">2</span>,dp[j][k<span class="number">-1</span>]*<span class="number">2</span>+<span class="built_in">map</span>[i][k]*<span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=dp[<span class="number">1</span>][m];</span><br><span class="line">	&#125;</span><br><span class="line">	out(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="B-关路灯"><a href="#B-关路灯" class="headerlink" title="B. 关路灯"></a>B. <a href="https://www.luogu.com.cn/problem/P1220">关路灯</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;在一条街道上有 $n$ 个路灯开着，他们可以看作分布在 $x$ 轴上，每个路灯有一定的坐标，也就是代表他们的位置。每个路灯也有一定的功率 $x$ ，代表一秒钟消耗多少电能。姜大佬初始位置在 $c$  ，他每天早晨出来关掉路灯。它可以先关左边的也可以先关右边的，他的行走速率是 $1m/s$ ，问最少消耗多少电能能关掉所有路灯。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;又是一道区间dp的题，那么我们可以思考一下，首先小姜老师肯定不能跳着关路灯，也就是说这个区间内中间的路灯都被关闭了，他会关一个区间的左端点或者右端点，而不会关这个区间外面的。那么我们就可以枚举区间长度来解决这个问题，从小的枚举到大的。<br>​    &nbsp;&nbsp;&nbsp;那么我们思考一下如何定义这个状态。我们可以定义关闭区间 $[i,j]$ 的路灯，最少消耗电能为 $f[i][j]$ ，如果需要转移状态的话，我们想到，对于一个方向，小姜老师可以继续往前走，关掉前面那盏灯，也可以返回去，关闭它屁股后面那盏灯。因为是有两个方向的，所以我们可以拓宽一维，用 $f[i][j][0/1]$ 来表示小姜老师现在是在往左走还是往右走，那么很明显 $f[i][j][0]$ 这个状态可以从 $f[i+1][j][0/1]$  来转移分别对应着小姜老师继续往前走关眼前的，和返回关屁股后的。相应的 $f[i][j][1]$ 就可以从 $f[i][j-1][0/1]$ ，转移的时候再加上消耗的电能即可！</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> lt[maxn]; <span class="comment">//lantern pos</span></span><br><span class="line"><span class="keyword">int</span> en[maxn]; <span class="comment">//energy </span></span><br><span class="line"><span class="keyword">int</span> sum[maxn]; <span class="comment">//prefix sum</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum[n]-(sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++) dp[i][j][k]=inf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;lt[i],&amp;en[i]);</span><br><span class="line">		sum[i]=en[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[c][c][<span class="number">0</span>]=dp[c][c][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">			dp[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j][<span class="number">0</span>]+(lt[i+<span class="number">1</span>]-lt[i])*calc(i+<span class="number">1</span>,j),dp[i+<span class="number">1</span>][j][<span class="number">1</span>]+(lt[j]-lt[i])*calc(i+<span class="number">1</span>,j));</span><br><span class="line">			dp[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+(lt[j]-lt[i])*calc(i,j<span class="number">-1</span>),dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+(lt[j]-lt[j<span class="number">-1</span>])*calc(i,j<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">min</span>(dp[<span class="number">1</span>][n][<span class="number">0</span>],dp[<span class="number">1</span>][n][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-小a和uim之大逃离"><a href="#C-小a和uim之大逃离" class="headerlink" title="C. 小a和uim之大逃离"></a>C. <a href="https://www.luogu.com.cn/problem/P1373">小a和uim之大逃离</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个 $n\times m$ 的矩阵，每个格子中有 $0\sim k$ 滴魔液，小姜老师和它朋友可以从任意地点开始，一起向右或者向下走，他们每个人有一个容量为 $k$ 的瓶子，由小姜老师开始轮流收集地上的魔液，当收集魔液大于 $k$ 的时候，会对 $k+1$ 取模，问他们有多少种方法使得收集的魔液数量相同。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;很显然我们可以写一个5维dp，用 $f[i][j][p][l][0/1]$ 来表示，当到了坐标为 $(i,j)$ 的格子的时候，小姜老师拥有魔液 $p$ 滴，他的朋友拥有魔液 $l$ 滴，并且这一次是由小姜老师采集的/由他的朋友采集的。这样的话，感觉比较好些，但是。。空间占用非常的高，我们优化一下，因为问的是收集相等，所以只需要维护他们的差就可以了，也就是说，只需要将 $(p-l+k)\%k$ 维护一下就可以了，因此循环枚举坐标以及他们的差，从低的向高的转移就可以了。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">805</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][<span class="number">16</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	k++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">			dp[i][j][<span class="built_in">map</span>[i][j]%k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j][t%k][<span class="number">0</span>]+=dp[i<span class="number">-1</span>][j][(t-<span class="built_in">map</span>[i][j]+k)%k][<span class="number">1</span>];dp[i][j][t%k][<span class="number">0</span>]%=mod;</span><br><span class="line">				dp[i][j][t%k][<span class="number">0</span>]+=dp[i][j<span class="number">-1</span>][(t-<span class="built_in">map</span>[i][j]+k)%k][<span class="number">1</span>];dp[i][j][t%k][<span class="number">0</span>]%=mod;</span><br><span class="line">				dp[i][j][t%k][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][j][(t+<span class="built_in">map</span>[i][j])%k][<span class="number">0</span>];dp[i][j][t%k][<span class="number">1</span>]%=mod;</span><br><span class="line">				dp[i][j][t%k][<span class="number">1</span>]+=dp[i][j<span class="number">-1</span>][(t+<span class="built_in">map</span>[i][j])%k][<span class="number">0</span>];dp[i][j][t%k][<span class="number">1</span>]%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=dp[i][j][<span class="number">0</span>][<span class="number">1</span>]%mod;</span><br><span class="line">			ans%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>关于STL的一些总结</title>
    <url>/2020/02/16/STL%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    &nbsp;&nbsp;&nbsp;STL之前只会用 stack 和 queue ，set 和 map 啥的也不太会用。学习一下。</p>
<a id="more"></a>

<hr>
<h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;首先使用之前需要声明头文件 <code>#include&lt;queue&gt;</code> ，通过 <code>queue&lt;typename&gt; q</code> 的形式来进行定义队列，上述为定义了一个队列元素类型为 typename 的队列，队列名称为 q，typename可以为C++原有数据类型，例如int，char，string这些，也可以是自定义的结构体类型等。</p>
<h3 id="主要函数及用途"><a href="#主要函数及用途" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><p>​    &nbsp;&nbsp;&nbsp;使用下述函数都是用类似于 队列名称.函数名()  的形式，好比pop函数就是 q.pop()</p>
<blockquote>
<ol>
<li>push(x)   将元素x从队尾入队</li>
<li>front( ) &amp; back( )    分别为获取队首元素和队尾元素，使用的时候必须确保队列不为空</li>
<li>pop( )  弹出队首元素，使用的时候必须确保队列不为空</li>
<li>empty( )  判断队列是否为空，空返回true，不空返回false</li>
<li>size( ) 查询队列中有多少个元素</li>
</ol>
</blockquote>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.front()); <span class="comment">//</span></span><br><span class="line">	q.push(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.back());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">if</span>(q.empty()) <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"queue is not empty\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">if</span>(q.empty()) <span class="built_in">printf</span>(<span class="string">"queue is empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">queue is not empty</span></span><br><span class="line"><span class="comment">queue is empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<br>

<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;与队列相对应，是一种先进后出（FILO）的数据结构，限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;首先使用之前需要声明头文件 <code>#include&lt;stack&gt;</code> ，通过 <code>stack&lt;typename&gt; s</code> 的形式来进行定义栈，上述为定义了一个队列元素类型为 typename 的栈，栈名称为 s，typename可以为C++原有数据类型，例如int，char，string这些，也可以是自定义的结构体类型等。</p>
<h3 id="主要函数及用途-1"><a href="#主要函数及用途-1" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><p>​    使用下述函数都是用类似于 栈名称.函数名()  的形式，好比pop函数就是 s.pop()</p>
<blockquote>
<ol>
<li>push(x)  将元素x压栈</li>
<li>pop( )  将栈顶元素出栈，使用时确保栈不为空</li>
<li>top( ) 获取栈顶元素的值，使用时要确保栈不为空</li>
<li>size( ) 返回栈中元素的个数</li>
<li>empty( ) 查询栈是否为空，空返回true，不空返回false</li>
</ol>
</blockquote>
<h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s.push(<span class="number">1</span>);</span><br><span class="line">	s.push(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the top element is %d\n"</span>,s.top()); <span class="comment">//Now the top element is 2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the stack size is %d\n"</span>,s.<span class="built_in">size</span>()); <span class="comment">//Now the stack size is 2</span></span><br><span class="line">	<span class="keyword">if</span>(!s.empty()) s.pop(); <span class="comment">//元素2 弹出栈</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the top element is %d\n"</span>,s.top()); <span class="comment">//Now the top element is 1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the stack size is %d\n"</span>,s.<span class="built_in">size</span>()); <span class="comment">//Now the stack size is 1</span></span><br><span class="line">	<span class="keyword">if</span>(s.empty()) <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>); </span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"stack is not empty\n"</span>); <span class="comment">//stack is not empty</span></span><br><span class="line">	<span class="keyword">if</span>(!s.empty()) s.pop(); <span class="comment">//元素1 弹出栈</span></span><br><span class="line">	<span class="keyword">if</span>(s.empty()) <span class="built_in">printf</span>(<span class="string">"stack is empty\n"</span>); <span class="comment">//stack is empty</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"stack is not empty\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">Now the top element is 2</span></span><br><span class="line"><span class="comment">Now the stack size is 2</span></span><br><span class="line"><span class="comment">Now the top element is 1</span></span><br><span class="line"><span class="comment">Now the stack size is 1</span></span><br><span class="line"><span class="comment">stack is not empty</span></span><br><span class="line"><span class="comment">stack is empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<br>

<h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射(map)"></a>映射(map)</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;map是STL的一个关联容器，提供一对一的数据处理能力，可以建立两个数据之间一一映射关系，map的定义需要关键字和存储值两个参数，我们可以通过关键字来查找对应的存储值（感觉类似于下标可以为任何类型的数组）吧，因为map的底层实现为红黑树（虽然我没学过），所以具有自动排序功能，也就是说map内部有序。</p>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;使用之前声明头文件 <code>#include&lt;map&gt;</code> ，通过 <code>map&lt;typename,typename&gt; m</code>  的形式来定义映射，如果我们要建立string和int这两个类型之间的一一映射，就可以写成 <code>map&lt;string,int&gt; m</code> ，我们可以通过关键字string来查找对应的int值。下述的讲述我们用这个m这个映射来进行。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    &nbsp;&nbsp;&nbsp;迭代器就是类似于指针吧，我们可以通过<code>map&lt;string,int&gt;::iterator it</code> ，来定义一个对应映射的迭代器，他能够用来指向map中的元素，通过它们我们可以对map执行定点删除，遍历等操作。</p>
<h3 id="主要函数及用途-2"><a href="#主要函数及用途-2" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h4><ul>
<li>通过insert函数进行插入<ul>
<li><code>m.insert(pair&lt;string,int&gt;(&quot;zs&quot;,1))</code></li>
<li><code>m.insert(make_pair(&quot;zs&quot;,2))</code></li>
</ul>
</li>
<li>通过类似于数组的形式插入<ul>
<li><code>m[&quot;zs&quot;] = 2</code></li>
</ul>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;上述两种形式有一定的区别，因为集合中元素是唯一的，用insert函数插入的时候，如果已经有相应的关键字，那么就不会插入。而如果用类似于数组的方式进行插入，就会覆盖原关键字对应的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"zs"</span>,<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,m[<span class="string">"zs"</span>]);</span><br><span class="line">	m.insert(make_pair(<span class="string">"zs"</span>,<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,m[<span class="string">"zs"</span>]);</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,m[<span class="string">"zs"</span>]);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果  1 1 2 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-查找数据"><a href="#2-查找数据" class="headerlink" title="2. 查找数据"></a>2. 查找数据</h4><p>​    &nbsp;&nbsp;&nbsp;通过find函数来查找关键字在map中的位置，如果找到了的话就返回对应的迭代器，如果没有找到的话就返回尾部的迭代器（end函数返回的值）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">1</span>;</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果 zs 1 </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h4><ul>
<li>清空map，可以使用clear函数。</li>
<li>删除特定元素<ul>
<li>先用find函数找到特定元素的迭代器，通过erase函数清除。</li>
<li>直接通过相应关键字清除。</li>
</ul>
</li>
<li>删除一串序列，通过erase(起始迭代器，终点迭代器) 来实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">1</span>;</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	m.erase(it);</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	<span class="keyword">if</span>(it==m.<span class="built_in">end</span>())</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Not find zs\n"</span>);</span><br><span class="line">	m[<span class="string">"zs"</span>]=<span class="number">2</span>;</span><br><span class="line">	m.erase(<span class="string">"zs"</span>);</span><br><span class="line">	it=m.<span class="built_in">find</span>(<span class="string">"zs"</span>);</span><br><span class="line">	<span class="keyword">if</span>(it==m.<span class="built_in">end</span>())</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Not find zs"</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果 Not find zs </span></span><br><span class="line"><span class="comment">		    Not find zs</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h4><blockquote>
<ol>
<li>count(“关键字”)  查询相应关键字在map中是否出现过，出现过返回1，没出现返回0</li>
<li>empty( )  判断是否为空，空返回true，不空返回false</li>
<li>begin( ) &amp; end( ) 分别为返回头和尾迭代器，配合迭代器可实行遍历</li>
<li>iterator-&gt;first &amp; iterator-&gt;second 分别对应相应迭代器指向的元素的关键字和值</li>
</ol>
</blockquote>
<hr>
<br>

<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>​    &nbsp;&nbsp;&nbsp;set为一个容器，用来存储同一数据类型的数据，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一（集合的唯一性），并且内部能根据元素的值自动进行排序。</p>
<h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h3><p>​    &nbsp;&nbsp;&nbsp;使用之前需要声明头文件 <code>#include&lt;set&gt;</code> ，通过 <code>set&lt;typename&gt; s</code> 来定义一个存储数据类型为typename的集合，名字叫做s。下述实例用此做基础。</p>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    &nbsp;&nbsp;&nbsp;通过<code>set&lt;typename&gt;::iterator it</code>，可以来定义一个相应的set的迭代器，用来遍历和指向其中元素。</p>
<h3 id="主要函数及用途-3"><a href="#主要函数及用途-3" class="headerlink" title="主要函数及用途"></a>主要函数及用途</h3><h4 id="1-插入数据-1"><a href="#1-插入数据-1" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h4><ul>
<li>插入特定元素可以通过 <code>s.insert(3)</code> 插入对应键值，返回值为pair&lt;set<int>::iterator,bool&gt; ，后续bool变量标志是否成功，如果元素3已经存在，那么bool值为false，迭代器对应的是该元素在其中的位置，如果元素不存在其中，返回true，并且返回的迭代器对应的在集合中位置</int></li>
<li>插入一个区间的元素，例如有整数数组a ，可以用 <code>s.insert(a,a+3)</code> ，可以将a中的 a[0] a[1] a[2] 插入到set中。</li>
</ul>
<h4 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2. 删除数据"></a>2. 删除数据</h4><p>​    &nbsp;&nbsp;&nbsp;删除和map非常像，也是三种。具体可参考map讲解。</p>
<h4 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h4><p>​    &nbsp;&nbsp;&nbsp;也是可以通过find函数，也是和map非常的像~</p>
<h4 id="4-其他-1"><a href="#4-其他-1" class="headerlink" title="4. 其他"></a>4. 其他</h4><blockquote>
<ol>
<li>begin() &amp; end( ) 返回头尾迭代器，注意尾迭代器是尾元素的后一位。</li>
<li>clear( ) 清除set容器中所有元素</li>
<li>empty( ) 判断set容器是否为空，为空则返回true，不空返回false</li>
<li>size( ) 返回当前set容器中元素的个数</li>
<li>rebegin( ) &amp; rend( ) 返回尾和头迭代器，配合reverse_iterator可以反序遍历set</li>
</ol>
</blockquote>
<hr>
<h2 id="关于vector和string等"><a href="#关于vector和string等" class="headerlink" title="关于vector和string等"></a>关于vector和string等</h2><ul>
<li><p>vector好的学习文章 ： <a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector容器浅析</a></p>
</li>
<li><p>string好的学习文章  ： <a href="https://www.cnblogs.com/fzxiaoyi/p/12083144.html">C++ STL(一)介绍及string</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题训练</title>
    <url>/2020/02/15/%E6%9D%82%E9%A2%98%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h2 id="A-配对"><a href="#A-配对" class="headerlink" title="A. 配对"></a>A. <a href="https://ac.nowcoder.com/acm/contest/3007/A">配对</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定含有 $n$ 个正整数的集合 $A$ 和 $B$ ，你需要建立他们之间的一一映射。将配对的两个数相加可以得到 $n$ 个和，问第 $k$ 大的和最大为多少。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先我们可以确定，组成前 $k$ 个最大的和一定用的是两个序列里面前 $k$ 大的数字。那么我们只需要知道如何配对能使第 $k$ 大的和最大。我们把问题简化一下如果 $A_1 &lt; A_2$ ，$B_1 &lt; B_2$  ，那么如果想要第二个和最大，肯定是需要 $A_1$ 和 $B_2$ 匹配，$A_2$ 和 $B_1$  匹配，然后两个选一个最小的。所以这个问题我们类推一下，就是将 $A$ 和 $B$ 序列进行排序，然后取两个里面前 $k$ 个数，$A$ 中大的依次匹配 $B$ 中小的。然后在这 $k$  个和中取一个最小值即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k,ans=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,a[i]+b[k-i+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="B-十字阵列"><a href="#B-十字阵列" class="headerlink" title="B. 十字阵列"></a>B. <a href="https://ac.nowcoder.com/acm/contest/3007/F">十字阵列</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个 $n\times m$ 的网格，每一个交点都一个敌人。你可以使用共 $h$ 次魔法，第 $i$ 次魔法能对第 $x_i$ 行和第 $y_i$  列的所有敌人造成 $w_i$ 点伤害，交界点的伤害只计算一次。。如果施放完所有所有魔法后，如果一个点 $(i,j)$ 共受到 $z_i$ 点伤害，问 $\sum{z_i(i+j)}$ 为多少。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;无脑的计数题QAQ..真的是水题啊，我们只需要给每次魔法施放的 $w_i$ 乘上一个 $(i,j)$ 即可，但是因为是一行一列都会变化，那么其实我们可以优化一下，先把一行一列的 $\sum(i+j)$ 给求出来，然后施法的时候直接乘上这个常数就可以了。（这个题还有个很神奇的地方就是，我明明算的不会爆int然后开的int，然后就错了，后来一直找问题没找出来，后来全改成long long就AC了，太奇怪了。。）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll row[maxn];</span><br><span class="line">ll col[maxn];</span><br><span class="line">ll x,y,z;</span><br><span class="line">ll n,m,h;</span><br><span class="line">ll ans,now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;h);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		row[i]=(m*i)%mod+(m)*(m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		row[i]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		col[j]=(n*j)%mod+(n)*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		col[j]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		now=((row[x]+col[y]-(x+y))%mod)*(z%mod);</span><br><span class="line">		now%=mod;</span><br><span class="line">		ans+=now;</span><br><span class="line">		ans%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-垃圾陷阱"><a href="#C-垃圾陷阱" class="headerlink" title="C. 垃圾陷阱"></a>C. <a href="https://www.luogu.com.cn/problem/P1156">垃圾陷阱</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;奶牛卡门想要从垃圾井底上到地面，对于一个垃圾它可以吃掉，或者是堆起来。初始卡门有10个小时的能量，吃掉一个垃圾会给他提供 $f_i$ 个小时的能量，叠起来一个垃圾会获得 $h_i$ 点高度，当垃圾总高度超过井的深度 $D$ 的时候，卡门就能上到地面。一个垃圾当 $t_i$ 小时时会到达井底。给出所有垃圾的状态，问奶牛能否到达地面。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    <del>&nbsp;&nbsp;&nbsp;这个题面被我翻译的屎一样，QAQ，如果看不懂还是去看原题叭。。</del><br>​    &nbsp;&nbsp;&nbsp;这是一个类似于背包的题，对于一个垃圾，我们有两种选择，一个是吃掉它，一个是把他堆起来。。这个状态其实我没找好，看了题解发现可以设 $f[i][j]$ 来表示当用了前 $i$ 个垃圾时，当高度为 $j$  的时候的最大的体力值（体力值就是还能继续活动多长时间）。我们用结构体数组 $a$ 来表示垃圾，写出如下转移方程。 </p>
<ul>
<li><p>如果选择把这个垃圾吃掉，那么 $f[i][j]=max(f[i-1][j]+a[i].f,f[i][j])$ </p>
</li>
<li><p>如果选择把这个垃圾搭起来，那么$f[i][j+a[i].h]=max(f[i-1][j+a[i].h],f[i-1][j])$ </p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;我们发现边界就是 $f[0][0]=10$ ，也就是用了0个垃圾，高度为0的时候体力值为10。</p>
<p>​    &nbsp;&nbsp;&nbsp;注意一个地方我们如果到达了地面，就直接输出时间，然后退出程序即可，如果没有的话，我们可以选择遍历每一个垃圾下的 $0$ 高度，也就是说所有垃圾都不叠是最长的寿命，所以输出一个其中的最大值即可。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t,f,h;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.t&lt;b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d,g;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn]; <span class="comment">//dp[i][j] 用i个垃圾，当高度为j时所具备的最高生命值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">"test.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;d,&amp;g);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i].t,&amp;a[i].f,&amp;a[i].h); </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+g,cmp);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=d;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]&gt;=a[i].t)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j+a[i].h&gt;=d)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i].t);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j]+a[i].f,dp[i][j]);</span><br><span class="line">				dp[i][j+a[i].h]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j+a[i].h],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=g;i++) ans=<span class="built_in">max</span>(ans,dp[i][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#619(Div.2)</title>
    <url>/2020/02/14/Codeforces/</url>
    <content><![CDATA[<h2 id="A-Three-Strings"><a href="#A-Three-Strings" class="headerlink" title="A. Three Strings"></a>A. <a href="https://codeforces.com/contest/1301/problem/A">Three Strings</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定三个长度为 $n$ 的字符串 $a$ , $b$ , $c$ ，遍历每个 $c$ 中每个字符 $c_i$，可以将其替换成 $a_i$ 或者 $b_i$ ，必须操作其中一个，问能否通过此操作使得字符串 $a$ , $b$ 相同。 </p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;仔细思考一下，如果要使得最终两个字符串相同的话，必须字符串 $c$ 中出现的字符，在 $a$ 或者 $b$ 字符串出现过，如果每个位置都出现过，那么就是可以的，否则不行。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(c);</span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="keyword">if</span>(c[i]!=a[i]&amp;&amp;c[i]!=b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="B-Motarack’s-Birthday"><a href="#B-Motarack’s-Birthday" class="headerlink" title="B. Motarack’s Birthday"></a>B. <a href="https://codeforces.com/contest/1301/problem/B">Motarack’s Birthday</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个含有 $n$ 个整数的序列 $a$ ，其中有一些数丢失，问将丢失的数赋值为多少才能使得相邻两数之差的绝对值的最大值的最小。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;我们想一下首先不缺失的数相邻两数之差是一定，无论赋值前后都不影响。而如果两个相邻的数都缺失的话，那么他们之间差的绝对值一定是0，也不用去看。这样的话我们就看一下，不缺失和缺失两数之间差的绝对值如何能够最小。因为最终所有的缺失的数都是赋值为同一个数，所以我们考虑一下发现需要考虑一下 缺失和不缺失的数相邻的时候，不缺失的那个数的最大值和最小值，我们只需要取他们的和的平均，那么绝对值就可以最小了。所以最终我们就把缺失的值赋为两数均值，然后求一遍相邻数之差绝对值的最大值就好了。（好像这道题难点不是思路，而是实现起来有很多边界等乱七八糟的要自习考虑一下。）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> minn,maxx,ans,anss;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		minn=inf,maxx=-inf,anss=-inf;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;a[i]==<span class="number">-1</span>&amp;&amp;a[i<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				minn=<span class="built_in">min</span>(minn,a[i<span class="number">-1</span>]);</span><br><span class="line">				maxx=<span class="built_in">max</span>(maxx,a[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;n&amp;&amp;a[i]==<span class="number">-1</span>&amp;&amp;a[i+<span class="number">1</span>]!=<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					minn=<span class="built_in">min</span>(minn,a[i+<span class="number">1</span>]);</span><br><span class="line">					maxx=<span class="built_in">max</span>(maxx,a[i+<span class="number">1</span>]);</span><br><span class="line">				&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		ans=(minn+maxx)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==<span class="number">-1</span>) a[i]=ans;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>) anss=<span class="built_in">max</span>(anss,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,anss,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-Ayoub’s-function"><a href="#C-Ayoub’s-function" class="headerlink" title="C. Ayoub’s function"></a>C. <a href="https://codeforces.com/contest/1301/problem/C">Ayoub’s function</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给定一个01字符串 $s$ ，其中含有 $m$ 个1，用 $f(s)$ 来表示字符串 $s$ 的有多少个字串其中含有1，求出符合条件的字符串 $s$ 中， $f(s)$ 的最大值是多少。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这题正着想不太好想，含有1的子串可以有很多种情况，但是正难则反，我们可以求出不含1的字串有多少情况，也就是全0的字串有多少种情况，然后用所有情况减去这个就行。<br>​    &nbsp;&nbsp;&nbsp;首先可以发现字符串 $s$ 一共有  $\binom{n}{2}+n$  种连续子串，那么如果一些0是连续的，那么好比有连续 $l$ 个0的话，我们可以发现他是有  $\binom{l}{2}+l$  种情况的。这个字符串一共是含有 $n-m$ 个0的，现在我们思考一下如何摆放这 $(n-m)$ 个0，才能使得  $f(s)$ 最大。那么如果 $f(s)$ 要尽量大，也就是说全0对应的情况就要尽可能的少，所以我们需要将这 $n-m$ 尽可能的均分成 $m+1$  份，类似于排列组合的插空法，将他们插到其中，但是我们发现有很大的可能是不能均分的，也就是说可能会有余数，那么我们就把余数均匀的分给前面余数个空，这样其实每个多贡献了 $(n-m)/(m+1) +1 $ 个。所以答案也就不难写出来了。不过不要忘了开long long。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n,m;</span><br><span class="line">ll t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">		ll sum=n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		ll p=n-m;</span><br><span class="line">		ll mod=p%(m+<span class="number">1</span>);</span><br><span class="line">		ll k=p/(m+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum-(m+<span class="number">1</span>)*k*(k+<span class="number">1</span>)/<span class="number">2</span>-(k+<span class="number">1</span>)*mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>日常水题</title>
    <url>/2020/02/13/%E6%97%A5%E5%B8%B8%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    &nbsp;&nbsp;&nbsp;今天又是颓废的一天，被大佬拉去跟他一起做牛客网的题，QAQ…那我会点啥嘛，就只能替大佬写两道水题了···</p>
<a id="more"></a> 

<br>

<h2 id="A-牛牛战队的比赛地"><a href="#A-牛牛战队的比赛地" class="headerlink" title="A. 牛牛战队的比赛地"></a>A. <a href="https://ac.nowcoder.com/acm/contest/3006">牛牛战队的比赛地</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标 $(x,y)$ 。<br>​    &nbsp;&nbsp;&nbsp;这周末，牛牛队又要出去比赛了，各个比赛的赛点都在 $x$ 轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。请你求出选择的比赛地距离各训练基地最大距离的最小值。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个题首先一看到这种什么最大的最小，第一直觉就是二分。首先我们想一下应该二分什么，肯定先想的是枚举 $x$ 轴上的点，但是这样就会有个问题，二分要用的话必须是单调的，那么我们不能够确定越往右或者越往左，他们的这个值是单调的。因此我们可以用三分，一直向单峰逼近，最终寻找到那个极值点。（说实话这是我第一次接触到三分法，我太菜了。）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;p[maxn]; <span class="comment">//point</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">double</span> lmid,rmid,lans,rans;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> dis=(p[i].x-x)*(p[i].x-x)+p[i].y*p[i].y;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,dis);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> l=<span class="number">-10000</span>,r=<span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">9999999999</span>;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;=eps)</span><br><span class="line">	&#123;</span><br><span class="line">		lmid=(r+l)/<span class="number">2</span>;</span><br><span class="line">		rmid=(r+lmid)/<span class="number">2</span>;</span><br><span class="line">		lans=check(lmid);</span><br><span class="line">		rans=check(rmid);</span><br><span class="line">		<span class="keyword">if</span>(lans&lt;rans)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,lans);</span><br><span class="line">			r=rmid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,rans);</span><br><span class="line">			l=lmid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf"</span>,<span class="built_in">sqrt</span>(ans));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="B-牛牛与牛妹的约会"><a href="#B-牛牛与牛妹的约会" class="headerlink" title="B. 牛牛与牛妹的约会"></a>B. <a href="https://ac.nowcoder.com/acm/contest/3006/D">牛牛与牛妹的约会</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;你想从 $(a,0)$ 点到 $(b,0)$ 点，你可以除了可以以 $1m/s$ 的速度奔跑，还可以用1秒的时间来引导闪现，这将使你从 $(x,0)$ 点闪现到 $(\sqrt[3]{x},0)$ 点，问最少需要多长时间到达 $(b,0)$ 点。$(Ps:a,b \in[-10^6,10^6])$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;一道贪心的题目，当闪现所能贡献的距离大于 $1m$ ，那么我就选择用闪现，不然就直接奔跑。那么我们可以用距离的变化来体现闪现贡献的距离，一直用闪现到不能用之后，就直接加上最后剩下的距离即可。注意pow这个函数有点坑？如果底数是负数并且指数不是整数的话好像会返回很奇怪的值···（跟大佬调了好长时间都卡在这了）</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,x,y;</span><br><span class="line"><span class="keyword">double</span> ans,a,b;</span><br><span class="line"><span class="keyword">double</span> dis,cdis;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		a =(<span class="keyword">double</span>)x;</span><br><span class="line">		b=(<span class="keyword">double</span>)y;</span><br><span class="line">		dis = <span class="built_in">abs</span>(a-b);</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cdis=<span class="built_in">abs</span>(-<span class="built_in">pow</span>(-a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cdis = <span class="built_in">abs</span>(<span class="built_in">pow</span>(a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(dis-cdis&gt;<span class="number">1.0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a=-<span class="built_in">pow</span>(-a,<span class="number">1.0</span>/<span class="number">3.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> a=<span class="built_in">pow</span>(a,<span class="number">1.0</span>/<span class="number">3.0</span>);</span><br><span class="line">			ans+=<span class="number">1</span>;</span><br><span class="line">			dis = cdis;</span><br><span class="line">			<span class="keyword">if</span>(a&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cdis = <span class="built_in">abs</span>(-<span class="built_in">pow</span>(-a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> cdis = <span class="built_in">abs</span>(<span class="built_in">pow</span>(a,<span class="number">1.0</span>/<span class="number">3.0</span>)-b);</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=dis;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-碎碎念"><a href="#C-碎碎念" class="headerlink" title="C. 碎碎念"></a>C. <a href="https://ac.nowcoder.com/acm/contest/3006/F">碎碎念</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;大佬豪和弱鸡战合作做题，如果大佬豪AC掉题目，那么弱鸡战会说 “宁好强啊！”，如果大佬豪WA掉了题目，那么弱鸡战会嘲讽大佬豪 $k$ 句 “宁好弱啊！” 。我们规定大佬豪提交只有AC和WA两种状态。因为大佬豪非常的强，如果一道题他WA掉了一发，那么他的下一发一定会AC。如果已知最终弱鸡战嘲讽了 $x$ 句，那么很明显可以对应很多的提交序列。现在想问你如果弱鸡战嘲讽数在 $[l,r]$ 这个区间，一共会有多少种提交序列。答案对 $1e9+7$ 取模。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;首先原始题面不是这样，我把名字改了一下，QAQ…<br>​    &nbsp;&nbsp;&nbsp;QAQ刷了这么多天的dp好像终于有点作用了，我终于看出来这是一道dp题了，还找对了他们的状态，不过转移方程却写错了。那么首先我们可以用 $f[i]$ 来表示，如果说了 $i$ 句话，那么一共有多少种可能的序列，但是这样的话我们发现没法确保上文上的如果WA掉了，下一发一定是AC。<br>​    &nbsp;&nbsp;&nbsp;所以我们可以考虑加一维状态来表示是通过哪种提交状态到达第 $i$ 句话的，也就是写成 $dp[0/1][i]$ 这个状态，$dp[0][i]$ 代表是从 $i-1$ 句话直接AC转移过来的，$dp[1][i]$ 是从 $i-k$ 句话通过WA转移过来的。所以这样的话转移方程就可以写出来了。</p>
<ul>
<li><p>$dp[0][i] = dp[0][i-1]+dp[1][i-1]$  （可以从WA和AC转移过来）</p>
</li>
<li><p>$dp[1][i]=dp[0][i-k]$ （只能从第 $i-k$ 状态是AC的时候转移，不能连续两次WA） </p>
</li>
</ul>
<p>​    &nbsp;&nbsp;&nbsp;因为最终是一个区间查询，那么我们可以用前缀和来优化。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> k,q;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;q);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+dp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">		dp[<span class="number">0</span>][i]%=mod;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[<span class="number">1</span>][i]=dp[<span class="number">0</span>][i-k];</span><br><span class="line">			dp[<span class="number">1</span>][i]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i]=dp[<span class="number">0</span>][i]+dp[<span class="number">1</span>][i];</span><br><span class="line">		ans[i]%=mod; </span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+ans[i];</span><br><span class="line">		sum[i]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(sum[r]-sum[l<span class="number">-1</span>]+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="D-牛牛战队的秀场"><a href="#D-牛牛战队的秀场" class="headerlink" title="D. 牛牛战队的秀场"></a>D. <a href="https://ac.nowcoder.com/acm/contest/3006/J">牛牛战队的秀场</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;在半径为 $r$ 的圆内有一个正接 $n$ 边形，随便选取一个顶点编号为 $1$ ，顺时针编号为 $2\sim n$ ，规定只能沿多边形边走，问从顶点 $i$ 到顶点 $j$ 最短路径为多少。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;很显然只有两条路可以走，我们只需要算出正多边形的每条边的边长，然后比较两条路径的大小，哪一个短就走哪一个就行，不过如果用了<code>cos()</code> 函数记得特判一下 $n=4$ 的情况，不然会发生错误。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ri;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.1415926535898</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;ri);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);</span><br><span class="line">	<span class="keyword">double</span> k=(<span class="keyword">double</span>)<span class="number">2</span>*pi/(<span class="keyword">double</span>)n;</span><br><span class="line">	<span class="keyword">double</span> s;</span><br><span class="line">	r=(<span class="keyword">double</span>)ri;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=<span class="built_in">sqrt</span>(<span class="number">2</span>*r*r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> s=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)<span class="number">2</span>*r*r<span class="number">-2.0</span>*r*r*<span class="built_in">cos</span>(k));</span><br><span class="line">	<span class="keyword">int</span> p=<span class="built_in">abs</span>(i-j);</span><br><span class="line">	<span class="keyword">if</span>(p&gt;n/<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lf"</span>,s*(n-p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lf"</span>,s*p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>dp习题练习</title>
    <url>/2020/02/12/dp%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h2 id="A-方格取数"><a href="#A-方格取数" class="headerlink" title="A. 方格取数"></a>A. <a href="https://www.luogu.com.cn/problem/P1004">方格取数</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;有一个 $N*N$ 的整数方阵，每个点初始值为0，在一些点上放上数，一个人从左上角走到右下角，规定只能向下或向右走，当他经过的点上有数时会取走它，问走两遍最多能取的数的和最大为多少。</p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;也就是说我们要找两条路径使他取数最大，首先我一开始想法是先走一遍，找到最大的那个路径，将这条路径上所有点设为0，然后再回来找这个方阵中最大的那个路径，两个加起来就行。但是路径上所有的点设为0这个地方不是很好实现，因此我们可以考虑另一个思路，两次同时走。我们把这两次看成两个人走的，表述方便。<br>​    &nbsp;&nbsp;&nbsp;我们用 $dp[i][j][k][l]$ 来表示当第一个人走到 $(i,j)$  第二个人走到 $(k,l)$ 时做能取数最多为多少 ，那么我们就可以考虑一下转移怎么转移，因为到达一个点只能是从左边来，或者是从上边来，因此第一个人从 $(i-1,j)$ 或者 $(i,j-1)$ 转移来，那么第二个人就从 $(k-1,l)$ 或者 $(k,l-1)$ 转移来，那么这个转移方程就是四种转移方式。我们需要保证一个问题，就是他俩经过同一个点的判定情况。我们需要将第二个人的坐标通过第一个人来限制，也就是说要确保第二个人和第一个人步数是相同的，当他们步数相同的时候，那么就不存在他们经过同一个点但是时间却是不同的情况了，因为到达一个点的步数是一定的。<br>​    &nbsp;&nbsp;&nbsp;再就是这个状态数组其实还是可以压缩到三维和二维的，这个就先不谈了，可以看洛谷的题解区。<br>​    &nbsp;&nbsp;&nbsp;这个题是一个经典的多维dp的题目，感觉还是挺有意义的。而且这个题和 <a href="https://www.luogu.com.cn/problem/P1006">传纸条</a> 很像，可以双倍经验。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,x,y,z;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">map</span>[x][y]=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				m=i+j-k;</span><br><span class="line">				<span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(i==k&amp;&amp;j==m) dp[i][j][k][m]=<span class="built_in">max</span>(<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][m],dp[i<span class="number">-1</span>][j][k][m<span class="number">-1</span>]),<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][m],dp[i][j<span class="number">-1</span>][k][m<span class="number">-1</span>]))+<span class="built_in">map</span>[i][j];</span><br><span class="line">				<span class="keyword">else</span> dp[i][j][k][m]=<span class="built_in">max</span>(<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][m],dp[i<span class="number">-1</span>][j][k][m<span class="number">-1</span>]),<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][m],dp[i][j<span class="number">-1</span>][k][m<span class="number">-1</span>]))+<span class="built_in">map</span>[i][j]+<span class="built_in">map</span>[k][m];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[n][n][n][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br> 

<h2 id="B-创意吃鱼法"><a href="#B-创意吃鱼法" class="headerlink" title="B. 创意吃鱼法"></a>B. <a href="https://www.luogu.com.cn/problem/P1736">创意吃鱼法</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出一个 $N*M$ 的只包含0和1的数阵，求只有对角线为1，其余位置为0的子方阵的最大边长。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这个题我们需要考虑两个方向，这个对角线既可以是斜向左上，也可以是斜向右上的。我们先考虑前者，后者同理即可。我们可以用两个数组 $col[i][j]$ 和 $row[i][j]$ 分别来表示，包含 $(i,j)$ 这个点往上一列有多少个0，以及包含这个点往左一行有多少个0，（这个在程序里好像我写反了，但是没啥区别说实话）。然后我们用 $f[i][j]$ 来表示，从这个点左上走满足条件的方阵的最大边长。那么很显然这个值和上方的0，左方的0，以及左上的状态有关，这个点是1的话，转移方程就是 $f[i][j]=min(f[i-1][j-1],min(col[i-1][j],row[i][j-1]))+1$ 。如果是0的话我们就更新 $col$ 和 $row$ 数组的值。然后求完斜向左上的再求一遍斜向右上的，取一个最大值即可。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2505</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> col[maxn][maxn],row[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">map</span>[i][j])</span><br><span class="line">		&#123;</span><br><span class="line">			row[i][j]=row[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">			col[i][j]=col[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">min</span>(row[i<span class="number">-1</span>][j],col[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">			ans=<span class="built_in">max</span>(dp[i][j],ans);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(row,<span class="number">0</span>,<span class="keyword">sizeof</span>(row));</span><br><span class="line">	<span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">map</span>[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">				row[i][j]=row[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">				col[i][j]=col[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>],<span class="built_in">min</span>(row[i<span class="number">-1</span>][j],col[i][j+<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">				ans=<span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="C-乌龟棋"><a href="#C-乌龟棋" class="headerlink" title="C. 乌龟棋"></a>C. <a href="https://www.luogu.com.cn/problem/P1541">乌龟棋</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出标号分别为1，2，3，4的四种卡片若干张，分别可以移动1，2，3，4步，玩家初始处于坐标为1的位置。玩家出一张牌，可移动相应的步数。移动到不同的坐标会加不同的分数，很明显不同的出牌顺序会对应着不同的分数，求玩家能获得的最大分数为多少。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;很显然我们可以通过已经出的牌计算出现在已经到达到哪个位置。我们可以用一个四重循环，来循环每张牌用的数量，很明显我们到达一个目标位置所用的最后一张牌可以是1，2，3，4的任何一个，因此我们可以从这个四个状态转移过来，找其中最大那个就可以了，注意要判断一下要转移过来的状态是否合法。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">355</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">125</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,pos;</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> x,num[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">42</span>][<span class="number">42</span>][<span class="number">42</span>][<span class="number">42</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		num[x]++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=w[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=num[<span class="number">1</span>];a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;=num[<span class="number">2</span>];b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=num[<span class="number">3</span>];c++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=num[<span class="number">4</span>];d++)</span><br><span class="line">				&#123;</span><br><span class="line">					pos=<span class="number">1</span>+a+(b&lt;&lt;<span class="number">1</span>)+c*<span class="number">3</span>+(d&lt;&lt;<span class="number">2</span>);</span><br><span class="line">					<span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;dp[a<span class="number">-1</span>][b][c][d]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a<span class="number">-1</span>][b][c][d]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(b&gt;<span class="number">0</span>&amp;&amp;dp[a][b<span class="number">-1</span>][c][d]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b<span class="number">-1</span>][c][d]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(c&gt;<span class="number">0</span>&amp;&amp;dp[a][b][c<span class="number">-1</span>][d]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c<span class="number">-1</span>][d]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(d&gt;<span class="number">0</span>&amp;&amp;dp[a][b][c][d<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[a][b][c][d]=<span class="built_in">max</span>(dp[a][b][c][d],dp[a][b][c][d<span class="number">-1</span>]+w[pos]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[num[<span class="number">1</span>]][num[<span class="number">2</span>]][num[<span class="number">3</span>]][num[<span class="number">4</span>]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="D-能量项链"><a href="#D-能量项链" class="headerlink" title="D. 能量项链"></a>D. <a href="https://www.luogu.com.cn/problem/P1063">能量项链</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp;&nbsp;&nbsp;给出一段含有 $n$ 个珠子的环状项链，对于相邻的两个珠子，前一颗珠子的尾标记等于后方珠子的头标记。<br>​    &nbsp;&nbsp;&nbsp;例如项链为 $[2,4,6,8]$ ， 那么用加入标记表示就是 $[(2,4),(4,6),(6,8),(8,2)]$  。当两个珠子两两合并的时候会产生的能量大小为 前方珠子头标记 $\times$ 前方珠子尾标记 $\times$ 后方珠子尾标记。显然合并的顺序不同最终会产生不同的能量值，问能产生的最大能量值为多少。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp;&nbsp;&nbsp;这道题和合并石子很像，也是一个区间dp的例题，我们也是通过枚举区间长度，然后枚举区间断点来分割区间。这个题也是一个环状，我们也是断环为链，不过处理释放的能量值的问题，我是用了一个结构体，来表示每一颗珠子的标记，通过这个来计算释放能量。不过记得处理子区间也要从处理到 $1\sim 2n$， 这个地方卡了我巨长时间，因为你后面要用到这个状态，如果不计算子区间无法转移到后面。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll dp[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll w;</span><br><span class="line">	ll nxt;</span><br><span class="line">&#125;a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i].w);</span><br><span class="line">		a[i+n].w=a[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span><span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i].nxt=a[i+<span class="number">1</span>].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) dp[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-p+<span class="number">1</span>;i++) <span class="comment">//重要(卡我巨长时间)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+a[i].w*a[k].nxt*a[j].nxt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		printf("%d ",dp[i][i+1]);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列&amp;单调栈总结</title>
    <url>/2020/02/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97&amp;%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​     &nbsp; &nbsp; &nbsp; 最近感觉遇到了好多单调队列和单调栈的问题，但是因为以前没学好，所以遇见了就一脸懵逼，然后绝对下决心来学一下。。感觉遇到啥都不会，这可咋办呐。。补不完的漏洞。</p>
<a id="more"></a>

<hr>
<h1 id="单调队列-Monotone-queue"><a href="#单调队列-Monotone-queue" class="headerlink" title="单调队列(Monotone queue)"></a>单调队列(Monotone queue)</h1><p>​    &nbsp; &nbsp; &nbsp; 单调队列，即单调递减或单调递增的队列。使用频率不高，但在有些程序中会有非同寻常的作用。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>​    &nbsp; &nbsp; &nbsp; 顾名思义，他就是一个单调的队列，那么我们可以规定他是单调递增的还是单调递减的，他和普通的队列有点区别，队列一般是尾进头出，而单调队列要实现的话要确保头和尾都可以出，尾可以进。如果要用STL库的话可以用里面的双端队列。<br>​    &nbsp; &nbsp; &nbsp; 跟普通队列相比他的进队需要确保一个条件就是要<strong>不破坏原有序列的单调性</strong>，好比我们有一个单调递增的单调队列，也就是从队首到队尾是单调递增的，那么有一段序列是 $[2,3,1,5,8,7,4,2]$ ，我们从左到右依次入队。</p>
<table>
<thead>
<tr>
<th>队列中元素</th>
<th>关于元素进出的备注</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>2入队</td>
</tr>
<tr>
<td>2，3</td>
<td>3比2大，可以满足递增性质，入队</td>
</tr>
<tr>
<td>1</td>
<td>因为1比2，3都小，要满足递增性质，先把2，3出队，再将1入队</td>
</tr>
<tr>
<td>1，5</td>
<td>5比1大，可以满足递增性质，入队</td>
</tr>
<tr>
<td>1，5，8</td>
<td>8比5大，可以满足递增性质，入队</td>
</tr>
<tr>
<td>1，5，7</td>
<td>7小于8，大于5，要满足递增性质，我们把8出队，然后将7入队</td>
</tr>
<tr>
<td>1，4</td>
<td>4小于5、7，但是大于1，因此7，5依次出队，4入队</td>
</tr>
<tr>
<td>1，2</td>
<td>2小于4，大于1，因此4出队，2入队</td>
</tr>
</tbody></table>
<p>​    &nbsp; &nbsp; &nbsp; 根据上述例子不难看出，我们要入队的时候首先要确保队尾元素要比想要入队的元素小，然后才能入队，否则的话就一直循环让尾部元素出队，直到能够满足单调性为止。</p>
<h2 id="单调队列的应用"><a href="#单调队列的应用" class="headerlink" title="单调队列的应用"></a>单调队列的应用</h2><ul>
<li>求区间的最值问题。下面写的两个例题都是这个用处。</li>
<li>优化dp，我现在能接触到的就是一个用单调队列优化多重背包的一个题，但是那个题我学了这个东西之后还是不理解为什么可以那么做。例题如下：<a href="https://www.luogu.com.cn/problem/P1776">宝物筛选</a></li>
</ul>
<h2 id="单调队列的一些例题"><a href="#单调队列的一些例题" class="headerlink" title="单调队列的一些例题"></a>单调队列的一些例题</h2><h3 id="A-Sliding-Window"><a href="#A-Sliding-Window" class="headerlink" title="A. Sliding Window"></a>A. <a href="http://poj.org/problem?id=2823">Sliding Window</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出一个含有 $n$ 个整数的序列 $a$ ，给出滑动窗口长度 $k$ ，窗口从序列最左端滑动到序列最右端，问滑动过程中每个时刻窗口中最大值和最小值是多少。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 一道很经典的单调队列的模板题，用于解决定长区间的最大最小值。我们可以维护两个单调队列，一个是单调递增的，一个是单调递减的。因为两种情况类似，我们考虑一下求窗口中最大值的方案。</p>
<p>​    &nbsp; &nbsp; &nbsp; 求最大值我们用的是单调递减的序列，这样就能够保证每次队首的就是答案，但是，这是为什么呢？我们来考虑一下，因为这是一个单调递减的序列，那么我们每次序列元素入队的时候，我们就去看当前队尾的元素是不是要比他大，如果比他还小，那么我们就直接将队尾元素出队，因为这时候要入队的元素（已经被窗口覆盖了）已经比他大了，那么在接下来的窗口中，肯定就没他什么事了，因为它一定不是最大的，那么如果一直将队尾元素出队到加入入队元素后还继续能保持队列的单调性了，但是这个元素还不是在队首，这就说明，队首的元素还是要比他大的（单调性易得）。</p>
<p>​    &nbsp; &nbsp; &nbsp; 所以这时候队首元素就是这个窗口中最大的了吗？也还不能确定，因为我们还不能确保这个队首元素就在窗口中，因此我们需要看看这个元素的位置和当前入队元素的位置之差是不是要比窗口长度大了，如果大于窗口长度，那么就说明队首元素已经不在窗口了，我们就将队首元素出队，最后输出队首元素就能确保它既在窗口中，又是窗口中所有元素的最大值了！</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> head,tail,a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos,value;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head=tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;i-q[head].pos&gt;=k) head++;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;a[i]&lt;=q[tail<span class="number">-1</span>].value) tail--;</span><br><span class="line">		q[tail].value=a[i],q[tail++].pos=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">printf</span>(<span class="string">"%d "</span>,q[head].value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q[i].value=q[i].pos=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head=tail=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;i-q[head].pos&gt;=k) head++;</span><br><span class="line">		<span class="keyword">while</span>(head!=tail&amp;&amp;a[i]&gt;=q[tail<span class="number">-1</span>].value) tail--;</span><br><span class="line">		q[tail].value=a[i],q[tail++].pos=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">printf</span>(<span class="string">"%d "</span>,q[head].value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	 	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	getmax();</span><br><span class="line">	getmin();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B-Max-Sum-of-Max-K-sub-sequence"><a href="#B-Max-Sum-of-Max-K-sub-sequence" class="headerlink" title="B. Max Sum of Max-K-sub-sequence"></a>B. <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3415">Max Sum of Max-K-sub-sequence</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给定长度为 $n$ 的整数循环序列 $a$ ，也就是$a[1],a[2],\cdots,a[n],a[1]\cdots$ 这样的序列，问最大连续长度为 $k$ 的连续子区间的序列和最大为多少，并且输出这个区间的左右坐标。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 我们把这道题转换一下，我们先处理好前缀和，好比我们要求 $a[1],a[2],a[3]$ 的序列和，那么也就是 $sum[3]-sum[0]$ ，因此我们在求这个题的时候就可以循环遍历 $1\sim{n-k+1}$ ，求长度为 $k$ 的定长区间中前缀和数组的最小值即可。但是我们要注意前缀和数组要处理到 $n-k+1$ 。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> n,k,a[maxn],sum[maxn];</span><br><span class="line"><span class="keyword">int</span> head,tail;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos,value;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="keyword">int</span> ans,l,r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		l=r=<span class="number">0</span>;</span><br><span class="line">		head=tail=<span class="number">0</span>;</span><br><span class="line">		ans=-inf;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">			sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum[i]=sum[i<span class="number">-1</span>]+a[i-n];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(head!=tail&amp;&amp;i-q[head].pos&gt;k) head++;</span><br><span class="line">			<span class="keyword">while</span>(head!=tail&amp;&amp;sum[i<span class="number">-1</span>]&lt;=q[tail<span class="number">-1</span>].value) tail--;</span><br><span class="line">			q[tail].pos=i<span class="number">-1</span>,q[tail++].value=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//			if(i!=q[head].pos)</span></span><br><span class="line"><span class="comment">//			&#123; </span></span><br><span class="line">				<span class="keyword">int</span> p=sum[i]-q[head].value;</span><br><span class="line">				<span class="keyword">if</span>(p&gt;ans)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=p;</span><br><span class="line">					<span class="keyword">int</span> k=q[head].pos+<span class="number">1</span>;</span><br><span class="line">					k&gt;n?l=k%n:l=k;</span><br><span class="line">					i&gt;n?r=i%n:r=i;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,ans,l,r);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+k<span class="number">-1</span>;i++) q[i].pos=q[i].value=-inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单调栈-Monotone-stack"><a href="#单调栈-Monotone-stack" class="headerlink" title="单调栈(Monotone stack)"></a>单调栈(Monotone stack)</h1><p>​    &nbsp; &nbsp; &nbsp; 单调增或单调减的栈，跟单调队列差不多，但是只用到它的一端。</p>
<h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>​    &nbsp; &nbsp; &nbsp; 单调栈也是在普通栈的基础上加了单调性，一般是用从栈底到栈顶的单调性来命名，好比从栈底到栈顶是单调递增的，那么他就是单调增的栈。跟单调队列一样，他的入栈规则也是<strong>要不破坏单调性</strong>，因此一个单调递增的栈如果有元素要入栈，如果他比栈顶的元素还要大，就可以直接入栈，如果他比栈顶的元素小，那么就要将栈顶的元素一直出栈到比要入栈元素小为止。如果序列为 $[2,3,1,5,4,7]$，要加入单调递增栈中，过程如下。<strong>PS：注意从左到右对应栈底到栈顶。</strong></p>
<table>
<thead>
<tr>
<th>栈中的元素</th>
<th>关于元素进出的备注</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>元素2压入栈中</td>
</tr>
<tr>
<td>2，3</td>
<td>3大于2，压入栈中</td>
</tr>
<tr>
<td>1</td>
<td>1小于3、2，因此全部弹出将1入栈</td>
</tr>
<tr>
<td>1，5</td>
<td>5大于1，压入栈中</td>
</tr>
<tr>
<td>1，4</td>
<td>4比5小，比1大，弹出5，压入4</td>
</tr>
<tr>
<td>1，4，7</td>
<td>7大于4，压入栈中</td>
</tr>
</tbody></table>
<p>​    &nbsp; &nbsp; &nbsp; 根据上述描述不难看出，其实单调栈就是单调队列的半部分，他能完成的任务理论上单调队列都能够完成，但是有些时候不需要麻烦的去维护单调队列只需要维护单调栈即可完成。</p>
<h2 id="单调栈的应用"><a href="#单调栈的应用" class="headerlink" title="单调栈的应用"></a>单调栈的应用</h2><ul>
<li>确定一个元素的左边区间第一个比它大的元素，第一个比它小的元素</li>
<li>确定右边区间第一个比他大or比他小的元素（根据单调性来看）</li>
<li>确定这个元素是否是一定区间内的最值，或者确定以他为最值的区间长度</li>
</ul>
<h2 id="单调栈的一些例题"><a href="#单调栈的一些例题" class="headerlink" title="单调栈的一些例题"></a>单调栈的一些例题</h2><h3 id="A-单调栈模板"><a href="#A-单调栈模板" class="headerlink" title="A. 单调栈模板"></a>A. <a href="https://www.luogu.com.cn/problem/P5788">单调栈模板</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出含有 $n$ 个整数的序列 $a$ ，定义 $f(i)$ 为第 $i$ 个元素后第一个大于 $a_i$ 的下标，求 $f(1)\cdots f(n)$ </p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 直接就是模板，对应了上述应用里的第二个。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> top,ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;a[i]&gt;a[<span class="built_in">stack</span>[top]])</span><br><span class="line">		&#123;</span><br><span class="line">			ans[<span class="built_in">stack</span>[top]] = i;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(top)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[<span class="built_in">stack</span>[top]]=<span class="number">0</span>;</span><br><span class="line">		top--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B-发射站"><a href="#B-发射站" class="headerlink" title="B. 发射站"></a>B. <a href="https://www.luogu.com.cn/problem/P1901">发射站</a></h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 某地有 $N$ 个能量发射站排成一行，每个发射站 $i$ 都有不相同的高度 $H_i$，并能向两边（两端的发射站只能向一边）同时发射能量值为 $V_i$ 的能量，发出的能量只被两边<strong>最近的且比它高</strong>的发射站接收。计算出接受能量最多的发射站接受的能量为多少。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 维护一个单调递减栈，一个元素新加进来如果是大于栈顶元素的话，那么栈顶元素出栈，并给入栈元素加上能量值。如果不大于栈顶元素的话，就将栈顶元素加上发射能量，然后将元素入栈。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,h[maxn],v[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn],top,ans;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;h[i],&amp;v[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;h[i]&gt;h[<span class="built_in">stack</span>[top]])</span><br><span class="line">		&#123;</span><br><span class="line">			f[i]+=v[<span class="built_in">stack</span>[top]];</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		f[<span class="built_in">stack</span>[top]]+=v[i];</span><br><span class="line">		<span class="built_in">stack</span>[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-音乐会的等待"><a href="#C-音乐会的等待" class="headerlink" title="C. 音乐会的等待"></a>C. <a href="https://www.luogu.com.cn/problem/P1823">音乐会的等待</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出一段序列 $a$ 代表 $n$ 个人，在一个区间 $[l,r]$ 如果区间内没有大于 $min(a[i],a[r])$ 的那么两个人可以相互看到。问这个序列中有多少对人可以相互看到。</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 我们可以维护一个单调递减栈，然后分情况讨论一下。</p>
<ul>
<li>如果要入栈元素大于当前元素，那么当前元素和入栈元素是可以相互看见的，因为这是找了左边区间第一个比它小的元素了，然后因为这是一个单调递减栈，所以我们可以一直出栈比入栈元素小的元素，可以发现这些都是可以互相看见的。而且最终的栈顶元素和要入栈元素也是可以看见的。</li>
<li>如果入栈元素小于当前元素，他可以和栈顶元素看见，而不能和后面的人看见，因为栈顶元素挡住他了。</li>
<li>如果入栈元素和当前元素高度相同，那么他们俩其实是等效的，如果有人比他们高，其实是可以直接看见两个，所以我们只需要将他们看成一个结构体，记录他们的数量和高度即可，每次统计的时候加上数量就行。</li>
</ul>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll cnt; <span class="comment">// num </span></span><br><span class="line">	ll p; <span class="comment">//height</span></span><br><span class="line">&#125;<span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		node temp;</span><br><span class="line">		temp.cnt=<span class="number">1</span>;</span><br><span class="line">		temp.p=h[i];</span><br><span class="line">		<span class="keyword">while</span>(top&gt;=<span class="number">0</span>&amp;&amp;h[i]&gt;<span class="built_in">stack</span>[top].p)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="built_in">stack</span>[top].cnt;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(h[i]==<span class="built_in">stack</span>[top].p)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="built_in">stack</span>[top].cnt;</span><br><span class="line">			temp.cnt+=<span class="built_in">stack</span>[top].cnt;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>[++top].cnt=temp.cnt;</span><br><span class="line">		<span class="built_in">stack</span>[top].p=temp.p;</span><br><span class="line">		<span class="keyword">if</span>(top!=<span class="number">0</span>) ans+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><a href="https://endlesslethe.com/monotone-queue-and-stack-tutorial.html">单调队列和单调栈详解</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u013686535/article/details/76725379">[SMOJ2116]诺诺的队列</a></p>
</li>
<li><p><a href="https://blog.csdn.net/dacc123/article/details/50545577">一些关于单调队列和单调栈优化dp的实例</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调队列&amp;单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces #618 (Div.2)</title>
    <url>/2020/02/10/Codeforces-618/</url>
    <content><![CDATA[<h2 id="A-Non-zero"><a href="#A-Non-zero" class="headerlink" title="A. Non-zero"></a>A. <a href="https://codeforces.com/contest/1300/problem/A">Non-zero</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 给出一段含有 $n$ 个数的序列 $a$ ，可以对其中任何数加一，问最少操作多少次让每一个数和序列和都不为0。</p>
<a id="more"></a>

<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp; &nbsp; &nbsp; 输入的时候如果输入的是 $0$ 就将答案加一，最后如果序列和为 $0$ 的话答案加一。</p>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,sum,p,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			<span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				sum+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> sum+=p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sum==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="B-Assigning-to-Classes"><a href="#B-Assigning-to-Classes" class="headerlink" title="B. Assigning to Classes"></a>B. <a href="https://codeforces.com/contest/1300/problem/B">Assigning to Classes</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 将 $2n$ 个数分成个奇数序列，问两个奇数序列的中位数之差最小为多少。</p>
<hr>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp; &nbsp; &nbsp; 直接就将序列排序然后输出中间两个数之差即可。</p>
<hr>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> p=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+<span class="number">1</span>+p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">abs</span>(a[n]-a[n+<span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="C-Anu-Has-a-Function"><a href="#C-Anu-Has-a-Function" class="headerlink" title="C. Anu Has a Function"></a>C. <a href="https://codeforces.com/contest/1300/problem/C">Anu Has a Function</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 给出函数 $f: f(x,y)=(x|y)-y $ ，给出序列 $a$，序列 $a$ 中含有 $n$ 个数，可以表示为$[a_1,a_2\cdots,a_n ]$ ，定义 $x=f(f(…f(f(a_1,a_2),a_3),…a_{n-1}),a_n)$ ，你可以对序列 $a$ 中元素进行重排，求使得 $x$ 最大的序列 $a$ 。如果有多种情况，输出一种即可。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>第一种思路是因为 $f(x,y)=(x|y)-y$ ，我们可以发现对于经过这样的运算之后，如果 $x$ 的某一位是1，如果 $y$ 的相应位是0，那么运算出来的 $f(x,y)$ 对应位就是1，如果 $y$ 对应位是1，那么运算出来就是0。那么对于 $x$ 的计算过程中的每一位这个规律都是适应的。因此我们只需要将位数从高到低依次扫一遍，如果这个位数为1的情况在序列所有元素中只出现了一次，那么就将唯一出现1的那个数放到第一位即可。</p>
</li>
<li><p>第二种思路<br>$$<br>\because f(x,y)=(x|y) - y {\Longleftrightarrow} f(x,y) = x\&amp;({\sim} y)<br>\therefore x=(a_1)\&amp;({\sim}a_2)\&amp;({\sim} a_3){\cdots}({\sim}a_n)<br>$$<br>   我们发现后面其实都是可交换的，所以第一个只有第一个是起决定作用的，那么我们就可以处理一个前缀和后缀的 and 数组，这样我们就可以 $O(1)$ 的计算出后面那部分，然后遍历序列 $a$ 找到最合适的 $a_1$。</p>
</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],maxk;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		maxk=<span class="built_in">max</span>(maxk,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;=maxk)</span><br><span class="line">	&#123;</span><br><span class="line">		k++;</span><br><span class="line">		p&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">			&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">if</span>(cnt==<span class="number">1</span>) swap(a[j],a[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		printf("%d %d\n",i,cnt);</span></span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> pre[maxn],suf[maxn]; <span class="comment">//pre is prefix,suf is suffix</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		a[i]=~a[i];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) pre[i]=a[i];</span><br><span class="line">		<span class="keyword">else</span> pre[i]=pre[i<span class="number">-1</span>]&amp;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	suf[n]=a[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		suf[i]=suf[i+<span class="number">1</span>]&amp;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p=a[i];</span><br><span class="line">		p=~a[i];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=suf[i+<span class="number">1</span>]&amp;p;</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,now);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=pre[i<span class="number">-1</span>]&amp;p;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;ans)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[i],a[<span class="number">1</span>]);</span><br><span class="line">				ans=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> now=pre[i<span class="number">-1</span>]&amp;suf[i+<span class="number">1</span>]&amp;p;</span><br><span class="line">			<span class="keyword">if</span>(now&gt;ans)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[i],a[<span class="number">1</span>]);</span><br><span class="line">				ans=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,~a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="D-Aerodynamic"><a href="#D-Aerodynamic" class="headerlink" title="D. Aerodynamic"></a>D. <a href="https://codeforces.com/contest/1299/problem/B">Aerodynamic</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>​    &nbsp; &nbsp; &nbsp; 给定一个凸多边形 $P$ 的所有顶点，可以将凸多边形沿向量 $(x,y)$ 平移，我们定义多边形 $T$ 是所有 $P$ 平移到与原点有交点后所构成的点集所形成的图形（我知道这句话有点绕，我实在是解释不明白，实在不行康康原题吧）。那么问这个 $T$ 是否是和 $P$ 相似的，如果是输出YES，不是输出NO。</p>
<hr>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>​    &nbsp; &nbsp; &nbsp; 就是判断这个图形是不是中心对称图形就行了，证明还不会，暂且放一下，会了再写QAQ..</p>
<hr>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//	printf("%d",p);</span></span><br><span class="line">	<span class="keyword">int</span> x1=x[<span class="number">1</span>]+x[<span class="number">1</span>+p];</span><br><span class="line">	<span class="keyword">int</span> y1=y[<span class="number">1</span>]+y[<span class="number">1</span>+p];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=p;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x1!=x[i]+x[i+p]||y1!=y[i]+y[i+p])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>背包进阶</title>
    <url>/2020/02/09/%E8%83%8C%E5%8C%85%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="1-分组背包"><a href="#1-分组背包" class="headerlink" title="1. 分组背包"></a>1. <a href="https://www.luogu.com.cn/problem/P1757">分组背包</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 在01背包基础上，将其中的物体分成 $k$ 组，每组内的物品相互冲突，即只能取其中一个，问最大价值。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 同一组中各个物品是相互排斥的，那么我们对于处理可以外层循环组别，然后循环体积，最后循环组内的物品，然后套用01背包的转移方程 $dp[i]=max(dp[i],dp[i-v[k]]+w[k])$ 即可。我们来思考一下他的正确性，为什么只要这样循环就能确保每个组最多只取用一种呢？很明显组内的我们对于同一个体积 $V$ ，求体积 $V$ 对应的最大价值的时候，是从这个组内所有物品中取了能获得最大价值的策略，很明显当我们转移任何一个 $dp[i-v[k]]$ 的状态的时候，他们其中都不包含第 $i$ 组的物品，都是只包含了前 $i-1$ 组的物品，因为我们最终取得最大价值的路径是确定的，因此通过这个方式我们就可以确保每个组内只取一种，但是如果体积和组内物品的循环调换过来，就不行了，因为之前的状态就会包含当前组内的其他物品。</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">105</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">&#125;p[maxt][maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxt];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> q,w,e,maxe;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;q,&amp;w,&amp;e);</span><br><span class="line">		cnt[e]++;</span><br><span class="line">		p[e][cnt[e]].a=q;</span><br><span class="line">		p[e][cnt[e]].b=w;</span><br><span class="line">		maxe=<span class="built_in">max</span>(maxe,e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxe;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=p[i][k].a)</span><br><span class="line">				dp[j]=<span class="built_in">max</span>(dp[j],dp[j-p[i][k].a]+p[i][k].b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-有依赖的背包"><a href="#2-有依赖的背包" class="headerlink" title="2. 有依赖的背包"></a>2. <a href="https://www.luogu.com.cn/problem/U65320">有依赖的背包</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 在01背包的基础上给物品加上依赖，某个物品可能为附件，必须买了主件之后才能买。规定一个物品最多有两个附件，并且附件不会再有附件，也不存在循环依赖（附件再依赖于主件）。问能获得的最大价值为多少。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 这道题有三种思路，难度依次递增。</p>
<ul>
<li>这道题的附件很少，可能为0，1，2。那么我们就在01背包的基础上，分五种情况来转移，分别是都不买，只买一个主件，只买主件和附件1，只买主件和附件2，买主件和两个附件。然后在这个基础上取一个最大的即可。但是这个思路对于附件可以很多的情况，就会特别麻烦。</li>
<li>第二种思路是转化成分组背包，我们注意到对于每一个主件和附件的搭配都是唯一的，也就是每种方案都是互斥的。好比最多那五种情况，我们就可以分成一组。然后进行分组背包即可。那么我们分组的时候，可以考虑到一个优化，也就是如果他们的体积相同，我们只需要选价值大的那个就可以啦。所以我们先对主件和附件这个集合，进行01背包，然后背出来相同体积下最大价值的方案，分到对应组里。这个思路对于附件也有附件的情况，就不好写了，不能直接01背包。</li>
<li>第三种思路可以应对附件也有附件的情况，可以用森林来表示所有物品之间的关系，然后树上dp做。然而，我不会。QAQ…</li>
</ul>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">32005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">65</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> num[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,p,q;</span><br><span class="line">&#125;item[maxm],minor[maxm][maxm];</span><br><span class="line"><span class="keyword">int</span> dp[maxn],cnt[maxm];</span><br><span class="line"><span class="keyword">int</span> vi[maxm][maxm],pi[maxm][maxm];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;item[i].v,&amp;item[i].p,&amp;item[i].q);</span><br><span class="line">		<span class="keyword">if</span>(item[i].q)</span><br><span class="line">		&#123;</span><br><span class="line">			num[item[i].q]++;</span><br><span class="line">			minor[item[i].q][num[item[i].q]].v=item[i].v;</span><br><span class="line">			minor[item[i].q][num[item[i].q]].p=item[i].v*item[i].p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(num[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">			dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=n-item[i].v;k&gt;=minor[i][j].v;k--)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[k-minor[i][j].v]!=<span class="number">-1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						dp[k]=<span class="built_in">max</span>(dp[k],dp[k-minor[i][j].v]+minor[i][j].p);	</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n-item[i].v;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[k]!=<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					cnt[i]++;</span><br><span class="line">					vi[i][cnt[i]]=k+item[i].v;</span><br><span class="line">					pi[i][cnt[i]]=dp[k]+item[i].v*item[i].p;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!item[i].q)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt[i]++;</span><br><span class="line">			vi[i][cnt[i]]=item[i].v;</span><br><span class="line">			pi[i][cnt[i]]=item[i].v*item[i].p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!cnt[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=cnt[i];k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=vi[i][k])</span><br><span class="line">				&#123;</span><br><span class="line">					dp[j]=<span class="built_in">max</span>(dp[j],dp[j-vi[i][k]]+pi[i][k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	int ans;</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++) ans=max(ans,dp[i]);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-多米诺骨牌-隐式背包"><a href="#3-多米诺骨牌-隐式背包" class="headerlink" title="3. 多米诺骨牌(隐式背包)"></a>3. <a href="https://www.luogu.com.cn/problem/P1282">多米诺骨牌(隐式背包)</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 多米诺骨牌有上下两个部分，分别具有一定点数。所有多米诺骨牌上部分点数之和与下部分点数之和差的绝对值为 $x$ ，多米诺骨牌可以进行上下翻转，问当 $x$ 最小的时候最少翻转几次。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 害，本来好像没有隐式背包这个说法，我自己瞎起的名字。。其实就是没那么裸的背包，实际上转化一下还是道背包的题。这道题本来其实看起来和背包没有什么关系，但是实际想一想，假如我们把所有多米诺骨牌一开始都调成上面大下面小的情况，然后调整过的把他的消耗值设为-1，没有调整过的把消耗值设为1。达成上大下小目的需要消耗的次数为n。调整后的上下点数差为V。我们每次调整之后 $V$ 会减少牌的上下点数之差，这就是我们需要的体积。然后一开始把 $dp[V]$ 设为n。然后转移方程为 $dp[i]=min(dp[i],dp[i+v[i]]+w[i]) $ 最后只需要求从 $0\sim V$ 最小的那个点数差对应的翻转次数值就可以了。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> ini;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> up[maxn],down[maxn];</span><br><span class="line"><span class="keyword">int</span> v[maxn],w[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;up[i],&amp;down[i]);</span><br><span class="line">		<span class="keyword">if</span>(up[i]&gt;=down[i])</span><br><span class="line">		&#123;</span><br><span class="line">			V+=up[i]-down[i];</span><br><span class="line">			v[i]=(up[i]-down[i])*<span class="number">2</span>;</span><br><span class="line">			w[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			V+=down[i]-up[i];</span><br><span class="line">			ini++;</span><br><span class="line">			v[i]=(down[i]-up[i])*<span class="number">2</span>;</span><br><span class="line">			w[i]=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=V;i++) dp[i]=<span class="number">233333</span>;</span><br><span class="line"><span class="comment">//	dp[V]=ini;</span></span><br><span class="line">	dp[V]=ini;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V-v[i];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[j+v[i]]!=<span class="number">233333</span>)</span><br><span class="line">			dp[j]=<span class="built_in">min</span>(dp[j],dp[j+v[i]]+w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=V;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i]!=<span class="number">233333</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[i]); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关于背包的题</title>
    <url>/2020/02/08/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8C%85%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    &nbsp; &nbsp; &nbsp; 今天跟着背包九讲把背包再学习一下，dd_engi大佬的背包九讲Github链接: <a href="https://github.com/tianyicui/pack">背包九讲</a></p>
<hr>
<h3 id="1-采药-01背包"><a href="#1-采药-01背包" class="headerlink" title="1. 采药(01背包)"></a>1. <a href="https://www.luogu.com.cn/problem/P1048">采药(01背包)</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $n$ 个价值为 $w_i$ ，体积为 $v_i$ 的物品，装入体积为 $V$ 的背包中，问能获得的最大为多少。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先我们可以用 $f[i][j]$ 来定义前 $i$ 个物品放入体积为 $j$ 的背包中能获得最大体积，对于每一个物品，我们可以分两种情况来讨论，分别是装和不装，然后取他们两个的最大值。已经正确的定义了状态，转移方程就不难写出来了，是 $f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])$ ，然后推的话就直接外层循环物品，内层循环体积递推即可。最后 $f[n][V]$ 就是我们需要的答案。</p>
<p>​    &nbsp; &nbsp; &nbsp; 但是看了大佬们的题解，他们说，空间复杂度还可以再优化，那么我们可以看看如果优化的话，肯定是不能去掉体积那一维的，所以就是去掉第几个物品那一维。所以从 $f[i][j]$ 变成了 $f[j]$  。那么我们想想，当我们推第 $i$ 个物体的状态的时候，我们需要已知第 $i-1$ 个的状态，我们物体循环是 $1\sim n$ 那么肯定 $f[i][j]$ 一开始对应的是 $f[i-1][j]$ ，那么如果顺推体积 $0\sim V$ 的话我们可以发现，当我们推 $f[i][j]$ 需要状态 $f[i-1][j-v[i]]$  的时候，这时候如果直接调用 $f[j-v[i]]$ 对应的是 $f[i][j-v[i]]$ 也就是说，这不是我们需要的结果，这时候的状态可能已经取过一次i了，那么我们就可以逆推体积 $V\sim c[i]$ ，这样我们调用 $f[j-v[i]]$ 就刚好对应的是没取过 $i$ 的情况了！最后推出来 $f[V]$ 就是对应的答案了！</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> t,m;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=a[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-疯狂的采药-完全背包"><a href="#2-疯狂的采药-完全背包" class="headerlink" title="2. 疯狂的采药(完全背包)"></a>2. <a href="https://www.luogu.com.cn/problem/P1616">疯狂的采药(完全背包)</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $n$ 种价值为 $w_i$ ，体积为 $v_i$ 的物品，每一种物品有无数个，装入体积为 $V$ 的背包中，问能获得的最大为多少。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 那么很显然我们可以把一个它转化成  $\sum_{i=1}^n \lfloor{\frac{V}{v_i}}\rfloor$ 个物品的01背包，也可以在取每个物体的时候循环 $\lfloor{\frac{V}{v_i}}\rfloor$ 次，但是我们可以思考对上述01背包的优化，我们发现如果顺着取，刚好对应的就是我们需要的状态，也就是说我们只需要将 $V$ 的循环正过来就可以了！</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> t,m;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;=t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-a[i]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-宝物筛选-多重背包"><a href="#3-宝物筛选-多重背包" class="headerlink" title="3. 宝物筛选(多重背包)"></a>3. <a href="https://www.luogu.com.cn/problem/P1776">宝物筛选(多重背包)</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $N$ 种物品和一个容量为 $V$ 的背包。第 $i$ 种物品最多有 $m_i$ 件可用，每件耗费的空间是 $v_i$，价值是 $w_i$ 。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 那么这道题裸的做法就是对于转移 $f[v]$ 这个方程的时候，考虑取多少个物品，可以取一个，可以取两个，在不超过体积情况下最多取 $m[i]$ 个，转移方程 $f[v]=max(f[v],f[v-k*v[i]])\quad k\in[1,m_i]$ 。那么这样其实时间复杂度还是很高的，所以大佬们给出了优化方案</p>
<ul>
<li>第一种就是把 $m_i$ 个物品进行二进制拆分，把他们拆成 $1$，$2^1$，$2^2$ ····等等，一直拆到不能再拆，这样我们就能够将 $m_i$ 个物品拆成 $log(m_i)$ 个物品，但是他们还是能够表示出所有的情况。然后就继续01背包背一下就可以了。</li>
<li>单调队列优化，我不会，我太菜了。。</li>
</ul>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,cnt;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn],v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j*=<span class="number">2</span>) <span class="comment">//二进制拆分</span></span><br><span class="line">        &#123;</span><br><span class="line">            v[++cnt]=j*a;</span><br><span class="line">			w[cnt]=j*b;</span><br><span class="line">            c-=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c) </span><br><span class="line">		&#123;</span><br><span class="line">			v[++cnt]=a*c;</span><br><span class="line">			w[cnt]=b*c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">   		&#123;</span><br><span class="line">   			f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>基础线性dp例题 #2</title>
    <url>/2020/02/07/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7dp%E4%BE%8B%E9%A2%98-2/</url>
    <content><![CDATA[<h3 id="1-石子归并"><a href="#1-石子归并" class="headerlink" title="1. 石子归并"></a>1. <a href="https://www.51nod.com/Challenge/Problem.html#problemId=1021">石子归并</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​     &nbsp; &nbsp; &nbsp; $N$ 堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将 $N$ 堆石子合并成一堆的最小代价。</p>
<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 很经典的区间dp例题，我们可以用 $dp[i][j]$ 来表示合并 $i\sim j$ 所需的最小代价，通过枚举中间的断点，来通过方程 $dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+cost[i][j])$  ，其中 $cost[i][j]$ 表示从 $i\sim j$ 的石子总数，通过前缀和很容易计算。在进行状态转移时需要前面状态已知，因为是枚举中间断点，所以断开区间的长度一定要小于原区间，因此在转移之前需要确保比他短的区间都已经达到了最小代价，因此我们可以通过枚举区间长度从 $2\sim N$ 来实现。</p>
<a id="more"></a>

<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum[maxn],a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-p+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">			dp[i][j]=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1880-NOI1995-石子合并"><a href="#2-P1880-NOI1995-石子合并" class="headerlink" title="2. P1880 [NOI1995]石子合并"></a>2. <a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; $N$ 堆石子摆成一个环。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将 $N$ 堆石子合并成一堆的最小代价和最大代价。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 这个题和上个题只有两个地方不同，一个是从线到环，一个是同时求最大和最小代价。害，其实这样也没变什么东西，也是跟上面一样，枚举区间长度和切割点。我们可以把一个环想象成一个链，如果这个环是由 N 个元素构成，那么这个链就由 N+N 个元素构成，这么这样就能确保你每次枚举区间的时候能取到合法的值，好比你要可以合并最后一个和第一个，那么就是对应的  $dp[n][n]+dp[n+1][n+1]+cost[n][n+1]$  。不过这样最后寻找答案的时候肯定不只是 $dp[i][n]$ 了，你要从 $dp[1][n]\sim dp[n][n*2]$ 中寻找最优的答案。同时求最大和最小代价就直接开两个数组记录就可以了。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum[maxn&lt;&lt;<span class="number">1</span>],a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ansmax,ansmin=<span class="number">12345678</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>],f[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>]; <span class="comment">//later is max , fromer is min </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		a[i+n]=a[i];</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	 &#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) dp[i][i]=f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-p+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">			dp[i][j]=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ansmax=<span class="built_in">max</span>(ansmax,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ansmin=<span class="built_in">min</span>(ansmin,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,ansmin,ansmax);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-P1140-相似基因"><a href="#3-P1140-相似基因" class="headerlink" title="3. P1140 相似基因"></a>3. <a href="https://www.luogu.com.cn/problemnew/solution/P1140">P1140 相似基因</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 有 $A : T :C : G $ 四种碱基，他们之间可以两两配对，特殊的，一个碱基也可以和空碱基配对，但是空碱基和空碱基配对是不被允许的，当不同的碱基间两两配对时，会具有一定的相似度，问给定两段序列 $s$，$t$ 能获得的最大相似度是多少。</p>
<ul>
<li>碱基配对时相似度的定义如下</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">C</th>
<th align="center">G</th>
<th align="center">T</th>
<th align="center">空</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">5</td>
<td align="center">-1</td>
<td align="center">-2</td>
<td align="center">-1</td>
<td align="center">-3</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">-1</td>
<td align="center">5</td>
<td align="center">-3</td>
<td align="center">-2</td>
<td align="center">-4</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">-2</td>
<td align="center">-3</td>
<td align="center">5</td>
<td align="center">-2</td>
<td align="center">-2</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">-1</td>
<td align="center">-2</td>
<td align="center">-2</td>
<td align="center">5</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">空</td>
<td align="center">-3</td>
<td align="center">-4</td>
<td align="center">-2</td>
<td align="center">-1</td>
<td align="center">非法</td>
</tr>
</tbody></table>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先用一个二维数组来存储对应的相似值表。因为对应的两段序列，我感觉这种题一般都是用 $dp[i][j]$ 来表示第一段序列从 $1\sim i$ 对应第二段序列 $1\sim j$ 所能获得的最大相似度，那么思考一下状态转移。</p>
<ul>
<li><p>首先可以是碱基对空碱基，这时候 $s$ 要匹配碱基，$t$ 中匹配空碱基，这样的话就从应该从 $dp[i-1][j] $转移过来，对应的转移方程为  $dp[i][j]=max(dp[i][j],dp[i-1][j]+map[s[i]][blank])$</p>
</li>
<li><p>也可以是空碱基对碱基，对应的转移方程为$dp[i][j]=max(dp[i][j],dp[i][j-1]+map[blank][t[j]])$</p>
</li>
<li><p>也可以是碱基对碱基，对应的转移方程为$dp[i][j]=max(dp[i][j],dp[i-1][j-1]+map[s[i]][t[j]])$</p>
</li>
</ul>
<p>​    &nbsp; &nbsp; &nbsp;  害，想到这里我又突然懵逼了，我在想是否能确保两个序列所有的碱基都被用到，仔细想想确实是可以的，因为状态定义的就是用了前 $i$ 个碱基和前 $j$ 个碱基所获得的最大相似度。最后我们就处理一下边界就可以了，边界我们可以发现是 $dp[i][0]$ 和 $dp[0][i]$ ，这就是可以对应着空碱基和相应 $s[i]$ 和 $t[i]$ 的碱基，因此只需要用循环依次转移一遍就可以了。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">5</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-4</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">-3</span>,<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//A 0 C 1 G 2 T 3 blank 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%s%d%s"</span>,&amp;n,s+<span class="number">1</span>,&amp;m,c+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'A'</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'C'</span>) a[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'G'</span>) a[i]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'T'</span>) a[i]=<span class="number">3</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'A'</span>) b[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'C'</span>) b[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'G'</span>) b[i]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="string">'T'</span>) b[i]=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">map</span>[a[i]][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="built_in">map</span>[<span class="number">4</span>][b[i]];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j]=-inf;</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][j<span class="number">-1</span>]+<span class="built_in">map</span>[<span class="number">4</span>][b[j]]);</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]+<span class="built_in">map</span>[a[i]][<span class="number">4</span>]);</span><br><span class="line">			dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="built_in">map</span>[a[i]][b[j]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[n][m]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>基础线性dp例题</title>
    <url>/2020/02/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7dp%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>​    &nbsp; &nbsp; &nbsp; 某位大佬曾经说过，dp不会没问题，想不到状态转移方程没问题，多做题就会了。所以，我打算多刷点dp题。那么，先从基础刷起吧。</p>
<h3 id="1-P1091-合唱队形"><a href="#1-P1091-合唱队形" class="headerlink" title="1. P1091 合唱队形"></a>1. <a href="https://www.luogu.com.cn/problem/P1091">P1091 合唱队形</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 已知序列 $a$ 有 $n$ 个数，通过取出其中一些数可以使他满足严格的先增再减序列，问最少取出几个。</p>
<hr>
<a id="more"></a> 

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 很显然想要求最少取出几个，我们就看严格先增再减的序列的最长长度即可。我们可以用 $g[i]$ 来存储到 $a[i]$ 为止的最长递增子序列的长度，然后用 $l[i]$ 来存储从 $a[i]$ 到序列末尾最长的递减子序列的长度。处理 $g[i]$ 从前往后扫，处理 $l[i]$ 需要从后往前扫。处理完 $f$ 和 $g$ 数组那么就从左到右扫一遍，$ans=max(ans,g[i]+l[i]-1)$ 。答案即是 $n-ans$ 。 </p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn],g[maxn],l[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]) g[i]=<span class="built_in">max</span>(g[i],g[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n+<span class="number">1</span>;j&gt;i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]) l[i]=<span class="built_in">max</span>(l[i],l[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxout=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maxout=<span class="built_in">max</span>(maxout,g[i]+l[i]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,n-maxout);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1280-尼克的任务"><a href="#2-P1280-尼克的任务" class="headerlink" title="2. P1280 尼克的任务"></a>2. <a href="https://www.luogu.com.cn/problem/P1280">P1280 尼克的任务</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 尼克的一个工作日为 $n$ 分钟，从第一分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $p+t-1$ 分钟结束。（实在不会总结题意，就直接复制过来了）</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 我们可以设 $f[i]$ 为时间从 $i\sim n$ 所能获得最长空闲时间，最终 $f[1]$ 对应的就是答案。假设在这个 $i$ 分钟有 $k[i]$ 个任务可以，那么我们可以分以下情况转移</p>
<ul>
<li>$k[i]=0$  ， 那么  $f[i]=f[i+1]+1$ </li>
<li>$k[i]\not=0$  ，那么可以循环 $1 \sim k[i]$ 遍历这个时间点开始的任务，$f[i]=max(f[i],f[i+k[i].t])$ </li>
</ul>
<p>​    &nbsp; &nbsp; &nbsp; 思路是这样的，但是我们记录 $k[i].t$ 并不好记录，因此我们可以先将任务开始时间按降序排序，用一个一个变量 $cnt$ 来代表已经取到第几个任务了，那么这样一直取下去，最终就能够遍历所有的任务。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(struct task a,struct task b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.l&gt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,n,k; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t[i].l,&amp;t[i].r);</span><br><span class="line">		p[t[i].l]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(t+<span class="number">1</span>,t+<span class="number">1</span>+k,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!p[i])</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i]=dp[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[i];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i]=<span class="built_in">max</span>(dp[i],dp[i+t[cnt].r]);</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>​    </p>
<p>​    &nbsp; &nbsp; &nbsp; 我太懒了····就写了两道，明天继续加油吧。。</p>
]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces#617(Div.3)</title>
    <url>/2020/02/05/Codeforces-617/</url>
    <content><![CDATA[<h3 id="A-Array-with-Odd-Sum"><a href="#A-Array-with-Odd-Sum" class="headerlink" title="A. Array with Odd Sum"></a>A. <a href="https://codeforces.com/contest/1296/problem/A">Array with Odd Sum</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出包含 <strong>n</strong> 个正整数的序列 <strong>a</strong> ，你可以把任何一个元素 $a_i$ ，赋值给另一个元素 $a_j$ ($i\neq j$) ，问通过任意此操作能否将序列 <strong>a</strong> 的和变为奇数。可以输出 <strong>YES</strong> ,不可以输入 <strong>NO</strong>.</p>
<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先当起始和为奇数的时候，就直接可输出 <strong>YES</strong> 了，如果是偶数的话，我们可以发现，如果序列元素中同时包含奇数和偶数，那么就是可以的，否则不可以。</p>
<a id="more"></a>

<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,flag,sum,p,flag1,flag2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		flag2=flag1=<span class="literal">false</span>;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			sum+=p;</span><br><span class="line">			<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">1</span>) flag1=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>) flag2=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag1&amp;&amp;flag2) flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="B-Food-Buying"><a href="#B-Food-Buying" class="headerlink" title="B. Food Buying"></a>B. <a href="https://codeforces.com/contest/1296/problem/B">Food Buying</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 初始有 <strong>s</strong> 个货币，每次花费 <strong>x</strong> 个货币会返还 $\lfloor{\frac{x}{10}}\rfloor$ 个货币，问最多共能花费多少货币。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 贪心即可。剩余的货币一直除10累加，注意最终剩余不足10的处理。</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p=s;</span><br><span class="line">			<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(p)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(p&lt;<span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">				now=p/<span class="number">10</span>;</span><br><span class="line">				s+=now;</span><br><span class="line">				p%=<span class="number">10</span>;</span><br><span class="line">				p+=now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-Yet-Another-Walking-Robot"><a href="#C-Yet-Another-Walking-Robot" class="headerlink" title="C. Yet Another Walking Robot"></a>C. <a href="https://codeforces.com/contest/1296/problem/C">Yet Another Walking Robot</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 一个机器人初始在 $(0,0)$ 点，规定 <strong>‘L’</strong>  ，<strong>‘R’</strong> ，<strong>‘U’</strong> ，<strong>‘D’</strong>  分别对应向左，向右，向上和向下。给定一段包含上述字母的序列 <strong>s</strong> ，机器人遵循指引序列移动。如果删除一段连续序列可使得机器人最终到达终点不变，问删除的最短序列的起始和终点为多少。</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 想了半天想了错误的解法。。一直在考虑 <strong>L</strong> 和 <strong>R</strong> 数相等，<strong>U</strong> 和 <strong>D</strong> 相等，通过这个方法来找序列。看了题解才发现是通过坐标来看。我们可以开一个map记录坐标和步数的关系，从左到右扫序列，如果没有到达过这个坐标，就记录当前是第几次移动到达这个坐标的，如果到达过的话，就看上一次到达这个坐标时的步数，计算他们的序列长度，如果小于计算的就更新答案。因为是需要找最小的，因此只需要记录上一次到达的步数即可。</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">-1</span>,r=n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pos; <span class="comment">//first为x second为y</span></span><br><span class="line">		<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; last;  </span><br><span class="line">		pos.first=pos.second=<span class="number">0</span>;</span><br><span class="line">		last[pos]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'L'</span>) pos.first--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'R'</span>) pos.first++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'U'</span>) pos.second++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'D'</span>) pos.second--;</span><br><span class="line"><span class="comment">/*			</span></span><br><span class="line"><span class="comment">			if(i==2)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				printf("%d %d\n",pos.first,pos.second);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">*/</span>			</span><br><span class="line">			<span class="keyword">if</span>(last.count(pos)!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> p=i-last[pos];</span><br><span class="line"><span class="comment">//				if(i==2) printf("%d %d\n",i,last[pos]);</span></span><br><span class="line">				<span class="keyword">if</span>(p&lt;r-l)</span><br><span class="line">				&#123;</span><br><span class="line">					l=last[pos];</span><br><span class="line">					r=i;	</span><br><span class="line">				&#125;	</span><br><span class="line"><span class="comment">//				if(i==2 )printf("%d %d\n",l,r);</span></span><br><span class="line">			&#125;</span><br><span class="line">			last[pos]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,l+<span class="number">1</span>,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="D-Fight-with-Monsters"><a href="#D-Fight-with-Monsters" class="headerlink" title="D. Fight with Monsters"></a>D. <a href="https://codeforces.com/contest/1296/problem/D">Fight with Monsters</a></h3><hr>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 由你先手和对手轮流击打 $n$ 个血量为 $h_i$ 的小怪兽，你可以对怪物造成 $a$ 点伤害，对手可以造成 $b$ 点伤害。你有 $k$ 次机会使对手跳过他的回合。当小怪兽血量 $h\le0$ 时视为被击杀，当你击杀怪兽，你获得一分，当对手击杀，你不得分。求你最多能获得多少分数。</p>
<hr>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 先看一下对于每个怪兽我们要击杀需要花费多少机会，你和对手一个回合会击杀怪兽 $a+b$ 点血量，因此你可以一直将回合进行到怪兽血量小于$a+b$，接下来我们可以分两种情况讨论。</p>
<ul>
<li><p>怪兽血量为0，那么我们就需要回溯对手最后一个回合，然后需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil$ 次</p>
</li>
<li><p>怪兽血量不为0，我们需要使用的机会就是 $\lceil\frac{h_i}{a}\rceil-1$ 次，注意这里不能直接写 $\lfloor\frac{h_i}{a}\rfloor$ 次，因为如果 $h_i$ 刚好能被 $a$ 整除，后面这个写法就错了。</p>
</li>
</ul>
<p>​    &nbsp; &nbsp; &nbsp; 计算出了每个怪兽需要花费的机会那么就好做了，就变成了一个贪心问题，我们去尽可能得击杀需要的机会少的，当机会消耗完毕，得到的就是答案了。</p>
<hr>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,k;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;a,&amp;b,&amp;k);</span><br><span class="line">	<span class="keyword">int</span> p=a+b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">		h[i]%=p;</span><br><span class="line">		<span class="keyword">if</span>(h[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			h[i]+=b;</span><br><span class="line">			f[i]=<span class="built_in">ceil</span>((<span class="keyword">double</span>)h[i]/a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> f[i]=<span class="built_in">ceil</span>((<span class="keyword">double</span>)h[i]/a)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(f+<span class="number">1</span>,f+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k-f[i]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		ans++;</span><br><span class="line">		k-=f[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷的一些搜索题</title>
    <url>/2020/02/04/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="1-P1378-油滴扩展"><a href="#1-P1378-油滴扩展" class="headerlink" title="1. P1378 油滴扩展"></a>1. <a href="https://www.luogu.com.cn/problem/P1378">P1378 油滴扩展</a></h3><hr>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 在长方形框中，最多有 n ($0\le{n}\le6$)个相异点，在框中点上依次放置可扩展的油滴，当碰到其他油滴边界或者长方形边框时会停止，扩展呈圆形展开。放置下一个时会确保上一个已经扩展完成。问通过变换放置顺序可使得最终框中剩下的面积最小为多少。</p>
<a id="more"></a>

<hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 这是个裸的dfs，情况最多也就 $6! = 720$ 种，所以我们可以只需要设置一个vis数组来记录是否已经放置过这个油滴，计算已扩展油滴和将要放的油滴之间的距离可以用 <strong>两点距离-扩展油滴的半径</strong>来实现 ，但是有个坑需要注意，就是当一个油滴已经放在已经有扩展油滴覆盖的区域，那么他俩的距离是0，而不是负数，因此在计算半径的时候需要优化一下。</p>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,y,xx,yy;</span><br><span class="line"><span class="keyword">double</span> rx[maxn];</span><br><span class="line"><span class="keyword">double</span> maxans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dx[maxn],dy[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">diss</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span> <span class="comment">//计算两点距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">radius</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">//计算半径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="built_in">min</span>(<span class="built_in">abs</span>(dx[p]-x),<span class="built_in">min</span>(<span class="built_in">abs</span>(dy[p]-y),<span class="built_in">min</span>(<span class="built_in">abs</span>(dx[p]-xx),<span class="built_in">abs</span>(dy[p]-yy))));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i]&amp;&amp;i!=p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> dis=diss(dx[i],dy[i],dx[p],dy[p]);</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(dis-rx[i],<span class="number">0.0</span>)); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowcnt,<span class="keyword">double</span> area)</span> <span class="comment">//area为拓展总面积 nowcnt为现在已经放置了几个 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nowcnt==n)</span><br><span class="line">	&#123;</span><br><span class="line">		maxans=<span class="built_in">max</span>(maxans,area);</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i]=<span class="literal">true</span>;</span><br><span class="line">			rx[i]=radius(i);</span><br><span class="line">			dfs(nowcnt+<span class="number">1</span>,area+pi*rx[i]*rx[i]);</span><br><span class="line">			rx[i]=<span class="number">0</span>;</span><br><span class="line">			vis[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;xx,&amp;yy);</span><br><span class="line">	<span class="keyword">double</span> sum=<span class="built_in">abs</span>(x-xx)*<span class="built_in">abs</span>(y-yy); <span class="comment">//矩形总面积 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;dx[i],&amp;dy[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%0.0lf"</span>,sum-maxans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-P1120-小木棍"><a href="#2-P1120-小木棍" class="headerlink" title="2. P1120 小木棍"></a>2. <a href="https://www.luogu.com.cn/problem/P1120">P1120 小木棍</a></h3><hr>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 将一些长度为 <strong>x</strong> 的等长木棍全部切成 <strong>n</strong> 段不超过50的小木棍，求长木棍长度 <strong>x</strong> 的最小长度。</p>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 首先这个题是有个坑的，题目给出来了，输入的小木棍长度可能会有大于50的，因此我们需要筛掉它。</p>
<p>​    &nbsp; &nbsp; &nbsp; 那么很显然这个题是一道搜索题，我们可以写搜索函数<code>dfs(int nowcnt,int nxt,int lenlast,int len)</code>.上述参数分别表示: 现在在寻找第几根小木棍，我们寻找下一个拼接段应该从哪里开始找，当前这根拼接还需要多长，以及我们要拼成多长的木棍。搜索的复杂度这么高，对于 $n\le65$ 的数据肯定不能直接无脑搜，因此需要想想怎么优化。</p>
<ul>
<li><p>首先要从大到小排序这个很关键的，因为你从大的先凑就能够保证后面选择的时候容错率更高一些。</p>
</li>
<li><p>很显然我们可以剪掉当 lenlast&lt;0 的情况，这个地方我们可以在拼接的时候就判断，也可以在拼接后判断。</p>
</li>
<li><p>在寻找下一个拼接片段的时候，我们可以通过二分搜索来查找下一个不超过lenlast的片段，我选择了直接用STL的库中的lower_bound函数。<del>(其实因为是我的二分总是写炸)</del></p>
</li>
<li><p>再就是我们对于相等片段的处理，很显然当前片段不符合情况那么与他等长的也都不会符合，因此我们可以直接循环筛掉。当然更优的方法可以提前处理一个跳表，直接跳到下一个与他不同的位置。</p>
</li>
<li><p>最后这个优化还是挺难想的，就是如果当前片段搜下去已经不符合情况，但是当前的lenlast是等于当前片段长度的，也就是说你正好用了尽可能满足条件的一个方案，也还是没达到目的，你们你继续往下搜，用比他还要劣的方案肯定也是不可能的，因此直接就break跳出循环不需要往下搜了。</p>
<p><del>不过就算加了这么多优化我还是T了三个点，直接 O<sub>2</sub>一开跑路了嘿嘿</del></p>
</li>
</ul>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],temp,icnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> totlen,maxlen,cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],finish;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nowcnt,<span class="keyword">int</span> nxt,<span class="keyword">int</span> lenlast,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//nowcnt:现在正在拼接第几根 </span></span></span><br><span class="line"><span class="function"><span class="comment">//nxt:我们应该从哪里开始检索 </span></span></span><br><span class="line"><span class="function"><span class="comment">//lenlast:现在拼接还需要多少才能拼接完成 </span></span></span><br><span class="line"><span class="function"><span class="comment">//len:每根木棍的理想长度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lenlast&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(lenlast==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		printf("test\n");</span></span><br><span class="line">		<span class="keyword">if</span>(nowcnt==cnt) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">			finish=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(p=<span class="number">1</span>;p&lt;=n;p++) <span class="keyword">if</span>(!vis[p]) <span class="keyword">break</span>;</span><br><span class="line">		vis[p]=<span class="literal">true</span>;</span><br><span class="line">		dfs(nowcnt+<span class="number">1</span>,p+<span class="number">1</span>,len-a[p],len);</span><br><span class="line">		<span class="keyword">if</span>(finish) <span class="keyword">return</span> ;</span><br><span class="line">		vis[p]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=lower_bound(a+nxt,a+<span class="number">1</span>+n,lenlast,greater&lt;<span class="keyword">int</span>&gt;())-a;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			printf("what\n");</span></span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;lenlast-a[i]&gt;=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i]=<span class="literal">true</span>;</span><br><span class="line">				dfs(nowcnt,i+<span class="number">1</span>,lenlast-a[i],len);</span><br><span class="line">				<span class="keyword">if</span>(finish) <span class="keyword">return</span>;</span><br><span class="line">				vis[i]=<span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">while</span>(a[i+<span class="number">1</span>]==a[i]) i++;</span><br><span class="line">				<span class="keyword">if</span>(i==n) <span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">if</span>(lenlast-a[i]==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">		<span class="keyword">if</span>(temp&gt;<span class="number">50</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> a[i]=temp;</span><br><span class="line">		maxlen=<span class="built_in">max</span>(maxlen,a[i]);</span><br><span class="line">		totlen+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="keyword">while</span>(!a[n]) n--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=maxlen;l&lt;=totlen;l++)</span><br><span class="line">	&#123;</span><br><span class="line">		finish=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(totlen%l!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		cnt=totlen/l;</span><br><span class="line">		vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,<span class="number">2</span>,l-a[<span class="number">1</span>],l);</span><br><span class="line">		vis[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(finish) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-YOKOF-Power-Calculus"><a href="#3-YOKOF-Power-Calculus" class="headerlink" title="3. YOKOF - Power Calculus"></a>3. <a href="https://www.spoj.com/problems/YOKOF/">YOKOF - Power Calculus</a></h3><hr>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给出一个正整数 <strong>n</strong> ，只能使用乘法或者除法，可以乘除 $x$ 或者过程中产生的中间值 $x^i$ ，输出使得 $x$ 变为 $x^n$ 所需的最少步数。$(n\le100)$</p>
<hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 很显然我们一直是对指数进行操作，看似是乘除，直接转化为指数的加减。因此我们需要记录一个状态数组来记录乘除中间所产生的 $x^i$ ，以便后续过程中使用。但是这道题直接搜索的话，又会超时，因为他把大量的时间浪费在高深度上，但是这个却不一定是最优解。因此需要用到迭代加深搜索(IDDFS).</p>
<blockquote>
<p>迭代加深搜索(IDDFS)主要用于处理一些题目可能会搜到很深但是答案却不是最优的问题。有的时候dfs搜索的深度是无穷的，而且他的复杂度是呈指数级增长的，因此这其中某些情况就可以用IDDFS，在每次搜索的时候，我们给深度一个限制，当达到这个最大深度却没有得到答案的时候，就返回，然后逐步提升深度，这样我们就可以避免将时间浪费在那些无谓的高深度搜索上了。</p>
</blockquote>
<p>$$<br>\sum_{i=0}^n2^i=2^{n+1}-1（指数级别增长实例）<br>$$</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1005</span>]; <span class="comment">//用来记录每次生成的中间状态 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> dep,<span class="keyword">int</span> maxdep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="number">0</span>||dep&gt;maxdep||k&lt;&lt;(maxdep-dep)&lt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==n||k&lt;&lt;(maxdep-dep)==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	x[dep]=k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=dep;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dfs(k+x[i],dep+<span class="number">1</span>,maxdep)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//对应乘法 </span></span><br><span class="line">		<span class="keyword">if</span>(dfs(k-x[i],dep+<span class="number">1</span>,maxdep)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//对应除法 </span></span><br><span class="line">	&#125;</span><br><span class="line">	x[dep]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dfs(<span class="number">1</span>,<span class="number">0</span>,i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>洛谷提高历练地</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX的一些总结</title>
    <url>/2020/02/03/LaTeX%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h3><!-- 空一行 -->

<p><img src="/images/xila.png" alt="xila"></p>
<a id="more"></a>

<hr>
<h3 id="一些技巧和特殊符号"><a href="#一些技巧和特殊符号" class="headerlink" title="一些技巧和特殊符号"></a>一些技巧和特殊符号</h3><ul>
<li><p>上标：num_i  -&gt;  $num_i$</p>
</li>
<li><p>下标：e^x -&gt;  $e^x$  （如果下标或上标不明显，可嵌套多层来达到目的）</p>
<ul>
<li>上下标是一串字符的话可用{}括起来表示</li>
</ul>
</li>
<li><p>根号：\sqrt[3]{x} -&gt; $\sqrt[3]{x}$</p>
</li>
<li><p>省略号： 在下面\dots -&gt; $\dots$     在中间\cdots -&gt;  $\cdots$</p>
</li>
<li><p>方框:  \boxed{example}  -&gt;  $\boxed{example}$   (还有一个\fbox与此类似  \fobx{example} -&gt; $\fbox{example}$) </p>
</li>
<li><p>字体加粗:  \mathbf{example} -&gt; $\mathbf{example}$ </p>
</li>
<li><p>字体斜体且加粗:  \boldsymbol{example}  -&gt;  $\boldsymbol{example}$</p>
</li>
<li><p>插入普通文本（自适应大小）:  \text{测试}  -&gt; $\text{测试}$  </p>
<p><img src="/images/specialsign.png" alt="specialsign"></p>
<p><img src="/images/specialsign2.png" alt="specialsign"></p>
</li>
</ul>
<hr>
<h3 id="一些基本符号"><a href="#一些基本符号" class="headerlink" title="一些基本符号"></a>一些基本符号</h3><ul>
<li><p>求和:  \sum_1^n  -&gt;  $\sum_1^n$ </p>
</li>
<li><p>积分:  \int_1^n -&gt; $\int_1^n$   \iint -&gt; $\iint$  以此类推$\cdots$</p>
</li>
<li><p>极限:  \lim_{x \to +\infty}  -&gt; $\lim_{x \to +\infty}$</p>
</li>
<li><p>分数:  \frac{1}{2} -&gt; $\frac{1}{2}$   如果要写多层分数可以用\cfrac （可以避免字母逐层缩小的限制）</p>
</li>
<li><p>组合数: \binom{5}{2} -&gt; $\binom{5}{2}$</p>
</li>
<li><p>下取整: \lfloor{x}\rfloor -&gt;  $\lfloor{x}\rfloor$</p>
</li>
<li><p>下取整: \lceil{x}\rceil -&gt; $\lceil{x}\rceil$</p>
<p><img src="/images/qita.png" alt="qita"></p>
<p><img src="/images/qita2.png" alt="qita2"></p>
</li>
</ul>
<hr>
<h3 id="关于矩阵和行列式"><a href="#关于矩阵和行列式" class="headerlink" title="关于矩阵和行列式"></a>关于矩阵和行列式</h3><ul>
<li>矩阵：用法如下，元素中间使用&amp;来分割同行元素，用\\来换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">	1 &amp; 2 &amp; 3\\</span><br><span class="line">	4 &amp; 5 &amp; 6\\</span><br><span class="line">	7 &amp; 8 &amp; 9\\</span><br><span class="line">\end&#123;matrix&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>\begin{matrix}<br>    1 &amp; 2 &amp; 3\\<br>    4 &amp; 5 &amp; 6\\<br>    7 &amp; 8 &amp; 9\\<br>\end{matrix}<br>$$</p>
<ul>
<li>行列式: 与矩阵相似，加上行列式的名字以及左右分割线即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;  \left|</span><br><span class="line">	\begin&#123;matrix&#125;</span><br><span class="line">	1 &amp; 2 &amp; 3 \\</span><br><span class="line">	4 &amp; 5 &amp; 6 \\</span><br><span class="line">	7 &amp; 8 &amp; 9 \\</span><br><span class="line">	\end&#123;matrix&#125;</span><br><span class="line">	\right|</span><br></pre></td></tr></table></figure>


<p>$$<br>A=  \left|<br>    \begin{matrix}<br>    1 &amp; 2 &amp; 3 \\<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9 \\<br>    \end{matrix}<br>    \right|<br>$$</p>
<hr>
<h3 id="分段函数和方程组"><a href="#分段函数和方程组" class="headerlink" title="分段函数和方程组"></a>分段函数和方程组</h3><ul>
<li>分段函数：写法如下，每一个条件用 表达式和条件之间用 <strong>&amp;</strong> 连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x)&#x3D;</span><br><span class="line">	\begin&#123;cases&#125;</span><br><span class="line">		x&#x2F;2, &amp; &#123;n&gt;2&#125;\\</span><br><span class="line">		2x , &amp; &#123;n&#x3D;2&#125;\\</span><br><span class="line">		3x , &amp; &#123;n&lt;2&#125;\\</span><br><span class="line">	\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>f(x)=<br>    \begin{cases}<br>        x/2, &amp; {n&gt;2}\\<br>        2x , &amp; {n=2}\\<br>        3x , &amp; {n&lt;2}\\<br>    \end{cases}<br>$$</p>
<ul>
<li>方程组: 写法如下，不是一个对称的，注意left后面为{ ，right后面为. 用\\换行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\left\&#123;</span><br><span class="line">	\begin&#123;array&#125;&#123;&#125;</span><br><span class="line">		a_1x+b_1y+c_1z&#x3D;d_1\\</span><br><span class="line">		a_2x+b_2y+c_2z&#x3D;d_2\\</span><br><span class="line">		a_3x+b_3y+c_3z&#x3D;d_3</span><br><span class="line">	\end&#123;array&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure>


<p>$$<br>\left\{<br>    \begin{array}{}<br>        a_1x+b_1y+c_1z=d_1\\<br>        a_2x+b_2y+c_2z=d_2\\<br>        a_3x+b_3y+c_3z=d_3<br>    \end{array}<br>\right.<br>$$</p>
<hr>
<p><strong>Ps: 上面的矩阵，行列式，分段函数和方程组有一个问题需要我们注意，因为反斜杠 \ 需要转义，那么对于每次换行需要两个\\ ，也就是说你打的时候总需要打四个，对于前面声明begin和end，或者left和right前面的反斜杠，你打的时候就要打两个，对于markdown编辑器里面编辑LaTeX可能会自适应，不会自动转义，但是我们推博客的时候，一定要注意这个地方，不然会显示错误。也就是对于上述描述中的反斜杠，都要按两倍来写</strong></p>
<hr>
<p>先总结这么多，后面那些进阶的用到了再总结。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://blog.csdn.net/happyday_d/article/details/83715440">Typora中利用LaTeX 插入数学公式</a></li>
<li><a href="https://www.jianshu.com/p/22117d964baf">LATEX 公式总结</a></li>
</ul>
]]></content>
      <categories>
        <category>不务正业</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeforcesER</title>
    <url>/2020/02/02/CodeforcesER81/</url>
    <content><![CDATA[<h3 id="A-Display-The-Number"><a href="#A-Display-The-Number" class="headerlink" title="A : Display The Number"></a>A : <a href="https://codeforces.com/contest/1295/problem/A">Display The Number</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 用一定数目的灯管，显示尽可能大的数</p>
<p><img src="https://s2.ax1x.com/2020/02/02/1te6Re.md.png" alt="A"></p>
<a id="more"></a>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 因为位数多的肯定更大，所以肯定用尽量少的灯管搭建单个数字更好，最少的两个分别是两个灯管显示的1，以及三个灯管显示的7，所以就是尽可能的用1，如果最后剩余正好三个就显示7。这就转化成了判断奇数还是偶数的题，奇数就显示7111····，偶数就是1111···。注意要把7放在前面（我就踩坑了）。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"7"</span>);</span><br><span class="line">			n-=<span class="number">3</span>;</span><br><span class="line">			<span class="keyword">int</span> p=n/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="B-Infinite-Prefixes"><a href="#B-Infinite-Prefixes" class="headerlink" title="B : Infinite Prefixes"></a>B : <a href="https://codeforces.com/contest/1295/problem/B">Infinite Prefixes</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给定一段01字符串 <strong>s</strong> 为循环节，得到无限循环的01字符串 <strong>t</strong>，求 <strong>t</strong> 中有多少前缀满足0个数-1个数等于期望值<strong>x</strong> （空前缀也算是一个前缀）</p>
<blockquote>
<p>前缀：例如”abcd”的前缀包括 “ “,”a”,”ab”,”abc”,”abcd”.</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>首先我们先记录循环节 <strong>s</strong> 中每个位置对应的01个数差，记为$num_i，i\in[1,n]$ （ <strong>s</strong> 长度记为n） </p>
<ul>
<li>首先我们可以发现当 <strong>x=0</strong> 的时候，空前缀也会有贡献，因此不能忽略空前缀。</li>
<li>如果循环节 <strong>s</strong> 的01数相等，那么我们可以发现最后循环节一位$num_n$总为0，那么可以分两种情况来讨论<ul>
<li>如果循环节中存在大于等于1个前缀满足期望值x，那么就有无限个满足，因此输出-1</li>
<li>如果循环节 <strong>s</strong> 中不存在满足期望值的前缀，那么 <strong>t</strong> 中也一定不存在</li>
</ul>
</li>
</ul>
<ul>
<li>再来看一般情况，如果一个前缀中包含多个循环节 <strong>s</strong> ,那么前面每个循环节对于最终01个数差的贡献总为$num_n$，因此我们可以用所期望的值 <strong>x</strong>，利用1~n 循环减去每一位的 $num_i$，如果所得是$num_n$的非负倍数，那么就是符合期望的，否则不是。(本来一直这里不太明白，后来发现对于循环节中的每一个位置，在后续循环的过程中，如果$num_n$不为0，那么这个位置每次对应的值总是唯一的)</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> t,cnt,n,x;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				num[i]=num[i<span class="number">-1</span>]+<span class="number">1</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> num[i]=num[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(num[i]==x) flag=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> p=num[n];</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="literal">true</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> m=x-num[i];</span><br><span class="line">				<span class="keyword">if</span>(m%p==<span class="number">0</span>&amp;&amp;m/p&gt;=<span class="number">0</span>) </span><br><span class="line">				&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>) cnt++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="C-Obtain-The-String"><a href="#C-Obtain-The-String" class="headerlink" title="C : Obtain The String"></a>C : <a href="https://codeforces.com/contest/1295/problem/C">Obtain The String</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>​    &nbsp; &nbsp; &nbsp; 给定字符串 <strong>s</strong> 和 <strong>t</strong> ，每次从 <strong>s</strong> 中选取子序列放入起始为空串的 <strong>z</strong> 后，问最少需要多少次操作使得 <strong>z=t</strong></p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​    &nbsp; &nbsp; &nbsp; 看了小姜老师的博客解法说是贪心，想了好一会，好像确实是可以贪心的···? 设置两个指针从 <strong>s</strong> 和 <strong>t</strong> 串的头部开始扫，对于 <strong>t</strong> 串中的每个字母，循环扫 <strong>s</strong> 串在其中找与它相同的，最终的答案就是扫 <strong>s</strong> 串的次数。(小姜老师说这个实质上就是每次尽可能找尽可能多的后缀，仔细想想确实是这样。)不过这么一直暴力扫下去肯定不是最优的方法，想办法去优化。还是借鉴大佬的想法用一个lens*26的跳表，然后O(lent)扫一遍 <strong>t</strong> 即可.</p>
<blockquote>
<p>跳表nxt的作用，用于寻找下一个所寻找字符在s中的位置。</p>
<p>nxt[x][y]用于指向从x位置开始下一个y的位置+1 （next在C++属于保留字，注意不要踩坑）</p>
</blockquote>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn],t[maxn];</span><br><span class="line"><span class="keyword">int</span> nxt[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> p,lens,lent;</span><br><span class="line"><span class="keyword">int</span> pos,ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">	<span class="keyword">while</span>(p--)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">		lent=<span class="built_in">strlen</span>(t),lens=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//		printf("%d",lens);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++)</span><br><span class="line">		&#123;</span><br><span class="line">			nxt[lens+<span class="number">1</span>][c]=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=lens;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]-<span class="string">'a'</span>==c)</span><br><span class="line">				&#123;</span><br><span class="line">					nxt[i][c]=i+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> nxt[i][c]=nxt[i+<span class="number">1</span>][c];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pos=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lent;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			pos=nxt[pos][(<span class="keyword">int</span>)t[i]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				pos=<span class="number">1</span>;</span><br><span class="line">				pos=nxt[pos][(<span class="keyword">int</span>)t[i]-<span class="string">'a'</span>];</span><br><span class="line">				<span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
